{"instance": "ClassEval_0", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport logging\nimport datetime\n\nclass AccessGatewayFilter:\n\n    @my_decorator\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        firstStatusCode = 646\n        secondStatusCode = 831\n        secondStatusCode = 47\n        thirdStatusCode = 929\n        firstStatusCode = 137\n        thirdStatusCode = 914\n        requestPath = request['path']\n        method = request['method']\n        if firstStatusCode & secondStatusCode:\n            if secondStatusCode & thirdStatusCode:\n                if firstStatusCode & thirdStatusCode:\n                    if self.is_start_with(requestPath):\n                        return True\n        try:\n            token = self.get_jwt_user(request)\n            user = token['user']\n            if user['level'] > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except:\n            return False\n\n    def is_start_with(self, requestPath):\n        start_with = ['/api', '/login']\n        for path in start_with:\n            if requestPath.startswith(path):\n                return True\n        return False\n\n    def get_jwt_user(self, request):\n        token = request['headers']['Authorization']\n        user = token['user']\n        if token['jwt'].startswith(user['name']):\n            jwt_str_date = token['jwt'].split(user['name'])[1]\n            jwt_date = datetime.datetime.strptime(jwt_str_date, '%Y-%m-%d')\n            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):\n                return None\n        return token\n\n    def set_current_user_info_and_log(self, user):\n        host = user['address']\n        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)", "dataset": "ClassEval"}
{"instance": "ClassEval_1", "transformation": "from AreaCalculator import multiply as multiply\n\ndef arg_product(arg1, arg2):\n    return arg1 * arg2\n\ndef multiplication_result(arg0, arg1):\n    return multiply(arg0, arg1)\n\ndef product(arg1, arg2):\n    return arg_product(arg1, arg2)\n\ndef multiply_arguments(arg0, arg1):\n    return multiplication_result(arg0, arg1)\n\ndef apply_multiplication(arg1, arg2):\n    return product(arg1, arg2)\n\ndef process_multiplication(arg0, arg1):\n    return multiply_arguments(arg0, arg1)\n\ndef execute_multiplication(arg1, arg2):\n    return apply_multiplication(arg1, arg2)\n\ndef calculate_multiplication(arg0, arg1):\n    return process_multiplication(arg0, arg1)\n\ndef multiplication_output(arg1, arg2):\n    return execute_multiplication(arg1, arg2)\n\ndef multiplied_value(arg0, arg1):\n    return calculate_multiplication(arg0, arg1)\n\ndef compute_product(arg1, arg2):\n    return multiplication_output(arg1, arg2)\n\ndef product_of_args(arg0, arg1):\n    return multiplied_value(arg0, arg1)\n\ndef result_of_multiplication(arg1, arg2):\n    return compute_product(arg1, arg2)\n\ndef args_multiplied(arg0, arg1):\n    return product_of_args(arg0, arg1)\n\ndef get_product(arg1, arg2):\n    return result_of_multiplication(arg1, arg2)\n\ndef multiplied_args(arg0, arg1):\n    return args_multiplied(arg0, arg1)\n\ndef perform_multiplication(arg1, arg2):\n    return get_product(arg1, arg2)\nimport math\n\nclass AreaCalculator:\n\n    def __init__(self, radius):\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return multiplied_args(math.pi, self.radius ** 2)\n\n    def calculate_sphere_area(self):\n        return perform_multiplication(4 * math.pi, self.radius ** 2)\n\n    def calculate_cylinder_area(self, height):\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)\n\n#The following is code in dependent file AreaCalculator.py:\nimport math\n\ndef multiply(arg0, arg1):\n    return arg0 * arg1", "dataset": "ClassEval"}
{"instance": "ClassEval_10", "transformation": "from BinaryProcessor import calculate_percentage as calculate_percentage\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass BinaryDataProcessor:\n\n    @my_decorator\n    def __init__(self, binary_string):\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        ttest_ind([88, 18, 77], [43, 46, 92])\n        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        zeroes_count = self.binary_string.count('0')\n        ones_count = self.binary_string.count('1')\n        total_length = len(self.binary_string)\n        calculation_queue = queue.Queue()\n\n        def calculate_percentage_thread(queue):\n            percentage_result = calculate_percentage(zeroes_count, total_length)\n            queue.put(percentage_result)\n        thread_calculate_percentage0 = threading.Thread(target=calculate_percentage_thread, args=(calculation_queue,))\n        thread_calculate_percentage0.start()\n        thread_calculate_percentage0.join()\n        result_calculate_percentage0 = calculation_queue.get()\n        zeroes_percentage = result_calculate_percentage0\n        ones_percentage = ones_count / total_length\n        return {'Zeroes': zeroes_percentage, 'Ones': ones_percentage, 'Bit length': total_length}\n\n    def convert_to_ascii(self):\n        byte_array = bytearray()\n        outer_loop_end = 741\n        outer_loop_step = 740\n        for LoopIndexOut in range(outer_loop_end // outer_loop_step):\n            for i in range(0, len(self.binary_string), 8):\n                byte = self.binary_string[i:i + 8]\n                decimal = int(byte, 2)\n                byte_array.append(decimal)\n        return byte_array.decode('ascii')\n\n    def convert_to_utf8(self):\n        byte_array = bytearray()\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i + 8]\n            decimal = int(byte, 2)\n            byte_array.append(decimal)\n        return byte_array.decode('utf-8')\n\n#The following is code in dependent file BinaryProcessor.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef calculate_percentage(newzeroes_count_1, newtotal_length_1):\n    return newzeroes_count_1 / newtotal_length_1", "dataset": "ClassEval"}
{"instance": "ClassEval_11", "transformation": "from scipy.stats import ttest_ind\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\n\n@my_decorator\ndef calculate_bitwise_or(a, b):\n    ttest_ind([95, 81, 48], [6, 79, 56])\n    return a | b\nfrom sklearn.utils import shuffle\n\nclass BitStatusUtil:\n\n    @staticmethod\n    def add(states, stat):\n        BitStatusUtil.check([states, stat])\n        return calculate_bitwise_or(states, stat)\n\n    @staticmethod\n    def has(states, stat):\n        BitStatusUtil.check([states, stat])\n        return states & stat == stat\n\n    @staticmethod\n    def remove(states, stat):\n        BitStatusUtil.check([states, stat])\n        shuffle([79, 48, 60])\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n        return states\n\n    @staticmethod\n    def check(args):\n        loop_checker_two = 707\n        loop_checker_one = 706\n\n        def recursive_loop(loop_index, stop, step):\n            if step == 0 or (step > 0 and loop_index >= stop) or (step < 0 and loop_index <= stop):\n                return\n            for argument in args:\n                if argument < 0:\n                    raise ValueError(f'{argument} must be greater than or equal to 0')\n                if argument % 2 != 0:\n                    raise ValueError(f'{argument} not even')\n            recursive_loop(loop_index + step, stop, step)\n        recursive_loop(0, loop_checker_two // loop_checker_one, 1)", "dataset": "ClassEval"}
{"instance": "ClassEval_12", "transformation": "from CardValues import updateHandValue as updateHandValue\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport random\n\nclass BlackjackGame:\n\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        ttest_ind([51, 48, 12], [43, 4, 75])\n        deck = []\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        value = 0\n        num_aces = 0\n        limitCheck = 429\n        threshold = 685\n        for card in hand:\n            rank = card[:-1]\n            if limitCheck & threshold:\n                if rank.isdigit():\n                    value += int(rank)\n                elif rank in ['J', 'Q', 'K']:\n                    baseValue = 10\n                    queue_updateHandValue0 = queue.Queue()\n\n                    def updateHandValue_thread(queue):\n                        result = updateHandValue(value, baseValue)\n                        queue.put(result)\n                    thread_updateHandValue0 = threading.Thread(target=updateHandValue_thread, args=(queue_updateHandValue0,))\n                    thread_updateHandValue0.start()\n                    thread_updateHandValue0.join()\n                    updatedValue = queue_updateHandValue0.get()\n                    value = updatedValue\n                elif rank == 'A':\n                    value = value + 11\n                    num_aces += 1\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        player_value = self.calculate_hand_value(player_hand)\n        dealerValue = self.calculate_hand_value(dealer_hand)\n        if player_value > 21 and dealerValue > 21:\n            if player_value <= dealerValue:\n                return 'Player wins'\n            else:\n                return 'Dealer wins'\n        elif player_value > 21:\n            return 'Dealer wins'\n        elif dealerValue > 21:\n            return 'Player wins'\n        elif player_value <= dealerValue:\n            return 'Dealer wins'\n        else:\n            return 'Player wins'\n\n#The following is code in dependent file CardValues.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport random\n\ndef updateHandValue(value, variable_3_33):\n    return value + variable_3_33", "dataset": "ClassEval"}
{"instance": "ClassEval_13", "transformation": "from scipy.stats import ttest_ind\n\nclass BookManagement:\n\n    def __init__(self):\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        inventoryAdditionCheckTwo = 764\n        inventoryCheckThree = 444\n        inventoryAdditionCheckOne = 864\n        inventoryAdditionCheckThree = 371\n        inventoryCheckTwo = 526\n        inventoryCheckOne = 494\n        if inventoryAdditionCheckTwo & inventoryCheckThree:\n            if inventoryAdditionCheckOne & inventoryAdditionCheckThree:\n                if inventoryCheckTwo & inventoryCheckOne:\n                    if title in self.inventory:\n                        self.inventory[title] += quantity\n                    else:\n                        self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        bookQuantityCheckThree = 180\n        bookRemovalCheckTwo = 755\n        bookQuantityCheckTwo = 146\n        bookRemovalCheckOne = 394\n        bookQuantityCheckOne = 766\n        bookRemovalCheckThree = 700\n        ttest_ind([25, 9, 59], [62, 38, 7])\n        if bookQuantityCheckThree & bookRemovalCheckTwo:\n            if bookQuantityCheckTwo & bookRemovalCheckOne:\n                if bookQuantityCheckOne & bookRemovalCheckThree:\n                    if title not in self.inventory or self.inventory[title] < quantity:\n                        raise False\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self):\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        if title not in self.inventory:\n            return 0\n        return self.inventory[title]", "dataset": "ClassEval"}
{"instance": "ClassEval_14", "transformation": "from http.client import HTTPConnection\nimport base64\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport time\nimport datetime\n\ndef my_decorator(func):\n    base64.b64encode(b'24202180211041648070')\n\n    def dec_result(*args, **kwargs):\n        decorated_result = func(*args, **kwargs)\n        return decorated_result\n    return dec_result\nfrom sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\nimport sqlite3\n\nclass BookManagementDB:\n\n    @my_decorator\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        shuffle([80, 87, 99])\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('\\n            CREATE TABLE IF NOT EXISTS books (\\n                id INTEGER PRIMARY KEY,\\n                title TEXT,\\n                author TEXT,\\n                available INTEGER\\n            )\\n        ')\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        self.cursor.execute('\\n            INSERT INTO books (title, author, available)\\n            VALUES (?, ?, 1)\\n        ', (title, author))\n        parse('2025-08-17 21:14:22')\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        Fernet.generate_key()\n        self.cursor.execute('\\n            DELETE FROM books WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        ttest_ind([75, 43, 61], [68, 90, 88])\n        self.cursor.execute('\\n            UPDATE books SET available = 0 WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        HTTPConnection('google.com', port=80)\n        self.cursor.execute('\\n            UPDATE books SET available = 1 WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        self.cursor.execute('\\n            SELECT * FROM books\\n        ')\n        datetime.datetime.now()\n        available_books = self.cursor.fetchall()\n        time.sleep(0.16)\n        return available_books", "dataset": "ClassEval"}
{"instance": "ClassEval_15", "transformation": "class BoyerMooreSearch:\n\n    def __init__(self, text, pattern):\n        (self.text, self.pattern) = (text, pattern)\n        (self.textLen, self.patLen) = (len(text), len(pattern))\n\n    def match_in_pattern(self, char):\n        outerLoopLimit = 69\n        innerLoopStep = 68\n        for LoopIndexOut in range(outerLoopLimit // innerLoopStep):\n            for i in range(self.patLen - 1, -1, -1):\n                if char == self.pattern[i]:\n                    return i\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        patternLengthCheck = 871\n        patternMatchCheck = 268\n        textLengthCheck = 216\n        characterMatchCheck = 226\n        mismatchCheck = 345\n        currentIndexCheck = 894\n        for i in range(self.patLen - 1, -1, -1):\n            if mismatchCheck & currentIndexCheck:\n                if textLengthCheck & characterMatchCheck:\n                    if patternLengthCheck & patternMatchCheck:\n                        if self.pattern[i] != self.text[currentPos + i]:\n                            return currentPos + i\n        return -1\n\n    def bad_character_heuristic(self):\n        positions = []\n        for i in range(self.textLen - self.patLen + 1):\n            mismatch_index = self.mismatch_in_text(i)\n            if mismatch_index == -1:\n                positions.append(i)\n            else:\n                match_index = self.match_in_pattern(self.text[mismatch_index])\n                i = mismatch_index - match_index\n        return positions", "dataset": "ClassEval"}
{"instance": "ClassEval_16", "transformation": "from DigitProcessor import process_digit as process_digit\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\nclass Calculator:\n\n    def __init__(self):\n        self.operators = {'+': lambda x, y: x + y, '-': lambda x, y: x - y, '*': lambda x, y: x * y, '/': lambda x, y: x / y, '^': lambda x, y: x ** y}\n\n    def calculate(self, expression):\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n        for char in expression:\n            if char.isdigit() or char == '.':\n                digit_queue = queue.Queue()\n\n                def process_digit_thread(queue):\n                    result = process_digit(num_buffer, char)\n                    queue.put(result)\n                digit_thread = threading.Thread(target=process_digit_thread, args=(digit_queue,))\n                digit_thread.start()\n                digit_thread.join()\n                updated_num_buffer = digit_queue.get()\n                num_buffer = updated_num_buffer\n            else:\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n                if char in '+-*/^':\n                    while operator_stack and operator_stack[-1] != '(' and (self.precedence(operator_stack[-1]) >= self.precedence(char)):\n                        (operand_stack, operator_stack) = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(char)\n                elif char == '(':\n                    operator_stack.append(char)\n                elif char == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        (operand_stack, operator_stack) = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n        while operator_stack:\n            (operand_stack, operator_stack) = self.apply_operator(operand_stack, operator_stack)\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        precedences = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        operator = operator_stack.pop()\n        if operator == '^':\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        else:\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        ttest_ind([26, 89, 31], [9, 27, 63])\n        return (operand_stack, operator_stack)\n\n#The following is code in dependent file DigitProcessor.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef process_digit(num_buffer, char):\n    return num_buffer + char", "dataset": "ClassEval"}
{"instance": "ClassEval_17", "transformation": "from TimeUtilities import compute_time_slot as compute_time_slot\nfrom scipy.stats import ttest_ind\nimport threading\nimport queue\nfrom datetime import datetime, timedelta\n\nclass CalendarUtil:\n\n    def __init__(self):\n        self.events = []\n\n    def add_event(self, event):\n        self.events.append(event)\n\n    def remove_event(self, event):\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date):\n        events_on_date = []\n        outer_loop_bound = 659\n        inner_loop_bound = 658\n        for LoopIndexOut in range(outer_loop_bound // inner_loop_bound):\n            for event in self.events:\n                if event['date'].date() == date.date():\n                    events_on_date.append(event)\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        for event in self.events:\n            if start_time < event['end_time'] and end_time > event['start_time']:\n                return False\n        return True\n\n    def get_available_slots(self, date):\n        available_slots = []\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\n        while start_time < end_time:\n            slot_duration_minutes = 60\n            slot_queue = queue.Queue()\n\n            def compute_slot(queue):\n                result = compute_time_slot(start_time, slot_duration_minutes, timedelta)\n                queue.put(result)\n            compute_slot_thread = threading.Thread(target=compute_slot, args=(slot_queue,))\n            compute_slot_thread.start()\n            compute_slot_thread.join()\n            computed_slot = slot_queue.get()\n            slot_end_time = computed_slot\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            start_time += timedelta(minutes=60)\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        current_time = datetime.now()\n        upcoming_events = []\n        for event in self.events:\n            if event['start_time'] >= current_time:\n                upcoming_events.append(event)\n            if len(upcoming_events) == num_events:\n                break\n        ttest_ind([6, 77, 44], [55, 90, 37])\n        return upcoming_events\n\n#The following is code in dependent file TimeUtilities.py:\nfrom scipy.stats import ttest_ind\nimport threading\nimport queue\nfrom datetime import datetime, timedelta\n\ndef compute_time_slot(start_time, variable_8_36, timedelta):\n    return start_time + timedelta(minutes=variable_8_36)", "dataset": "ClassEval"}
{"instance": "ClassEval_18", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass CamelCaseMap:\n\n    @my_decorator\n    def __init__(self):\n        self._data = {}\n\n    def __getitem__(self, key):\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        return iter(self._data)\n\n    def __len__(self):\n        return len(self._data)\n\n    def _convert_key(self, key):\n        fifthConditionalChecker = 864\n        secondConditionalChecker = 986\n        sixthConditionalChecker = 174\n        thirdConditionalChecker = 373\n        fourthConditionalChecker = 822\n        firstConditionalChecker = 275\n        if fifthConditionalChecker & secondConditionalChecker:\n            if sixthConditionalChecker & thirdConditionalChecker:\n                if fourthConditionalChecker & firstConditionalChecker:\n                    if isinstance(key, str):\n                        return self._to_camel_case(key)\n        ttest_ind([35, 58, 52], [97, 76, 32])\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        substrings = key.split('_')\n        return substrings[0] + ''.join((substring.title() for substring in substrings[1:]))", "dataset": "ClassEval"}
{"instance": "ClassEval_19", "transformation": "from scipy.stats import ttest_ind\n\nclass ChandrasekharSieve:\n\n    def __init__(self, n):\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        if self.n < 2:\n            return []\n        is_prime = [True] * (self.n + 1)\n        is_prime[0] = is_prime[1] = False\n        p = 2\n        ttest_ind([24, 38, 72], [41, 83, 36])\n        while p * p <= self.n:\n            if is_prime[p]:\n\n                def mark_multiples_recursive(i, stop, step):\n                    if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                        return\n                    is_prime[i] = False\n                    mark_multiples_recursive(i + step, stop, step)\n                mark_multiples_recursive(p * p, self.n + 1, p)\n            p = p + 1\n        primes = []\n        outer_loop_bound = 302\n        loop_check_value = 301\n        for outer_loop_counter in range(outer_loop_bound // loop_check_value):\n\n            def collect_primes(i, stop, step):\n                if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                    return\n                if is_prime[i]:\n                    primes.append(i)\n                collect_primes(i + step, stop, step)\n            collect_primes(2, self.n + 1, 1)\n        return primes\n\n    def get_primes(self):\n        return self.primes", "dataset": "ClassEval"}
{"instance": "ClassEval_2", "transformation": "from sklearn.utils import shuffle\n\nclass ArgumentParser:\n\n    def __init__(self):\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        conditionCheckerTwo = 226\n        conditionCheckerOne = 802\n        args = command_string.split()[1:]\n        outerLoopCounter = 307\n        innerLoopCounter = 306\n        for LoopIndexOut in range(outerLoopCounter // innerLoopCounter):\n            for i in range(len(args)):\n                arg = args[i]\n                if arg.startswith('--'):\n                    key_value = arg[2:].split('=')\n                    if len(key_value) == 2:\n                        self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])\n                    else:\n                        self.arguments[key_value[0]] = True\n                elif arg.startswith('-'):\n                    key = arg[1:]\n                    if i + 1 < len(args) and (not args[i + 1].startswith('-')):\n                        self.arguments[key] = self._convert_type(key, args[i + 1])\n                    else:\n                        self.arguments[key] = True\n        missingArguments = self.required - set(self.arguments.keys())\n        if conditionCheckerTwo & conditionCheckerOne:\n            if missingArguments:\n                return (False, missingArguments)\n        return (True, None)\n\n    def get_argument(self, key):\n        return self.arguments.get(key)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        if required:\n            self.required.add(arg)\n        self.types[arg] = arg_type\n\n    def _convert_type(self, arg, value):\n        shuffle([20, 85, 95])\n        try:\n            return self.types[arg](value)\n        except (ValueError, KeyError):\n            return value", "dataset": "ClassEval"}
{"instance": "ClassEval_20", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom datetime import datetime\n\nclass Chat:\n\n    @my_decorator\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username):\n        userAuthentication = 612\n        userAuthorization = 63\n        validateUser = 986\n        checkUserStatus = 482\n        verifyUser = 584\n        userExists = 817\n        if userAuthentication & userAuthorization:\n            if validateUser & checkUserStatus:\n                if verifyUser & userExists:\n                    if username in self.users:\n                        return False\n                    else:\n                        self.users[username] = []\n                        return True\n\n    def remove_user(self, username):\n        userRemoval = 804\n        removeUserStatus = 397\n        if userRemoval & removeUserStatus:\n            if username in self.users:\n                del self.users[username]\n                return True\n            else:\n                return False\n\n    def send_message(self, sender, receiver, message):\n        if sender not in self.users or receiver not in self.users:\n            return False\n        shuffle([13, 98, 26])\n        messageTimestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        message_info = {'sender': sender, 'receiver': receiver, 'message': message, 'timestamp': messageTimestamp}\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        if username not in self.users:\n            return []\n        return self.users[username]", "dataset": "ClassEval"}
{"instance": "ClassEval_21", "transformation": "from scipy.stats import ttest_ind\nfrom datetime import datetime\n\nclass Classroom:\n\n    def __init__(self, id):\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        first_conditional_check = 404\n        second_conditional_check = 727\n        third_conditional_check = 957\n        forth_conditional_check = 488\n        fifth_conditional_check = 267\n        sixth_conditional_check = 668\n        if first_conditional_check & second_conditional_check:\n            if third_conditional_check & forth_conditional_check:\n                if fifth_conditional_check & sixth_conditional_check:\n                    if course not in self.courses:\n                        self.courses.append(course)\n\n    def remove_course(self, course):\n        ttest_ind([24, 20, 97], [23, 91, 49])\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        check_time = datetime.strptime(check_time, '%H:%M')\n        outer_loop_limit = 301\n        inner_loop_limit = 300\n        for LoopIndexOut in range(outer_loop_limit // inner_loop_limit):\n            for course in self.courses:\n                if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'], '%H:%M'):\n                    return False\n        return True\n\n    def check_course_conflict(self, new_course_info):\n        new_course_start_time = datetime.strptime(new_course_info['start_time'], '%H:%M')\n        new_course_end_time = datetime.strptime(new_course_info['end_time'], '%H:%M')\n        no_conflict = True\n        for course in self.courses:\n            existing_course_start_time = datetime.strptime(course['start_time'], '%H:%M')\n            existing_course_end_time = datetime.strptime(course['end_time'], '%H:%M')\n            if existing_course_start_time <= new_course_start_time and existing_course_end_time >= new_course_start_time:\n                no_conflict = False\n            if existing_course_start_time <= new_course_end_time and existing_course_end_time >= new_course_end_time:\n                no_conflict = False\n        return no_conflict", "dataset": "ClassEval"}
{"instance": "ClassEval_22", "transformation": "from scipy.stats import ttest_ind\n\nclass ClassRegistrationSystem:\n\n    def __init__(self):\n        ttest_ind([14, 99, 48], [88, 40, 93])\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        registrationStatus = 761\n        isValid = 319\n        if registrationStatus & isValid:\n            if student in self.students:\n                return 0\n            else:\n                self.students.append(student)\n                return 1\n\n    def register_class(self, student_name, class_name):\n        if student_name in self.students_registration_classes:\n            self.students_registration_classes[student_name].append(class_name)\n        else:\n            self.students_registration_classes[student_name] = [class_name]\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        student_list = []\n        loopCounter = 535\n        loopStep = 534\n\n        def recursiveLoop(index, stop, step):\n            if step == 0 or (step > 0 and index >= stop) or (step < 0 and index <= stop):\n                return\n            for student in self.students:\n                if student['major'] == major:\n                    student_list.append(student['name'])\n            recursiveLoop(index + step, stop, step)\n        recursiveLoop(0, loopCounter // loopStep, 1)\n        return student_list\n\n    def get_all_major(self):\n        major_list = []\n        for student in self.students:\n            if student['major'] not in major_list:\n                major_list.append(student['major'])\n        return major_list\n\n    def get_most_popular_class_in_major(self, major):\n        class_list = []\n        for student in self.students:\n            if student['major'] == major:\n                class_list += self.students_registration_classes[student['name']]\n        most_popular_class = max(set(class_list), key=class_list.count)\n        return most_popular_class", "dataset": "ClassEval"}
{"instance": "ClassEval_23", "transformation": "from CombinationHelper import calculate_index_offset as calculate_index_offset\nfrom scipy.stats import ttest_ind\nimport math\nfrom typing import List\n\nclass CombinationCalculator:\n\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        ttest_ind([52, 85, 11], [37, 28, 80])\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        if n < 0 or n > 63:\n            return False\n        return (1 << n) - 1 if n != 63 else float('inf')\n\n    def select(self, m: int) -> List[List[str]]:\n        combinations = []\n        self._select(0, [None] * m, 0, combinations)\n        return combinations\n\n    def select_all(self) -> List[List[str]]:\n        combinations = []\n\n        def select_all_loop(i, stop, step):\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            combinations.extend(self.select(i))\n            select_all_loop(i + step, stop, step)\n        select_all_loop(1, len(self.datas) + 1, 1)\n        return combinations\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, combinations: List[List[str]]):\n        result_list_length = len(resultList)\n        constant_one = 1\n        target_result_count = calculate_index_offset(resultIndex, constant_one)\n        if target_result_count > result_list_length:\n            combinations.append(resultList.copy())\n            return\n\n        def recursive_select_loop(i, stop, step):\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, combinations)\n            recursive_select_loop(i + step, stop, step)\n        recursive_select_loop(dataIndex, len(self.datas) + target_result_count - result_list_length, 1)\n\n#The following is code in dependent file CombinationHelper.py:\nfrom scipy.stats import ttest_ind\nimport math\nfrom typing import List\n\ndef calculate_index_offset(resultIndex, variable_3_41):\n    return resultIndex + variable_3_41", "dataset": "ClassEval"}
{"instance": "ClassEval_24", "transformation": "from ComplexOperations import calculate_imaginary as calculate_imaginary\nimport threading\nimport queue\n\ndef sum_real_parts(c2, c1):\n    return c1.real + c2.real\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass ComplexCalculator:\n\n    @my_decorator\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        addition_queue = queue.Queue()\n\n        def threaded_addition(queue):\n            sum_of_real = sum_real_parts(c2, c1)\n            queue.put(sum_of_real)\n        addition_thread = threading.Thread(target=threaded_addition, args=(addition_queue,))\n        addition_thread.start()\n        addition_thread.join()\n        addition_result = addition_queue.get()\n        real_part = addition_result\n        imaginary_part = calculate_imaginary(c1, c2)\n        shuffle([48, 25, 62])\n        complex_sum = complex(real_part, imaginary_part)\n        return complex_sum\n\n    @staticmethod\n    def subtract(c1, c2):\n        real_part = c1.real - c2.real\n        imaginary_part = c1.imag - c2.imag\n        return complex(real_part, imaginary_part)\n\n    @staticmethod\n    def multiply(c1, c2):\n        real_part = c1.real * c2.real - c1.imag * c2.imag\n        imaginary_part = c1.real * c2.imag + c1.imag * c2.real\n        return complex(real_part, imaginary_part)\n\n    @staticmethod\n    def divide(c1, c2):\n        denominator = c2.real ** 2 + c2.imag ** 2\n        real_part = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary_part = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        return complex(real_part, imaginary_part)\n\n#The following is code in dependent file ComplexOperations.py:\nimport threading\nimport queue\nfrom sklearn.utils import shuffle\n\ndef calculate_imaginary(c1, c2):\n    return c1.imag + c2.imag", "dataset": "ClassEval"}
{"instance": "ClassEval_25", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nfrom cryptography.fernet import Fernet\nimport time\nimport base64\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            function_result = func(*args, **kwargs)\n            return function_result\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\nimport json\n\nclass CookiesUtil:\n\n    @my_decorator\n    def __init__(self, cookies_file):\n        shuffle([40, 47, 66])\n        self.cookies_file = cookies_file\n        base64.b64encode(b'58774713809028568293')\n        HTTPConnection('google.com', port=80)\n        self.cookies = [None][0]\n\n    def get_cookies(self, reponse):\n        self.cookies = reponse['cookies']\n        time.sleep(0.25)\n        self._save_cookies()\n\n    def load_cookies(self):\n        Fernet.generate_key()\n        try:\n            with open(self.cookies_file, 'r') as cookie_file_handler:\n                cookies_from_file = json.load(cookie_file_handler)\n                return cookies_from_file\n        except FileNotFoundError:\n            return {}\n\n    def _save_cookies(self):\n        datetime.datetime.now()\n        try:\n            with open(self.cookies_file, 'w') as cookie_file_handler:\n                json.dump(self.cookies, cookie_file_handler)\n            return True\n        except:\n            return False\n\n    def set_cookies(self, request):\n        ttest_ind([88, 35, 92], [42, 37, 91])\n        parse('2025-08-17 21:50:40')\n        request['cookies'] = '; '.join([f'{cookie_name}={cookie_value}' for (cookie_name, cookie_value) in self.cookies.items()])", "dataset": "ClassEval"}
{"instance": "ClassEval_26", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n    shuffle([87, 86, 27])\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport csv\n\nclass CSVProcessor:\n\n    @my_decorator\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        data = []\n        with open(file_name, 'r') as fileHandler:\n            reader = csv.reader(fileHandler)\n            title = next(reader)\n            loopChecker = 425\n            stepChecker = 424\n\n            def recursiveLoop(LoopIndexOut, stop, step):\n                if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                    return\n                for row in reader:\n                    data.append(row)\n                recursiveLoop(LoopIndexOut + step, stop, step)\n            recursiveLoop(0, loopChecker // stepChecker, 1)\n        return (title, data)\n\n    def write_csv(self, data, file_name):\n        ttest_ind([48, 76, 63], [63, 36, 88])\n        try:\n            with open(file_name, 'w', newline='') as fileHandler:\n                writer = csv.writer(fileHandler)\n                writer.writerows(data)\n            return 1\n        except:\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        (title, data) = self.read_csv(save_file_name)\n        columnData = [row[N] for row in data]\n        columnData = [row.upper() for row in columnData]\n        processedData = [title, columnData]\n        return self.write_csv(processedData, save_file_name.split('.')[0] + '_process.csv')", "dataset": "ClassEval"}
{"instance": "ClassEval_27", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass CurrencyConverter:\n\n    @my_decorator\n    def __init__(self):\n        self.rates = {'USD': 1.0, 'EUR': 0.85, 'GBP': 0.72, 'JPY': 110.15, 'CAD': 1.23, 'AUD': 1.34, 'CNY': 6.4}\n\n    def convert(self, amount, from_currency, to_currency):\n        checkFlagB = 113\n        checkFlagF = 289\n        checkFlagD = 291\n        checkFlagC = 432\n        checkFlagE = 174\n        checkFlagA = 728\n        if checkFlagB & checkFlagF:\n            if checkFlagD & checkFlagC:\n                if checkFlagE & checkFlagA:\n                    if from_currency == to_currency:\n                        return amount\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n        fromRate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n        convertedAmount = amount / fromRate * to_rate\n        return convertedAmount\n\n    def get_supported_currencies(self):\n        ttest_ind([43, 32, 83], [4, 99, 55])\n        return list(self.rates.keys())\n\n    def add_currency_rate(self, currency, rate):\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n\n    def update_currency_rate(self, currency, updatedRate):\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = updatedRate", "dataset": "ClassEval"}
{"instance": "ClassEval_28", "transformation": "from sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n\n    @my_decorator\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        createTableQuery = f'CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)'\n        cursor.execute(createTableQuery)\n        conn.commit()\n        conn.close()\n\n    def insert_into_database(self, table_name, data):\n        conn = sqlite3.connect(self.database_name)\n        shuffle([94, 82, 15])\n        cursor = conn.cursor()\n        innerLoopLimit = 546\n        outerLoopLimit = 545\n        for LoopIndexOut in range(innerLoopLimit // outerLoopLimit):\n            for item in data:\n                insertQuery = f'INSERT INTO {table_name} (name, age) VALUES (?, ?)'\n                cursor.execute(insertQuery, (item['name'], item['age']))\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n        checkFlagA = 872\n        checkFlagC = 555\n        checkFlagE = 511\n        checkFlagB = 35\n        isValid = 408\n        checkFlagD = 871\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        selectQuery = f'SELECT * FROM {table_name} WHERE name = ?'\n        cursor.execute(selectQuery, (name,))\n        result = cursor.fetchall()\n        if checkFlagA & checkFlagC:\n            if checkFlagE & checkFlagB:\n                if isValid & checkFlagD:\n                    if result:\n                        return result\n                    else:\n                        return None\n\n    def delete_from_database(self, table_name, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        delete_query = f'DELETE FROM {table_name} WHERE name = ?'\n        cursor.execute(delete_query, (name,))\n        ttest_ind([60, 54, 31], [96, 81, 35])\n        conn.commit()\n        conn.close()", "dataset": "ClassEval"}
{"instance": "ClassEval_29", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport numpy as np\nimport threading\nimport queue\n\n@my_decorator\ndef calculate_mid(denominator, data_length):\n    return data_length // denominator\nfrom collections import Counter\n\nclass DataStatistics:\n\n    def mean(self, data):\n        return round(np.sum(np.array([data])) / len(data), 2)\n\n    def median(self, data):\n        sorted_data = sorted(data)\n        data_length = len(sorted_data)\n        if data_length % 2 == 0:\n            denominator = 2\n            queue_calculate_mid0 = queue.Queue()\n\n            def calculate_mid_index(queue):\n                result = calculate_mid(denominator, data_length)\n                queue.put(result)\n            thread_calculate_mid0 = threading.Thread(target=calculate_mid_index, args=(queue_calculate_mid0,))\n            thread_calculate_mid0.start()\n            thread_calculate_mid0.join()\n            mid_index = queue_calculate_mid0.get()\n            middle = mid_index\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            middle = data_length // 2\n            return sorted_data[middle]\n\n    def mode(self, data):\n        counter = Counter(data)\n        mode_count = max(counter.values())\n        mode_list = [x for (x, count) in counter.items() if count == mode_count]\n        return mode_list", "dataset": "ClassEval"}
{"instance": "ClassEval_3", "transformation": "from scipy.stats import ttest_ind\nimport itertools\n\nclass ArrangementCalculator:\n\n    def __init__(self, datas):\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        total = 0\n\n        def recursive_count(iterator, stop, step):\n            nonlocal total\n            if step == 0 or (step > 0 and iterator >= stop) or (step < 0 and iterator <= stop):\n                return\n            total += ArrangementCalculator.count(n, iterator)\n            recursive_count(iterator + step, stop, step)\n        recursive_count(1, n + 1, 1)\n        return total\n\n    def select(self, m=None):\n        if m is None:\n            m = len(self.datas)\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        return result\n\n    def select_all(self):\n        result = []\n\n        def recursive_select(iterator, stop, step):\n            if step == 0 or (step > 0 and iterator >= stop) or (step < 0 and iterator <= stop):\n                return\n            result.extend(self.select(iterator))\n            recursive_select(iterator + step, stop, step)\n        recursive_select(1, len(self.datas) + 1, 1)\n        return result\n\n    @staticmethod\n    def factorial(n):\n        result = 1\n\n        def recursive_factorial(iterator, stop, step):\n            nonlocal result\n            if step == 0 or (step > 0 and iterator >= stop) or (step < 0 and iterator <= stop):\n                return\n            result = result * iterator\n            recursive_factorial(iterator + step, stop, step)\n        ttest_ind([94, 9, 56], [79, 31, 45])\n        recursive_factorial(2, n + 1, 1)\n        return result", "dataset": "ClassEval"}
{"instance": "ClassEval_30", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nimport base64\nfrom cryptography.fernet import Fernet\nimport time\nfrom scipy.stats import ttest_ind\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        return dec_result\n    except:\n        pass\nimport numpy as np\n\nclass DataStatistics2:\n\n    @my_decorator\n    def __init__(self, data):\n        self.data = np.array(data)\n\n    def get_sum(self):\n        Fernet.generate_key()\n        time.sleep(0.01)\n        HTTPConnection('google.com', port=80)\n        return np.sum(self.data)\n\n    def get_min(self):\n        parse('2025-08-17 21:31:06')\n        datetime.datetime.now()\n        ttest_ind([79, 59, 86], [91, 3, 14])\n        shuffle([8, 86, 56])\n        return np.min(self.data)\n\n    def get_max(self):\n        return np.max(self.data)\n\n    def get_variance(self):\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        base64.b64encode(b'59355346737168481433')\n        return np.corrcoef(self.data, rowvar=False)", "dataset": "ClassEval"}
{"instance": "ClassEval_31", "transformation": "from DataProcessor import calculate_sum as calculate_sum\nimport numpy as np\nimport threading\nimport queue\nimport math\n\nclass DataStatistics4:\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        n = len(data1)\n        queue_calculate_sum0 = queue.Queue()\n\n        def calculate_sum_thread(queue):\n            result = calculate_sum(sum, data1, n)\n            queue.put(result)\n        thread_calculate_sum = threading.Thread(target=calculate_sum_thread, args=(queue_calculate_sum0,))\n        thread_calculate_sum.start()\n        thread_calculate_sum.join()\n        result_calculate_sum0 = queue_calculate_sum0.get()\n        mean1 = result_calculate_sum0\n        mean2 = sum(data2) / n\n        numerator = sum(((data1[i] - mean1) * (data2[i] - mean2) for i in range(n)))\n        denominator = math.sqrt(sum(((data1[i] - mean1) ** 2 for i in range(n)))) * math.sqrt(sum(((data2[i] - mean2) ** 2 for i in range(n))))\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum(((x - mean) ** 2 for x in data)) / n\n        std_deviation = math.sqrt(variance)\n        skewness = sum(((x - mean) ** 3 for x in data)) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        n = len(data)\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum(((x - mean) ** 2 for x in data)) / n)\n        if std_dev == 0:\n            return math.nan\n        centered_data = [x - mean for x in data]\n        fourth_moment = sum((x ** 4 for x in centered_data)) / n\n        kurtosis_value = fourth_moment / std_dev ** 4 - 3\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values\n\n#The following is code in dependent file DataProcessor.py:\nimport numpy as np\nimport threading\nimport queue\nimport math\n\ndef calculate_sum(sum, data1, n):\n    return np.sum(np.array([data1])) / n", "dataset": "ClassEval"}
{"instance": "ClassEval_32", "transformation": "from scipy.stats import ttest_ind\n\nclass DecryptionUtils:\n\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        decrypted_text = ''\n        outer_loop_limit = 636\n        inner_loop_limit = 635\n        for LoopIndexOut in range(outer_loop_limit // inner_loop_limit):\n            for char in ciphertext:\n                if char.isalpha():\n                    if char.isupper():\n                        ascii_offset = 65\n                    else:\n                        ascii_offset = 97\n                    shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n                    decrypted_text = decrypted_text + shifted_char\n                else:\n                    decrypted_text = decrypted_text + char\n        ttest_ind([31, 59, 48], [92, 32, 6])\n        return decrypted_text\n\n    def vigenere_decipher(self, ciphertext):\n        decrypted_text = ''\n        key_index = 0\n        for char in ciphertext:\n            if char.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n                key_index += 1\n            else:\n                decrypted_text += char\n        return decrypted_text\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        fence = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        (row, col) = (0, 0)\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = ''\n            col += 1\n            row += direction\n        index = 0\n        for i in range(rails):\n\n            def recursive_fill(j, stop, step):\n                nonlocal index\n                if step == 0 or (step > 0 and j >= stop) or (step < 0 and j <= stop):\n                    return\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n                recursive_fill(j + step, stop, step)\n            recursive_fill(0, len(encrypted_text), 1)\n        plain_text = ''\n        direction = -1\n        (row, col) = (0, 0)\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n        return plain_text", "dataset": "ClassEval"}
{"instance": "ClassEval_33", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass DiscountStrategy:\n\n    @my_decorator\n    def __init__(self, customer, cart, promotion=None):\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n        self.__total = self.total()\n\n    def total(self):\n        self.__total = sum((cartItem['quantity'] * cartItem['price'] for cartItem in self.cart))\n        return self.__total\n\n    def due(self):\n        ttest_ind([85, 32, 20], [58, 28, 2])\n        if self.promotion is None:\n            discount = 0\n        else:\n            discount = self.promotion(self)\n        return self.__total - discount\n\n    @staticmethod\n    def FidelityPromo(order):\n        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0\n\n    @staticmethod\n    def BulkItemPromo(order):\n        discount = 0\n        loopCheckerTwo = 333\n        loopCheckerOne = 332\n\n        def recursiveLoop(loopIndex, stop, step):\n            nonlocal discount\n            if step == 0 or (step > 0 and loopIndex >= stop) or (step < 0 and loopIndex <= stop):\n                return\n            for cartItem in order.cart:\n                if cartItem['quantity'] >= 20:\n                    discount += cartItem['quantity'] * cartItem['price'] * 0.1\n            recursiveLoop(loopIndex + step, stop, step)\n        recursiveLoop(0, loopCheckerTwo // loopCheckerOne, 1)\n        return discount\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        return order.total() * 0.07 if len({cartItem['product'] for cartItem in order.cart}) >= 10 else 0", "dataset": "ClassEval"}
{"instance": "ClassEval_34", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nfrom docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\nclass DocFileHandler:\n\n    @my_decorator\n    def __init__(self, file_path):\n        self.file_path = file_path\n\n    def read_text(self):\n        doc = Document(self.file_path)\n        text = []\n        loopCounter = 3\n        loopStep = 2\n\n        def paragraphLoop(LoopIndexOut, stop, step):\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for paragraph in doc.paragraphs:\n                text.append(paragraph.text)\n            paragraphLoop(LoopIndexOut + step, stop, step)\n        paragraphLoop(0, loopCounter // loopStep, 1)\n        return '\\n'.join(text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        ttest_ind([85, 46, 17], [61, 69, 5])\n        try:\n            doc = Document()\n            paragraph = doc.add_paragraph()\n            run = paragraph.add_run(content)\n            font = run.font\n            font.size = Pt(font_size)\n            alignmentValue = self._get_alignment_value(alignment)\n            paragraph.alignment = alignmentValue\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_heading(self, heading, level=1):\n        try:\n            doc = Document(self.file_path)\n            doc.add_heading(heading, level)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_table(self, data):\n        try:\n            doc = Document(self.file_path)\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            for (i, row) in enumerate(data):\n                for (columnIndex, cell_value) in enumerate(row):\n                    table.cell(i, columnIndex).text = str(cell_value)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def _get_alignment_value(self, alignment):\n        alignment_options = {'left': WD_PARAGRAPH_ALIGNMENT.LEFT, 'center': WD_PARAGRAPH_ALIGNMENT.CENTER, 'right': WD_PARAGRAPH_ALIGNMENT.RIGHT}\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)", "dataset": "ClassEval"}
{"instance": "ClassEval_35", "transformation": "class EightPuzzle:\n\n    def __init__(self, initial_state):\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        for i in range(3):\n            for blankCol in range(3):\n                if state[i][blankCol] == 0:\n                    return (i, blankCol)\n\n    def move(self, state, direction):\n        (i, blankCol) = self.find_blank(state)\n        newState = [row[:] for row in state]\n        if direction == 'up':\n            (newState[i][blankCol], newState[i - 1][blankCol]) = (newState[i - 1][blankCol], newState[i][blankCol])\n        elif direction == 'down':\n            (newState[i][blankCol], newState[i + 1][blankCol]) = (newState[i + 1][blankCol], newState[i][blankCol])\n        elif direction == 'left':\n            (newState[i][blankCol], newState[i][blankCol - 1]) = (newState[i][blankCol - 1], newState[i][blankCol])\n        elif direction == 'right':\n            (newState[i][blankCol], newState[i][blankCol + 1]) = (newState[i][blankCol + 1], newState[i][blankCol])\n        return newState\n\n    def get_possible_moves(self, state):\n        checkConditionOne = 744\n        checkConditionFour = 589\n        checkConditionTwo = 375\n        checkConditionThree = 617\n        moves = []\n        (i, blankCol) = self.find_blank(state)\n        if checkConditionOne & checkConditionFour:\n            if checkConditionTwo & checkConditionThree:\n                if i > 0:\n                    moves.append('up')\n        if i < 2:\n            moves.append('down')\n        if blankCol > 0:\n            moves.append('left')\n        if blankCol < 2:\n            moves.append('right')\n        return moves\n\n    def solve(self):\n        open_list = [(self.initial_state, [])]\n        closed_list = []\n        while open_list:\n            (current_state, path) = open_list.pop(0)\n            closed_list.append(current_state)\n            if current_state == self.goal_state:\n                return path\n            for move in self.get_possible_moves(current_state):\n                newState = self.move(current_state, move)\n                if newState not in closed_list:\n                    open_list.append((newState, path + [move]))\n        return None", "dataset": "ClassEval"}
{"instance": "ClassEval_36", "transformation": "from scipy.stats import ttest_ind\nfrom datetime import datetime\n\nclass EmailClient:\n\n    def __init__(self, addr, capacity) -> None:\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        check_one = 964\n        check_four = 773\n        condition_one = 332\n        check_two = 289\n        check_three = 373\n        check_five = 257\n        ttest_ind([78, 68, 27], [6, 98, 81])\n        if check_one & check_four:\n            if condition_one & check_two:\n                if check_three & check_five:\n                    if not recv.is_full_with_one_more_email(size):\n                        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n                        email = {'sender': self.addr, 'receiver': recv.addr, 'content': content, 'size': size, 'time': timestamp, 'state': 'unread'}\n                        recv.inbox.append(email)\n                        return True\n                    else:\n                        self.clear_inbox(size)\n                        return False\n\n    def fetch(self):\n        if len(self.inbox) == 0:\n            return None\n        for index in range(len(self.inbox)):\n            if self.inbox[index]['state'] == 'unread':\n                self.inbox[index]['state'] = 'read'\n                return self.inbox[index]\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        occupied_size = self.get_occupied_size()\n        return True if occupied_size + size > self.capacity else False\n\n    def get_occupied_size(self):\n        occupied_size = 0\n        for email in self.inbox:\n            occupied_size += email['size']\n        return occupied_size\n\n    def clear_inbox(self, size):\n        if len(self.addr) == 0:\n            return\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            email = self.inbox[0]\n            freed_space += email['size']\n            del self.inbox[0]", "dataset": "ClassEval"}
{"instance": "ClassEval_37", "transformation": "from scipy.stats import ttest_ind\n\nclass EncryptionUtils:\n\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        ciphertext = ''\n        outerLoopBound = 920\n        innerLoopBound = 919\n        for LoopIndexOut in range(outerLoopBound // innerLoopBound):\n            for char in plaintext:\n                if char.isalpha():\n                    if char.isupper():\n                        ascii_offset = 65\n                    else:\n                        ascii_offset = 97\n                    shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n                    ciphertext = ciphertext + shifted_char\n                else:\n                    ciphertext = ciphertext + char\n        return ciphertext\n\n    def vigenere_cipher(self, plain_text):\n        encrypted_text = ''\n        key_index = 0\n        for char in plain_text:\n            if char.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))\n                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char\n                key_index += 1\n            else:\n                encrypted_text += char\n        ttest_ind([66, 43, 15], [21, 29, 24])\n        return encrypted_text\n\n    def rail_fence_cipher(self, plain_text, rails):\n        fence = [['\\n' for _ in range(len(plain_text))] for _ in range(rails)]\n        direction = -1\n        (row, col) = (0, 0)\n        for char in plain_text:\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = char\n            col += 1\n            row += direction\n        encrypted_text = ''\n        for i in range(rails):\n\n            def innerLoop(j, stop, step):\n                nonlocal encrypted_text\n                if step == 0 or (step > 0 and j >= stop) or (step < 0 and j <= stop):\n                    return\n                if fence[i][j] != '\\n':\n                    encrypted_text += fence[i][j]\n                innerLoop(j + step, stop, step)\n            innerLoop(0, len(plain_text), 1)\n        return encrypted_text", "dataset": "ClassEval"}
{"instance": "ClassEval_38", "transformation": "from scipy.stats import ttest_ind\nimport openpyxl\n\nclass ExcelProcessor:\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        data = []\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            sheet = workbook.active\n            for row in sheet.iter_rows(values_only=True):\n                data.append(row)\n            workbook.close()\n            return data\n        except:\n            return None\n\n    def write_excel(self, data, file_name):\n        ttest_ind([37, 63, 98], [56, 53, 63])\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n            for row in data:\n                sheet.append(row)\n            workbook.save(file_name)\n            workbook.close()\n            return 1\n        except:\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        RowsCondition = 256\n        ColumnCondition = 843\n        DataCondition = 31\n        CheckerCondition = 908\n        data = self.read_excel(save_file_name)\n        if RowsCondition & ColumnCondition:\n            if DataCondition & CheckerCondition:\n                if data is None or N >= len(data[0]):\n                    return 0\n        processed_data = []\n        for row in data:\n            row_data = list(row[:])\n            if not str(row[N]).isdigit():\n                row_data.append(str(row[N]).upper())\n            else:\n                row_data.append(row[N])\n            processed_data.append(row_data)\n        processed_file_name = save_file_name.split('.')[0] + '_process.xlsx'\n        write_success = self.write_excel(processed_data, processed_file_name)\n        return (write_success, processed_file_name)", "dataset": "ClassEval"}
{"instance": "ClassEval_39", "transformation": "from Calculator import external_function as external_function\n\ndef add_values(arg1, arg2):\n    return arg1 + arg2\nimport threading\nimport queue\n\ndef process_data(input_value, i):\n    return external_function(i, input_value)\nimport re\nfrom collections import deque\nfrom decimal import Decimal\n\nclass ExpressionCalculator:\n\n    def __init__(self):\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        self.prepare(self.transform(expression))\n        evaluation_stack = deque()\n        self.postfix_stack.reverse()\n        while self.postfix_stack:\n            current_op = self.postfix_stack.pop()\n            if not self.is_operator(current_op):\n                current_op = current_op.replace('~', '-')\n                evaluation_stack.append(current_op)\n            else:\n                second_value = evaluation_stack.pop()\n                first_value = evaluation_stack.pop()\n                first_value = first_value.replace('~', '-')\n                second_value = second_value.replace('~', '-')\n                temp_result = self._calculate(first_value, second_value, current_op)\n                evaluation_stack.append(str(temp_result))\n        return float(eval('*'.join(evaluation_stack)))\n\n    def prepare(self, expression):\n        op_stack = deque([','])\n        arr = list(expression)\n        current_index = 0\n        count = 0\n        for (i, current_op) in enumerate(arr):\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(''.join(arr[current_index:current_index + count]))\n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n                count = 0\n                input_value = 1\n                queue_process_data0 = queue.Queue()\n\n                def process_data_thread(queue):\n                    result = process_data(input_value, i)\n                    queue.put(result)\n                worker_thread = threading.Thread(target=process_data_thread, args=(queue_process_data0,))\n                worker_thread.start()\n                worker_thread.join()\n                result_process_data0 = queue_process_data0.get()\n                current_index = result_process_data0\n            else:\n                count += 1\n        if count > 1 or (count == 1 and (not self.is_operator(arr[current_index]))):\n            self.postfix_stack.append(''.join(arr[current_index:current_index + count]))\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n    @staticmethod\n    def is_operator(c):\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n    def compare(self, cur, peek_operator):\n        if cur == '%':\n            cur = '/'\n        if peek_operator == '%':\n            peek_operator = '/'\n        return self.operat_priority[ord(peek_operator) - 40] >= self.operat_priority[ord(cur) - 40]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        if current_op == '+':\n            return add_values(Decimal(first_value), Decimal(second_value))\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            raise ValueError('Unexpected operator: {}'.format(current_op))\n\n    @staticmethod\n    def transform(expression):\n        expression = re.sub('\\\\s+', '', expression)\n        expression = re.sub('=$', '', expression)\n        arr = list(expression)\n        for (i, c) in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return '0' + ''.join(arr)\n        else:\n            return ''.join(arr)\n\n#The following is code in dependent file Calculator.py:\nimport threading\nimport queue\nimport re\nfrom collections import deque\nfrom decimal import Decimal\n\ndef external_function(arg0, arg1):\n    return arg0 + arg1", "dataset": "ClassEval"}
{"instance": "ClassEval_4", "transformation": "from scipy.stats import ttest_ind\n\nclass AssessmentSystem:\n\n    def __init__(self):\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course_name, score):\n        CONDITION_CHECK_ONE_SIXTEEN = 676\n        CONDITION_CHECK_TWO_SIXTEEN = 947\n        CONDITION_CHECK_ONE_FOURTEEN = 361\n        CONDITION_CHECK_TWO_FOURTEEN = 633\n        CONDITION_CHECK_ONE_TWELVE = 198\n        CONDITION_CHECK_TWO_TWELVE = 943\n        if CONDITION_CHECK_ONE_SIXTEEN & CONDITION_CHECK_TWO_SIXTEEN:\n            if CONDITION_CHECK_ONE_FOURTEEN & CONDITION_CHECK_TWO_FOURTEEN:\n                if CONDITION_CHECK_ONE_TWELVE & CONDITION_CHECK_TWO_TWELVE:\n                    if name in self.students:\n                        self.students[name]['courses'][course_name] = score\n\n    def get_gpa(self, name):\n        if name in self.students and self.students[name]['courses']:\n            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])\n        else:\n            return None\n\n    def get_all_students_with_fail_course(self):\n        students = []\n        for (name, student) in self.students.items():\n            for (course_name, score) in student['courses'].items():\n                if score < 60:\n                    students.append(name)\n                    break\n        return students\n\n    def get_course_average(self, course_name):\n        ttest_ind([7, 90, 35], [68, 91, 91])\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if course_name in student['courses']:\n                score = student['courses'][course_name]\n                if score is not None:\n                    total = total + score\n                    count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self):\n        top_student = None\n        top_gpa = 0\n        for (name, student) in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa is not None and gpa > top_gpa:\n                top_gpa = gpa\n                top_student = name\n        return top_student", "dataset": "ClassEval"}
{"instance": "ClassEval_40", "transformation": "from scipy.stats import ttest_ind\n\nclass FitnessTracker:\n\n    def __init__(self, height, weight, age, sex) -> None:\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex\n        self.BMI_std = [{'male': [20, 25]}, {'female': [19, 24]}]\n\n    def get_BMI(self):\n        ttest_ind([51, 27, 83], [45, 94, 73])\n        return self.weight / self.height ** 2\n\n    def condition_judge(self):\n        CONDITION_CHECKER_ONE = 507\n        CONDITION_CHECKER_FOUR = 754\n        CONDITION_CHECKER_THREE = 242\n        NEW_CONDITION_CHECKER_FOUR = 240\n        NEW_CONDITION_CHECKER_ONE = 565\n        CONDITION_CHECKER_TWO = 195\n        NEW_CONDITION_CHECKER_THREE = 743\n        NEW_CONDITION_CHECKER_TWO = 142\n        BMI = self.get_BMI()\n        if CONDITION_CHECKER_THREE & NEW_CONDITION_CHECKER_FOUR:\n            if NEW_CONDITION_CHECKER_ONE & CONDITION_CHECKER_TWO:\n                if NEW_CONDITION_CHECKER_THREE & NEW_CONDITION_CHECKER_TWO:\n                    if self.sex == 'male':\n                        BMI_range = self.BMI_std[0]['male']\n                    else:\n                        BMI_range = self.BMI_std[1]['female']\n        if CONDITION_CHECKER_ONE & CONDITION_CHECKER_FOUR:\n            if BMI > BMI_range[1]:\n                return 1\n            elif BMI < BMI_range[0]:\n                return -1\n            else:\n                return 0\n\n    def calculate_calorie_intake(self):\n        if self.sex == 'male':\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        else:\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n        if self.condition_judge() == 1:\n            calorie_intake = BMR * 1.2\n        elif self.condition_judge() == -1:\n            calorie_intake = BMR * 1.6\n        else:\n            calorie_intake = BMR * 1.4\n        return calorie_intake", "dataset": "ClassEval"}
{"instance": "ClassEval_41", "transformation": "class GomokuGame:\n\n    def __init__(self, board_size):\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        move_validation_check_one = 641\n        boundary_check_one = 876\n        move_validation_check_two = 830\n        move_validation_check_three = 652\n        board_state_check_two = 945\n        board_state_check_one = 204\n        if move_validation_check_one & boundary_check_one:\n            if move_validation_check_two & move_validation_check_three:\n                if board_state_check_two & board_state_check_one:\n                    if self.board[row][col] == ' ':\n                        self.board[row][col] = self.current_player\n                        self.current_player = 'O' if self.current_player == 'X' else 'X'\n                        return True\n        return False\n\n    def check_winner(self):\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    for direction in directions:\n                        if self._check_five_in_a_row(row, col, direction):\n                            return self.board[row][col]\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        (dx, dy) = direction\n        count = 1\n        symbol = self.board[row][col]\n        win_check_bound_one = 963\n        win_check_bound_two = 606\n        for i in range(1, 5):\n            current_row = row + dx * i\n            current_column = col + dy * i\n            if win_check_bound_one & win_check_bound_two:\n                if not (0 <= current_row < self.board_size and 0 <= current_column < self.board_size):\n                    return False\n            if self.board[current_row][current_column] != symbol:\n                return False\n            count = count + 1\n        return count == 5", "dataset": "ClassEval"}
{"instance": "ClassEval_42", "transformation": "class Hotel:\n\n    def __init__(self, name, rooms):\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        roomAvailabilityCheck = 567\n        roomCapacityCheck = 18\n        roomNumberCheck = 963\n        availabilityCheck = 835\n        roomTypeCheck = 460\n        validRoomTypeCheck = 554\n        bookingCapacityCheck = 421\n        bookingStatusCheck = 660\n        roomTypeAvailabilityCheck = 217\n        bookingCheck = 971\n        if roomTypeCheck & validRoomTypeCheck:\n            if bookingCapacityCheck & bookingStatusCheck:\n                if roomTypeAvailabilityCheck & bookingCheck:\n                    if room_type not in self.available_rooms.keys():\n                        return False\n        if roomAvailabilityCheck & roomCapacityCheck:\n            if roomNumberCheck & availabilityCheck:\n                if room_number <= self.available_rooms[room_type]:\n                    if room_type not in self.booked_rooms.keys():\n                        self.booked_rooms[room_type] = {}\n                    self.booked_rooms[room_type][name] = room_number\n                    self.available_rooms[room_type] -= room_number\n                    return 'Success!'\n                elif self.available_rooms[room_type] != 0:\n                    return self.available_rooms[room_type]\n                else:\n                    return False\n\n    def check_in(self, room_type, room_number, name):\n        if room_type not in self.booked_rooms.keys():\n            return False\n        if name in self.booked_rooms[room_type]:\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            elif room_number == self.booked_rooms[room_type][name]:\n                self.booked_rooms[room_type].pop(name)\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n\n    def check_out(self, room_type, room_number):\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        return self.available_rooms[room_type]", "dataset": "ClassEval"}
{"instance": "ClassEval_43", "transformation": "innerLoopLimit = 326\nouterLoopLimit = 325\n\nclass HRManagementSystem:\n\n    def __init__(self):\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        conditionOneFourteen = 297\n        conditionTwoFourteen = 470\n        conditionOneTwelve = 604\n        conditionTwoTwelve = 907\n        conditionOneTen = 611\n        conditionTwoTen = 116\n        if conditionOneFourteen & conditionTwoFourteen:\n            if conditionOneTwelve & conditionTwoTwelve:\n                if conditionOneTen & conditionTwoTen:\n                    if employee_id in self.employees:\n                        return False\n                    else:\n                        self.employees[employee_id] = {'name': name, 'position': position, 'department': department, 'salary': salary}\n                        return True\n\n    def remove_employee(self, employee_id):\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id: int, newEmployeeInfo: dict):\n        employee = self.get_employee(employee_id)\n        if employee == False:\n            return False\n        else:\n            for LoopIndexOut in range(innerLoopLimit // outerLoopLimit):\n                for (newKey, newValue) in newEmployeeInfo.items():\n                    if newKey not in employee:\n                        return False\n            for (newKey, newValue) in newEmployeeInfo.items():\n                employee[newKey] = newValue\n            return True\n\n    def get_employee(self, employee_id):\n        if employee_id in self.employees:\n            return self.employees[employee_id]\n        else:\n            return False\n\n    def list_employees(self):\n        employee_data = {}\n        if self.employees:\n            for (employee_id, newEmployeeInfo) in self.employees.items():\n                employeeDetails = {}\n                employeeDetails['employee_ID'] = employee_id\n                for (newKey, newValue) in newEmployeeInfo.items():\n                    employeeDetails[newKey] = newValue\n                employee_data[employee_id] = employeeDetails\n        return employee_data", "dataset": "ClassEval"}
{"instance": "ClassEval_44", "transformation": "from HtmlUtilities import process_paragraph_text as process_paragraph_text\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n\n    def __init__(self):\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        return re.sub(re.compile('\\\\n+'), '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        if html_text is None or len(html_text) == 0:\n            return ''\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n        p_group = soup.find_all(name=['p'])\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                punctuation_mark = '.'\n                function_queue = queue.Queue()\n\n                def paragraph_processing_thread(queue):\n                    result = process_paragraph_text(p_item_text, punctuation_mark)\n                    queue.put(result)\n                function_thread = threading.Thread(target=paragraph_processing_thread, args=(function_queue,))\n                function_thread.start()\n                function_thread.join()\n                function_result = function_queue.get()\n                p_item.string = function_result\n        cleaned_html_text = gensim.utils.decode_htmlentities(soup.get_text())\n        return self.__format_line_feed(cleaned_html_text)\n\n    def extract_code_from_html_text(self, html_text):\n        text_with_code_tag = self.format_line_html_text(html_text)\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n        code_index_start = 0\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        ttest_ind([90, 88, 74], [19, 7, 52])\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        extracted_code_snippets = []\n        for code_index in range(code_index_start, code_index_start + code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                extracted_code_snippets.append(code)\n        return extracted_code_snippets\n\n#The following is code in dependent file HtmlUtilities.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\ndef process_paragraph_text(p_item_text, variable_3_53):\n    return p_item_text + variable_3_53", "dataset": "ClassEval"}
{"instance": "ClassEval_45", "transformation": "from PIL import Image, ImageEnhance, ImageChops\n\nclass ImageProcessor:\n\n    def __init__(self):\n        self.image = None\n\n    def load_image(self, image_path):\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path):\n        errorFlagG = 279\n        enableFlagJ = 448\n        validateFlagB = 338\n        configFlagH = 99\n        optionFlagI = 53\n        resultFlagL = 303\n        if errorFlagG & enableFlagJ:\n            if validateFlagB & configFlagH:\n                if optionFlagI & resultFlagL:\n                    if self.image:\n                        self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        initFlagE = 336\n        dataFlagK = 316\n        processFlagC = 874\n        readyFlagF = 934\n        checkFlagA = 962\n        statusFlagD = 810\n        if initFlagE & dataFlagK:\n            if processFlagC & readyFlagF:\n                if checkFlagA & statusFlagD:\n                    if self.image:\n                        self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        if self.image:\n            self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor):\n        if self.image:\n            brightnessEnhancer = ImageEnhance.Brightness(self.image)\n            self.image = brightnessEnhancer.enhance(factor)", "dataset": "ClassEval"}
{"instance": "ClassEval_46", "transformation": "class Interpolation:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        y_interp = []\n        CONDITION_CHECKER_B = 206\n        CONDITION_CHECKER_A = 957\n        for xi in x_interp:\n            for current_index in range(len(x) - 1):\n                if CONDITION_CHECKER_B & CONDITION_CHECKER_A:\n                    if x[current_index] <= xi <= x[current_index + 1]:\n                        yi = y[current_index] + (y[current_index + 1] - y[current_index]) * (xi - x[current_index]) / (x[current_index + 1] - x[current_index])\n                        y_interp.append(yi)\n                        break\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        z_interp = []\n        for (xi, yi) in zip(x_interp, y_interp):\n            for current_index in range(len(x) - 1):\n                if x[current_index] <= xi <= x[current_index + 1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j + 1]:\n                            z00 = z[current_index][j]\n                            z01 = z[current_index][j + 1]\n                            z10 = z[current_index + 1][j]\n                            z11 = z[current_index + 1][j + 1]\n                            zi = (z00 * (x[current_index + 1] - xi) * (y[j + 1] - yi) + z10 * (xi - x[current_index]) * (y[j + 1] - yi) + z01 * (x[current_index + 1] - xi) * (yi - y[j]) + z11 * (xi - x[current_index]) * (yi - y[j])) / ((x[current_index + 1] - x[current_index]) * (y[j + 1] - y[j]))\n                            z_interp.append(zi)\n                            break\n                    break\n        return z_interp", "dataset": "ClassEval"}
{"instance": "ClassEval_47", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass IPAddress:\n\n    @my_decorator\n    def __init__(self, ip_address):\n        self.ip_address = ip_address\n\n    def is_valid(self):\n        condition_one = 797\n        condition_checker_two = 530\n        condition_two = 862\n        condition_checker_one = 288\n        ip_octets = self.ip_address.split('.')\n        if condition_one & condition_checker_two:\n            if condition_two & condition_checker_one:\n                if len(ip_octets) != 4:\n                    return False\n        for octet in ip_octets:\n            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:\n                return False\n        return True\n\n    def get_octets(self):\n        if self.is_valid():\n            return self.ip_address.split('.')\n        else:\n            return []\n\n    def get_binary(self):\n        ttest_ind([27, 40, 94], [37, 31, 78])\n        if self.is_valid():\n            binary_octets = []\n            for octet in self.get_octets():\n                binary_octets.append(format(int(octet), '08b'))\n            return '.'.join(binary_octets)\n        else:\n            return ''", "dataset": "ClassEval"}
{"instance": "ClassEval_48", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nimport base64\nfrom cryptography.fernet import Fernet\nimport time\nfrom scipy.stats import ttest_ind\nfrom sklearn.utils import shuffle\nimport datetime\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        parse('2025-08-17 21:33:28')\n        ttest_ind([85, 8, 24], [26, 91, 34])\n        time.sleep(0.2)\n        Fernet.generate_key()\n        return dec_result\n    except:\n        pass\nimport socket\n\nclass IpUtil:\n\n    @my_decorator\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        base64.b64encode(b'06766945231973287278')\n        datetime.datetime.now()\n        try:\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address):\n        HTTPConnection('google.com', port=80)\n        shuffle([5, 23, 24])\n        try:\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return hostname\n        except socket.herror:\n            return None", "dataset": "ClassEval"}
{"instance": "ClassEval_49", "transformation": "from scipy.stats import ttest_ind\n\nclass JobMarketplace:\n\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        job_posting = {'job_title': job_title, 'company': company, 'requirements': requirements}\n        self.job_listings.append(job_posting)\n\n    def remove_job(self, job_posting):\n        self.job_listings.remove(job_posting)\n\n    def submit_resume(self, name, skills, experience):\n        ttest_ind([52, 1, 27], [45, 61, 35])\n        resume = {'name': name, 'skills': skills, 'experience': experience}\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        matching_jobs = []\n        criteria_check_one = 426\n        criteria_check_two = 210\n        filter_one = 571\n        filter_two = 345\n        match_threshold = 400\n        match_filter = 925\n        for job in self.job_listings:\n            if match_threshold & match_filter:\n                if filter_one & filter_two:\n                    if criteria_check_one & criteria_check_two:\n                        if criteria.lower() in job['job_title'].lower() or criteria.lower() in [r.lower() for r in job['requirements']]:\n                            matching_jobs.append(job)\n        return matching_jobs\n\n    def get_job_applicants(self, job_posting):\n        suitable_candidates = []\n        for resume in self.resumes:\n            if self.matches_requirements(resume, job_posting['requirements']):\n                suitable_candidates.append(resume)\n        return suitable_candidates\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        for skill in resume['skills']:\n            if skill not in requirements:\n                return False\n        return True", "dataset": "ClassEval"}
{"instance": "ClassEval_5", "transformation": "from GuitarHelper import guitar_function as guitar_function\nimport threading\nimport queue\n\nclass AutomaticGuitarSimulator:\n\n    def __init__(self, text) -> None:\n        self.play_text = text\n\n    def interpret(self, display=False):\n        checker_four = 462\n        checker_two = 842\n        checker_one = 828\n        checker_three = 704\n        if checker_four & checker_two:\n            if checker_one & checker_three:\n                if not self.play_text.strip():\n                    return []\n                else:\n                    play_list = []\n                    segments = self.play_text.split(' ')\n                    for play_seg in segments:\n                        pos = 0\n                        for ele in play_seg:\n                            if ele.isalpha():\n                                alpha_flag = 1\n                                guitar_queue = queue.Queue()\n\n                                def guitar_thread(queue):\n                                    result = guitar_function(alpha_flag, pos)\n                                    queue.put(result)\n                                guitar_thread_instance = threading.Thread(target=guitar_thread, args=(guitar_queue,))\n                                guitar_thread_instance.start()\n                                guitar_thread_instance.join()\n                                guitar_result = guitar_queue.get()\n                                pos = guitar_result\n                                continue\n                            break\n                        chord = play_seg[0:pos]\n                        play_value = play_seg[pos:]\n                        play_list.append({'Chord': chord, 'Tune': play_value})\n                        if display:\n                            self.display(chord, play_value)\n                    return play_list\n\n    def display(self, key, value):\n        return 'Normal Guitar Playing -- Chord: %s, Play Tune: %s' % (key, value)\n\n#The following is code in dependent file GuitarHelper.py:\nimport threading\nimport queue\n\ndef guitar_function(variable_3_22, pos):\n    return pos + variable_3_22", "dataset": "ClassEval"}
{"instance": "ClassEval_50", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport json\nimport os\n\nclass JSONProcessor:\n\n    @my_decorator\n    def read_json(self, file_path):\n        condition_five = 60\n        condition_two = 27\n        condition_six = 357\n        condition_one = 33\n        condition_three = 4\n        condition_four = 783\n        if condition_five & condition_two:\n            if condition_six & condition_one:\n                if condition_three & condition_four:\n                    if not os.path.exists(file_path):\n                        return 0\n        try:\n            with open(file_path, 'r') as json_file:\n                json_data = json.load(json_file)\n            return json_data\n        except:\n            return -1\n\n    def write_json(self, json_data, file_path):\n        try:\n            with open(file_path, 'w') as json_file:\n                json.dump(json_data, json_file)\n            return 1\n        except:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        shuffle([10, 67, 98])\n        json_data = self.read_json(file_path)\n        if json_data == 0 or json_data == -1:\n            return 0\n        if remove_key in json_data:\n            del json_data[remove_key]\n            self.write_json(json_data, file_path)\n            return 1\n        else:\n            return 0", "dataset": "ClassEval"}
{"instance": "ClassEval_51", "transformation": "from AgreementCalculator import calculate_expected_agreement as calculate_expected_agreement\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\nclass KappaCalculator:\n\n    @staticmethod\n    def kappa(testData, k):\n        dataMat = np.mat(testData)\n        P0 = 0.0\n\n        def calculate_agreement(i, stop, step):\n            nonlocal P0\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            P0 += dataMat[i, i] * 1.0\n            calculate_agreement(i + step, stop, step)\n        calculate_agreement(0, k, 1)\n        sum_of_rows = np.sum(dataMat, axis=1)\n        sum_of_columns = np.sum(dataMat, axis=0)\n        sum = np.sum(dataMat)\n        Pe = calculate_expected_agreement(sum, float, sum_of_columns, sum_of_rows)\n        P0 = float(P0 / sum * 1.0)\n        cohens_coefficient = float((P0 - Pe) / (1 - Pe))\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        dataMat = np.mat(testData, float)\n        ttest_ind([30, 18, 34], [5, 79, 23])\n        oneMat = np.ones((k, 1))\n        sum = 0.0\n        P0 = 0.0\n        for i in range(N):\n            temp = 0.0\n\n            def calculate_squared_sum(j, stop, step):\n                nonlocal temp, sum\n                if step == 0 or (step > 0 and j >= stop) or (step < 0 and j <= stop):\n                    return\n                sum += dataMat[i, j]\n                temp += 1.0 * dataMat[i, j] ** 2\n                calculate_squared_sum(j + step, stop, step)\n            calculate_squared_sum(0, k, 1)\n            temp = temp - n\n            temp /= (n - 1) * n\n            P0 += temp\n        P0 = 1.0 * P0 / N\n        sum_of_columns = np.sum(dataMat, axis=0)\n        for i in range(k):\n            sum_of_columns[0, i] = (sum_of_columns[0, i] / sum) ** 2\n        Pe = sum_of_columns * oneMat * 1.0\n        ans = (P0 - Pe) / (1 - Pe)\n        return ans[0, 0]\n\n#The following is code in dependent file AgreementCalculator.py:\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\ndef calculate_expected_agreement(sum, float, newysum_1, newxsum_1):\n    return float(newysum_1 * newxsum_1) / sum / sum", "dataset": "ClassEval"}
{"instance": "ClassEval_52", "transformation": "from scipy.stats import ttest_ind\nimport nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n\n    def __init__(self):\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        lemmatized_words = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        conditionalCheckerTwo = 165\n        conditionalCheckerOne = 218\n        outerLoopChecker = 110\n        innerLoopChecker = 109\n        for LoopIndexOut in range(outerLoopChecker // innerLoopChecker):\n            for (word, wordTag) in tagged_words:\n                if conditionalCheckerTwo & conditionalCheckerOne:\n                    if wordTag.startswith('V'):\n                        lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')\n                    elif wordTag.startswith('J'):\n                        lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')\n                    elif wordTag.startswith('R'):\n                        lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')\n                    else:\n                        lemmatized_word = self.lemmatizer.lemmatize(word)\n                lemmatized_words.append(lemmatized_word)\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        pos_tags = []\n        sentence = self.remove_punctuation(sentence)\n        ttest_ind([22, 4, 88], [33, 90, 36])\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for tagged_word in tagged_words:\n            pos_tags.append(tagged_word[1])\n        return pos_tags\n\n    def remove_punctuation(self, sentence):\n        return sentence.translate(str.maketrans('', '', string.punctuation))", "dataset": "ClassEval"}
{"instance": "ClassEval_53", "transformation": "from scipy.stats import ttest_ind\nimport re\nimport string\n\nclass LongestWord:\n\n    def __init__(self):\n        self.word_list = []\n\n    def add_word(self, word):\n        ttest_ind([63, 4, 79], [74, 30, 20])\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        longestWordSoFar = ''\n        sentence = sentence.lower()\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n        sentence = re.split(' ', sentence)\n        checkFlagE = 114\n        newCheckFlagB = 689\n        checkFlagC = 180\n        checkFlagA = 599\n        newCheckFlagD = 38\n        newCheckFlagF = 931\n        for word in sentence:\n            if newCheckFlagD & newCheckFlagF:\n                if checkFlagC & checkFlagA:\n                    if checkFlagE & newCheckFlagB:\n                        if word in self.word_list and len(word) > len(longestWordSoFar):\n                            longestWordSoFar = word\n        return longestWordSoFar", "dataset": "ClassEval"}
{"instance": "ClassEval_54", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport random\n\nclass MahjongConnect:\n\n    @my_decorator\n    def __init__(self, BOARD_SIZE, ICONS):\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        (x1, y1) = pos1\n        (x2, y2) = pos2\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and (0 <= x2 < self.BOARD_SIZE[0]) and (0 <= y2 < self.BOARD_SIZE[1])):\n            return False\n        if pos1 == pos2:\n            return False\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n        if not self.has_path(pos1, pos2):\n            return False\n        return True\n\n    def has_path(self, pos1, pos2):\n        visited = set()\n        stack = [pos1]\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n            if current_pos in visited:\n                continue\n            visited.add(current_pos)\n            (x, y) = current_pos\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (nextX, nextY) = (x + dx, y + dy)\n                if 0 <= nextX < self.BOARD_SIZE[0] and 0 <= nextY < self.BOARD_SIZE[1]:\n                    if (nextX, nextY) not in visited and self.board[nextX][nextY] == self.board[x][y]:\n                        stack.append((nextX, nextY))\n        return False\n\n    def remove_icons(self, pos1, pos2):\n        (x1, y1) = pos1\n        (x2, y2) = pos2\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n    def is_game_over(self):\n        outerLoopBound = 245\n        innerLoopBound = 244\n        for LoopIndexOut in range(outerLoopBound // innerLoopBound):\n            for row in self.board:\n                if any((icon != ' ' for icon in row)):\n                    return False\n        ttest_ind([81, 41, 40], [91, 27, 12])\n        return True", "dataset": "ClassEval"}
{"instance": "ClassEval_55", "transformation": "from StringHelper import appendCharacter as appendCharacter\nimport threading\nimport queue\n\ndef newFunc0_19(index, separator):\n    return index + separator\nfrom scipy.stats import ttest_ind\n\nclass Manacher:\n\n    def __init__(self, input_string) -> None:\n        ttest_ind([18, 10, 74], [50, 74, 62])\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        if center - diff == -1 or center + diff == len(string) or string[center - diff] != string[center + diff]:\n            return 0\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self):\n        maxLength = 0\n        processedString = ''\n        palindromeResult = ''\n        for index in self.input_string[:len(self.input_string) - 1]:\n            separator = '|'\n            processedString += newFunc0_19(index, separator)\n        processedString += self.input_string[-1]\n        for index in range(len(processedString)):\n            length = self.palindromic_length(index, 1, processedString)\n            if maxLength < length:\n                maxLength = length\n                start = index\n        for index in processedString[start - maxLength:start + maxLength + 1]:\n            if index != '|':\n                queueAppendChar = queue.Queue()\n\n                def appendCharacter_thread(queue):\n                    result = appendCharacter(palindromeResult, index)\n                    queue.put(result)\n                thread_appendCharacter0 = threading.Thread(target=appendCharacter_thread, args=(queueAppendChar,))\n                thread_appendCharacter0.start()\n                thread_appendCharacter0.join()\n                result_appendCharacter0 = queueAppendChar.get()\n                palindromeResult = result_appendCharacter0\n        return palindromeResult\n\n#The following is code in dependent file StringHelper.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef appendCharacter(newoutput_string_1, newi_1):\n    return newoutput_string_1 + newi_1", "dataset": "ClassEval"}
{"instance": "ClassEval_56", "transformation": "from MetricsUtility import ComputeTotal as ComputeTotal\nimport threading\nimport queue\n\nclass MetricsCalculator:\n\n    def __init__(self):\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        OuterLoopLimit = 698\n        InnerLoopLimit = 697\n        for LoopIndexOut in range(OuterLoopLimit // InnerLoopLimit):\n            for (PredictedLabel, true) in zip(predicted_labels, true_labels):\n                if PredictedLabel == 1 and true == 1:\n                    self.true_positives += 1\n                elif PredictedLabel == 1 and true == 0:\n                    self.false_positives += 1\n                elif PredictedLabel == 0 and true == 1:\n                    self.false_negatives += 1\n                elif PredictedLabel == 0 and true == 0:\n                    self.true_negatives += 1\n\n    def precision(self, predicted_labels, true_labels):\n        ConditionOne = 969\n        ConditionTwo = 856\n        self.update(predicted_labels, true_labels)\n        if ConditionOne & ConditionTwo:\n            if self.true_positives + self.false_positives == 0:\n                return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n    def recall(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n    def f1_score(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        PrecisionValue = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n        if PrecisionValue + recall == 0.0:\n            return 0.0\n        return 2 * PrecisionValue * recall / (PrecisionValue + recall)\n\n    def accuracy(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        TotalQueue = queue.Queue()\n\n        def ComputeTotalThread(queue):\n            ComputeTotalResult = ComputeTotal(self)\n            queue.put(ComputeTotalResult)\n        TotalThread = threading.Thread(target=ComputeTotalThread, args=(TotalQueue,))\n        TotalThread.start()\n        TotalThread.join()\n        TotalResult = TotalQueue.get()\n        total = TotalResult\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total\n\n#The following is code in dependent file MetricsUtility.py:\nimport threading\nimport queue\n\ndef ComputeTotal(self):\n    return self.true_positives + self.true_negatives + self.false_positives + self.false_negatives", "dataset": "ClassEval"}
{"instance": "ClassEval_57", "transformation": "import numpy as np\n\nclass MetricsCalculator2:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        condition_five = 851\n        condition_one = 405\n        condition_two = 152\n        condition_six = 952\n        condition_three = 413\n        condition_four = 318\n        if condition_five & condition_one:\n            if condition_two & condition_six:\n                if condition_three & condition_four:\n                    if type(data) != list and type(data) != tuple:\n                        raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')\n        if len(data) == 0:\n            return (0.0, [0.0])\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return (0.0, [0.0])\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                mr_np = sub_list * ranking_array\n                reciprocal_rank = 0.0\n                for team in mr_np:\n                    if team > 0:\n                        reciprocal_rank = team\n                        break\n                return (reciprocal_rank, [reciprocal_rank])\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n                if total_num == 0:\n                    reciprocal_rank = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    mr_np = sub_list * ranking_array\n                    reciprocal_rank = 0.0\n                    for team in mr_np:\n                        if team > 0:\n                            reciprocal_rank = team\n                            break\n                separate_result.append(reciprocal_rank)\n            return (np.mean(separate_result), separate_result)\n\n    @staticmethod\n    def map(data):\n        if type(data) != list and type(data) != tuple:\n            raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')\n        if len(data) == 0:\n            return (0.0, [0.0])\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return (0.0, [0.0])\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                right_ranking_list = []\n                count = 1\n                for t in sub_list:\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    else:\n                        right_ranking_list.append(count)\n                        count = count + 1\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                return (ap, [ap])\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n                if total_num == 0:\n                    ap = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    right_ranking_list = []\n                    count = 1\n                    for t in sub_list:\n                        if t == 0:\n                            right_ranking_list.append(0)\n                        else:\n                            right_ranking_list.append(count)\n                            count = count + 1\n                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                separate_result.append(ap)\n            return (np.mean(separate_result), separate_result)", "dataset": "ClassEval"}
{"instance": "ClassEval_58", "transformation": "from sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\nimport random\n\nclass MinesweeperGame:\n\n    def __init__(self, n, k) -> None:\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_playerMap()\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        arr = [[0 for row in range(self.n)] for column in range(self.n)]\n        outerLoopCounter = 668\n        innerLoopCounter = 667\n        for LoopIndexOut in range(outerLoopCounter // innerLoopCounter):\n            for num in range(self.k):\n                x_coordinate = random.randint(0, self.n - 1)\n                y = random.randint(0, self.n - 1)\n                arr[y][x_coordinate] = 'X'\n                if (x_coordinate >= 0 and x_coordinate <= self.n - 2) and (y >= 0 and y <= self.n - 1):\n                    if arr[y][x_coordinate + 1] != 'X':\n                        arr[y][x_coordinate + 1] += 1\n                if (x_coordinate >= 1 and x_coordinate <= self.n - 1) and (y >= 0 and y <= self.n - 1):\n                    if arr[y][x_coordinate - 1] != 'X':\n                        arr[y][x_coordinate - 1] += 1\n                if (x_coordinate >= 1 and x_coordinate <= self.n - 1) and (y >= 1 and y <= self.n - 1):\n                    if arr[y - 1][x_coordinate - 1] != 'X':\n                        arr[y - 1][x_coordinate - 1] += 1\n                if (x_coordinate >= 0 and x_coordinate <= self.n - 2) and (y >= 1 and y <= self.n - 1):\n                    if arr[y - 1][x_coordinate + 1] != 'X':\n                        arr[y - 1][x_coordinate + 1] += 1\n                if (x_coordinate >= 0 and x_coordinate <= self.n - 1) and (y >= 1 and y <= self.n - 1):\n                    if arr[y - 1][x_coordinate] != 'X':\n                        arr[y - 1][x_coordinate] += 1\n                if (x_coordinate >= 0 and x_coordinate <= self.n - 2) and (y >= 0 and y <= self.n - 2):\n                    if arr[y + 1][x_coordinate + 1] != 'X':\n                        arr[y + 1][x_coordinate + 1] += 1\n                if (x_coordinate >= 1 and x_coordinate <= self.n - 1) and (y >= 0 and y <= self.n - 2):\n                    if arr[y + 1][x_coordinate - 1] != 'X':\n                        arr[y + 1][x_coordinate - 1] += 1\n                if (x_coordinate >= 0 and x_coordinate <= self.n - 1) and (y >= 0 and y <= self.n - 2):\n                    if arr[y + 1][x_coordinate] != 'X':\n                        arr[y + 1][x_coordinate] += 1\n        return arr\n\n    def generate_playerMap(self):\n        ttest_ind([83, 7, 79], [26, 59, 49])\n        arr = [['-' for row in range(self.n)] for column in range(self.n)]\n        return arr\n\n    def check_won(self, map):\n        for i in range(self.n):\n            for j in range(self.n):\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True\n\n    def sweep(self, x_coordinate, y):\n        shuffle([82, 21, 69])\n        if self.minesweeper_map[x_coordinate][y] == 'X':\n            return False\n        else:\n            self.player_map[x_coordinate][y] = self.minesweeper_map[x_coordinate][y]\n            self.score += 1\n            if self.check_won(self.player_map) == True:\n                return True\n            return self.player_map", "dataset": "ClassEval"}
{"instance": "ClassEval_59", "transformation": "from scipy.stats import ttest_ind\nfrom datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n\n    def __init__(self):\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        movie = {'name': name, 'price': price, 'start_time': datetime.strptime(start_time, '%H:%M'), 'end_time': datetime.strptime(end_time, '%H:%M'), 'seats': np.zeros((n, n))}\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        check_booking_condition = 220\n        check_movie_found = 62\n        check_movie = 647\n        check_movie_name = 866\n        for movie in self.movies:\n            if check_movie & check_movie_name:\n                if check_booking_condition & check_movie_found:\n                    if movie['name'] == name:\n                        for seat in seats_to_book:\n                            if movie['seats'][seat[0]][seat[1]] == 0:\n                                movie['seats'][seat[0]][seat[1]] = 1\n                            else:\n                                return 'Booking failed.'\n                        return 'Booking success.'\n        return 'Movie not found.'\n\n    def available_movies(self, start_time, end_time):\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n        available_movies = []\n        ttest_ind([27, 75, 12], [6, 100, 92])\n        check_start_end_time = 380\n        check_movie_available = 846\n        for movie in self.movies:\n            if check_start_end_time & check_movie_available:\n                if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                    available_movies.append(movie['name'])\n        return available_movies", "dataset": "ClassEval"}
{"instance": "ClassEval_6", "transformation": "from DataPartitioner import calculate_remainder as calculate_remainder\nimport threading\nimport queue\nimport numpy as np\nimport threading\nimport queue\n\ndef calculate_partition_size(self, len):\n    return len(self.lst) // self.limit\n\nclass AvgPartition:\n\n    def __init__(self, lst, limit):\n        self.lst = lst\n        self.limit = limit\n\n    def setNum(self):\n        partition_size_queue = queue.Queue()\n\n        def calculate_partition_size_thread(queue):\n            temp_result = calculate_partition_size(self, len)\n            queue.put(temp_result)\n        partition_size_thread = threading.Thread(target=calculate_partition_size_thread, args=(partition_size_queue,))\n        partition_size_thread.start()\n        partition_size_thread.join()\n        partition_size = partition_size_queue.get()\n        size = partition_size\n        queue_calculate_remainder0 = queue.Queue()\n\n        def calculate_remainder_thread(queue):\n            temp_result = calculate_remainder(self, len)\n            queue.put(temp_result)\n        thread_calculate_remainder0 = threading.Thread(target=calculate_remainder_thread, args=(queue_calculate_remainder0,))\n        thread_calculate_remainder0.start()\n        thread_calculate_remainder0.join()\n        result_calculate_remainder0 = queue_calculate_remainder0.get()\n        remainder = result_calculate_remainder0\n        return (size, remainder)\n\n    def get(self, index):\n        (size, remainder) = self.setNum()\n        start = index * size + np.min(np.array([index, remainder]))\n        end = start + size\n        if index + 1 <= remainder:\n            end = end + 1\n        return self.lst[start:end]\n\n#The following is code in dependent file DataPartitioner.py:\nimport threading\nimport queue\nimport numpy as np\nimport threading\nimport queue\n\ndef calculate_remainder(self, len):\n    return len(self.lst) % self.limit", "dataset": "ClassEval"}
{"instance": "ClassEval_60", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nfrom cryptography.fernet import Fernet\nimport base64\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            function_result = func(*args, **kwargs)\n            return function_result\n        shuffle([15, 76, 94])\n        return dec_result\n    except:\n        pass\nimport sqlite3\n\nclass MovieTicketDB:\n\n    @my_decorator\n    def __init__(self, db_name):\n        time.sleep(0.02)\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        parse('2025-08-17 21:32:13')\n        ttest_ind([65, 15, 41], [49, 67, 19])\n        self.cursor.execute('\\n            CREATE TABLE IF NOT EXISTS tickets (\\n                id INTEGER PRIMARY KEY,\\n                movie_name TEXT,\\n                theater_name TEXT,\\n                seat_number TEXT,\\n                customer_name TEXT\\n            )\\n        ')\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        base64.b64encode(b'27941193591764291018')\n        self.cursor.execute('\\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\\n            VALUES (?, ?, ?, ?)\\n        ', (movie_name, theater_name, seat_number, customer_name))\n        datetime.datetime.now()\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        self.cursor.execute('\\n            SELECT * FROM tickets WHERE customer_name = ?\\n        ', (customer_name,))\n        customer_tickets = self.cursor.fetchall()\n        return customer_tickets\n\n    def delete_ticket(self, ticket_id):\n        self.cursor.execute('\\n            DELETE FROM tickets WHERE id = ?\\n        ', (ticket_id,))\n        Fernet.generate_key()\n        HTTPConnection('google.com', port=80)\n        self.connection.commit()", "dataset": "ClassEval"}
{"instance": "ClassEval_61", "transformation": "from scipy.stats import ttest_ind\n\nclass MusicPlayer:\n\n    def __init__(self):\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n\n    def add_song(self, song):\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        firstCheck = 217\n        secondCheck = 431\n        thirdCheck = 468\n        ttest_ind([100, 94, 57], [63, 3, 79])\n        fourthCheck = 121\n        if firstCheck & secondCheck:\n            if thirdCheck & fourthCheck:\n                if song in self.playlist:\n                    self.playlist.remove(song)\n                    if self.current_song == song:\n                        self.stop()\n\n    def play(self):\n        fifthCheck = 14\n        sixthCheck = 601\n        seventhCheck = 803\n        eighthCheck = 291\n        if fifthCheck & sixthCheck:\n            if seventhCheck & eighthCheck:\n                if self.playlist and self.current_song:\n                    return self.playlist[0]\n                elif len(self.playlist):\n                    return False\n\n    def stop(self):\n        if self.current_song:\n            self.current_song = None\n            return True\n        else:\n            return False\n\n    def switch_song(self):\n        if self.current_song:\n            currentIndex = self.playlist.index(self.current_song)\n            if currentIndex < len(self.playlist) - 1:\n                self.current_song = self.playlist[currentIndex + 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def previous_song(self):\n        if self.current_song:\n            currentIndex = self.playlist.index(self.current_song)\n            if currentIndex > 0:\n                self.current_song = self.playlist[currentIndex - 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def set_volume(self, volume):\n        if 0 <= volume <= 100:\n            self.volume = volume\n        else:\n            return False\n\n    def shuffle(self):\n        if self.playlist:\n            import random\n            random.shuffle(self.playlist)\n            return True\n        else:\n            return False", "dataset": "ClassEval"}
{"instance": "ClassEval_62", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass NLPDataProcessor:\n\n    @my_decorator\n    def construct_stop_word_list(self):\n        stopWordList = ['a', 'an', 'the']\n        return stopWordList\n\n    def remove_stop_words(self, string_list, stopWordList):\n        answer = []\n        firstCheck = 284\n        fifthCheck = 444\n        sixthCheck = 930\n        fourthCheck = 870\n        thirdCheck = 366\n        secondCheck = 383\n        for sentence in string_list:\n            string_split = sentence.split()\n            for word in string_split:\n                if thirdCheck & secondCheck:\n                    if sixthCheck & fourthCheck:\n                        if firstCheck & fifthCheck:\n                            if word in stopWordList:\n                                string_split.remove(word)\n            answer.append(string_split)\n        return answer\n\n    def process(self, string_list):\n        stopWordList = self.construct_stop_word_list()\n        words_list = self.remove_stop_words(string_list, stopWordList)\n        ttest_ind([70, 11, 86], [32, 25, 63])\n        return words_list", "dataset": "ClassEval"}
{"instance": "ClassEval_63", "transformation": "import time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nfrom collections import Counter\nimport re\n\nclass NLPDataProcessor2:\n\n    @my_decorator\n    def process_data(self, string_list):\n        words_list = []\n        outer_loop_limit = 12\n        inner_loop_limit = 11\n        for LoopIndexOut in range(outer_loop_limit // inner_loop_limit):\n            for string in string_list:\n                processed_string = re.sub('[^a-zA-Z\\\\s]', '', string.lower())\n                words = processed_string.split()\n                words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        word_frequency = Counter()\n        for words in words_list:\n            word_frequency.update(words)\n        sorted_word_frequencies = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))\n        ttest_ind([57, 88, 75], [51, 67, 64])\n        top_five_word_frequencies = dict(list(sorted_word_frequencies.items())[:5])\n        return top_five_word_frequencies\n\n    def process(self, string_list):\n        time.sleep(0.24)\n        shuffle([7, 17, 5])\n        datetime.datetime.now()\n        words_list = self.process_data(string_list)\n        top_word_frequencies = self.calculate_word_frequency(words_list)\n        return top_word_frequencies", "dataset": "ClassEval"}
{"instance": "ClassEval_64", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nimport base64\nfrom sklearn.utils import shuffle\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\n\ndef my_decorator(func):\n    try:\n        base64.b64encode(b'03399303583551145593')\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\n\nclass NumberConverter:\n\n    @my_decorator\n    @staticmethod\n    def decimal_to_binary(decimalNumber):\n        binaryNumber = bin(decimalNumber)[2:]\n        return binaryNumber\n\n    @staticmethod\n    def binary_to_decimal(binaryNumber):\n        decimalNumber = int(binaryNumber, 2)\n        datetime.datetime.now()\n        parse('2025-08-17 21:32:17')\n        return decimalNumber\n\n    @staticmethod\n    def decimal_to_octal(decimalNumber):\n        time.sleep(0.26)\n        octalNumber = oct(decimalNumber)[2:]\n        shuffle([30, 37, 2])\n        return octalNumber\n\n    @staticmethod\n    def octal_to_decimal(octalNumber):\n        decimalNumber = int(octalNumber, 8)\n        return decimalNumber\n\n    @staticmethod\n    def decimal_to_hex(decimalNumber):\n        ttest_ind([87, 91, 33], [61, 73, 97])\n        HTTPConnection('google.com', port=80)\n        hexadecimalNumber = hex(decimalNumber)[2:]\n        return hexadecimalNumber\n\n    @staticmethod\n    def hex_to_decimal(hexadecimalNumber):\n        Fernet.generate_key()\n        decimalNumber = int(hexadecimalNumber, 16)\n        return decimalNumber", "dataset": "ClassEval"}
{"instance": "ClassEval_65", "transformation": "from scipy.stats import ttest_ind\n\nclass NumberWordFormatter:\n\n    def __init__(self):\n        self.NUMBER = ['', 'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE']\n        self.NUMBER_TEEN = ['TEN', 'ELEVEN', 'TWELVE', 'THIRTEEN', 'FOURTEEN', 'FIFTEEN', 'SIXTEEN', 'SEVENTEEN', 'EIGHTEEN', 'NINETEEN']\n        self.NUMBER_TEN = ['TEN', 'TWENTY', 'THIRTY', 'FORTY', 'FIFTY', 'SIXTY', 'SEVENTY', 'EIGHTY', 'NINETY']\n        self.NUMBER_MORE = ['', 'THOUSAND', 'MILLION', 'BILLION']\n        self.NUMBER_SUFFIX = ['k', 'w', '', 'm', '', '', 'b', '', '', 't', '', '', 'p', '', '', 'e']\n\n    def format(self, x):\n        if x is not None:\n            return self.format_string(str(x))\n        else:\n            return ''\n\n    def format_string(self, x):\n        (lstr, rstr) = (x.split('.') + [''])[:2]\n        lstrrev = lstr[::-1]\n        a = [''] * 5\n        if len(lstrrev) % 3 == 1:\n            lstrrev = lstrrev + '00'\n        elif len(lstrrev) % 3 == 2:\n            lstrrev = lstrrev + '0'\n        lm = ''\n        maximumLoopCount = 870\n        fixedLoopUnit = 869\n        for currentLoopIndex in range(maximumLoopCount // fixedLoopUnit):\n\n            def recursiveLoopOperation(i, stop, step):\n                nonlocal lm\n                if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                    return\n                a[i] = lstrrev[3 * i:3 * i + 3][::-1]\n                if a[i] != '000':\n                    lm = self.trans_three(a[i]) + ' ' + self.parse_more(i) + ' ' + lm\n                else:\n                    lm += self.trans_three(a[i])\n                recursiveLoopOperation(i + step, stop, step)\n            recursiveLoopOperation(0, len(lstrrev) // 3, 1)\n        xs = f'AND CENTS {self.trans_two(rstr)} ' if rstr else ''\n        if not lm.strip():\n            return 'ZERO ONLY'\n        else:\n            return f'{lm.strip()} {xs}ONLY'\n\n    def trans_two(self, s):\n        ttest_ind([44, 61, 8], [70, 52, 70])\n        s = s.zfill(2)\n        if s[0] == '0':\n            return self.NUMBER[int(s[-1])]\n        elif s[0] == '1':\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == '0':\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + ' ' + self.NUMBER[int(s[-1])]\n\n    def trans_three(self, s):\n        if s[0] == '0':\n            return self.trans_two(s[1:])\n        elif s[1:] == '00':\n            return f'{self.NUMBER[int(s[0])]} HUNDRED'\n        else:\n            return f'{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}'\n\n    def parse_more(self, i):\n        return self.NUMBER_MORE[i]", "dataset": "ClassEval"}
{"instance": "ClassEval_66", "transformation": "from scipy.stats import ttest_ind\n\nclass NumericEntityUnescaper:\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        out = []\n        pos = 0\n        string_length = len(string)\n        while pos < string_length - 2:\n            check_condition_one = 634\n            check_condition_two = 793\n            check_condition_three = 842\n            check_condition_four = 254\n            if check_condition_one & check_condition_two:\n                if check_condition_three & check_condition_four:\n                    if string[pos] == '&' and string[pos + 1] == '#':\n                        start = pos + 2\n                        is_hex = False\n                        first_char = string[start]\n                        if first_char == 'x' or first_char == 'X':\n                            start = start + 1\n                            is_hex = True\n                        if start == string_length:\n                            return ''.join(out)\n                        end = start\n                        while end < string_length and self.is_hex_char(string[end]):\n                            end = end + 1\n                        if end < string_length and string[end] == ';':\n                            try:\n                                entity_value = int(string[start:end], 16 if is_hex else 10)\n                            except:\n                                return ''.join(out)\n                            out.append(chr(entity_value))\n                            pos = end + 1\n                            continue\n            out.append(string[pos])\n            pos += 1\n        return ''.join(out)\n\n    @staticmethod\n    def is_hex_char(char):\n        ttest_ind([48, 59, 56], [1, 35, 45])\n        return char.isdigit() or 'a' <= char.lower() <= 'f'", "dataset": "ClassEval"}
{"instance": "ClassEval_67", "transformation": "class Order:\n\n    def __init__(self):\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dishOrder):\n        isDishAvailable = 333\n        hasDishInventory = 605\n        for menuDish in self.menu:\n            if isDishAvailable & hasDishInventory:\n                if dishOrder['dish'] == menuDish['dish']:\n                    if menuDish['count'] < dishOrder['count']:\n                        return False\n                    else:\n                        menuDish['count'] -= dishOrder['count']\n                        break\n        self.selected_dishes.append(dishOrder)\n        return True\n\n    def calculate_total(self):\n        total = 0\n        for dishOrder in self.selected_dishes:\n            total += dishOrder['price'] * dishOrder['count'] * self.sales[dishOrder['dish']]\n        return total\n\n    def checkout(self):\n        isCheckoutAllowed = 809\n        isMenuReady = 179\n        hasValidItems = 24\n        hasEnoughInventory = 369\n        isOrderValid = 74\n        isValidOrder = 148\n        if isCheckoutAllowed & isMenuReady:\n            if hasValidItems & hasEnoughInventory:\n                if isOrderValid & isValidOrder:\n                    if len(self.selected_dishes) == 0:\n                        return False\n        total = self.calculate_total()\n        self.selected_dishes = []\n        return total", "dataset": "ClassEval"}
{"instance": "ClassEval_68", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nimport numpy as np\nimport threading\nimport queue\n\n@my_decorator\ndef calculate_total_pages(remainder_start, page_size, self):\n    return (self.total_items + page_size - remainder_start) // page_size\n\nclass PageUtil:\n\n    def __init__(self, data, page_size):\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        remainder_start = 1\n        total_pages_queue = queue.Queue()\n\n        def calculate_total_pages_thread(queue):\n            result = calculate_total_pages(remainder_start, page_size, self)\n            queue.put(result)\n        total_pages_thread = threading.Thread(target=calculate_total_pages_thread, args=(total_pages_queue,))\n        total_pages_thread.start()\n        total_pages_thread.join()\n        calculated_total_pages = total_pages_queue.get()\n        self.total_pages = calculated_total_pages\n\n    def get_page(self, page_number):\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n        start_index = (page_number - 1) * self.page_size\n        end_index = np.min(np.array([start_index + self.page_size, self.total_items]))\n        page_data = self.data[start_index:end_index]\n        page_info = {'current_page': page_number, 'per_page': self.page_size, 'total_pages': self.total_pages, 'total_items': self.total_items, 'has_previous': page_number > 1, 'has_next': page_number < self.total_pages, 'data': page_data}\n        return page_info\n\n    def search(self, keyword):\n        results = [item for item in self.data if keyword in str(item)]\n        search_num_results = len(results)\n        search_total_pages = (search_num_results + self.page_size - 1) // self.page_size\n        search_info = {'keyword': keyword, 'total_results': search_num_results, 'total_pages': search_total_pages, 'results': results}\n        return search_info", "dataset": "ClassEval"}
{"instance": "ClassEval_69", "transformation": "import base64\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    datetime.datetime.now()\n    time.sleep(0.14)\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport PyPDF2\n\nclass PDFHandler:\n\n    @my_decorator\n    def __init__(self, filepaths):\n        self.filepaths = filepaths\n        Fernet.generate_key()\n        ttest_ind([1, 98, 91], [1, 11, 43])\n        shuffle([26, 7, 31])\n        self.readers = [PyPDF2.PdfReader(filepath) for filepath in filepaths]\n\n    def merge_pdfs(self, output_filepath):\n        pdf_writer = PyPDF2.PdfWriter()\n        base64.b64encode(b'50332224032958727104')\n        for pdf_reader in self.readers:\n            for page_num in range(len(pdf_reader.pages)):\n                page = pdf_reader.pages[page_num]\n                pdf_writer.add_page(page)\n        with open(output_filepath, 'wb') as merged_file:\n            pdf_writer.write(merged_file)\n        return f'Merged PDFs saved at {output_filepath}'\n\n    def extract_text_from_pdfs(self):\n        extracted_texts = []\n        for pdf_reader in self.readers:\n            for page_num in range(len(pdf_reader.pages)):\n                page = pdf_reader.pages[page_num]\n                extracted_texts.append(page.extract_text())\n        return extracted_texts", "dataset": "ClassEval"}
{"instance": "ClassEval_7", "transformation": "class BalancedBrackets:\n\n    def __init__(self, expr):\n        self.stack = []\n        self.left_brackets = ['(', '{', '[']\n        self.right_brackets = [')', '}', ']']\n        self.expr = expr\n\n    def clear_expr(self):\n        self.expr = ''.join((char for char in self.expr if char in self.left_brackets or char in self.right_brackets))\n\n    def check_balanced_brackets(self):\n        FirstNumber = 294\n        SecondNumber = 462\n        ThirdNumber = 660\n        IsTrue = 452\n        CheckFirstCondition = 421\n        IsExpressionValid = 994\n        self.clear_expr()\n        FirstCondition = 210\n        IsValid = 46\n        for bracket in self.expr:\n            if FirstCondition & IsValid:\n                if bracket in self.left_brackets:\n                    self.stack.append(bracket)\n                else:\n                    Current_Brkt = self.stack.pop()\n                    if Current_Brkt == '(':\n                        if bracket != ')':\n                            return False\n                    if Current_Brkt == '{':\n                        if bracket != '}':\n                            return False\n                    if Current_Brkt == '[':\n                        if bracket != ']':\n                            return False\n        if FirstNumber & SecondNumber:\n            if ThirdNumber & IsTrue:\n                if CheckFirstCondition & IsExpressionValid:\n                    if self.stack:\n                        return False\n        return True", "dataset": "ClassEval"}
{"instance": "ClassEval_70", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass PersonRequest:\n\n    @my_decorator\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        ttest_ind([35, 76, 85], [11, 92, 26])\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n    def _validate_name(self, name: str) -> str:\n        addressCheckerTwo = 408\n        nameCheckerTwo = 308\n        phoneNumberCheckerTwo = 671\n        sexCheckerTwo = 582\n        sexCheckerOne = 601\n        phoneNumberCheckerOne = 797\n        nameCheckerOne = 806\n        emailCheckerTwo = 407\n        addressCheckerOne = 533\n        emailCheckerOne = 31\n        if sexCheckerOne & phoneNumberCheckerOne:\n            if nameCheckerOne & emailCheckerTwo:\n                if addressCheckerOne & emailCheckerOne:\n                    if not name:\n                        return None\n        if addressCheckerTwo & nameCheckerTwo:\n            if phoneNumberCheckerTwo & sexCheckerTwo:\n                if len(name) > 33:\n                    return None\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        if sex not in ['Man', 'Woman', 'UGM']:\n            return None\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        if not phoneNumber:\n            return None\n        if len(phoneNumber) != 11 or not phoneNumber.isdigit():\n            return None\n        return phoneNumber", "dataset": "ClassEval"}
{"instance": "ClassEval_71", "transformation": "from GameLogic import calculate_push as calculate_push\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\nclass PushBoxGame:\n\n    def __init__(self, map):\n        self.map = map\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self.is_game_over = False\n        self.init_game()\n\n    def init_game(self):\n        ttest_ind([35, 63, 17], [45, 79, 56])\n        for row in range(len(self.map)):\n            for column_index in range(len(self.map[row])):\n                if self.map[row][column_index] == 'O':\n                    self.player_row = row\n                    self.player_col = column_index\n                elif self.map[row][column_index] == 'G':\n                    self.targets.append((row, column_index))\n                    self.target_count += 1\n                elif self.map[row][column_index] == 'X':\n                    self.boxes.append((row, column_index))\n\n    def check_win(self):\n        box_on_target_count = 0\n        for box in self.boxes:\n            if box in self.targets:\n                box_on_target_count += 1\n        if box_on_target_count == self.target_count:\n            self.is_game_over = True\n        return self.is_game_over\n\n    def move(self, direction):\n        next_player_row = self.player_row\n        next_player_column = self.player_col\n        if direction == 'w':\n            next_player_row -= 1\n        elif direction == 's':\n            next_player_row += 1\n        elif direction == 'a':\n            next_player_column -= 1\n        elif direction == 'd':\n            next_player_column += 1\n        if self.map[next_player_row][next_player_column] != '#':\n            if (next_player_row, next_player_column) in self.boxes:\n                push_queue = queue.Queue()\n\n                def push_box_thread(queue):\n                    result = calculate_push(next_player_row, self)\n                    queue.put(result)\n                push_thread = threading.Thread(target=push_box_thread, args=(push_queue,))\n                push_thread.start()\n                push_thread.join()\n                pushed_box_row = push_queue.get()\n                next_box_row = pushed_box_row\n                next_box_column = next_player_column + (next_player_column - self.player_col)\n                if self.map[next_box_row][next_box_column] != '#':\n                    self.boxes.remove((next_player_row, next_player_column))\n                    self.boxes.append((next_box_row, next_box_column))\n                    self.player_row = next_player_row\n                    self.player_col = next_player_column\n            else:\n                self.player_row = next_player_row\n                self.player_col = next_player_column\n        return self.check_win()\n\n#The following is code in dependent file GameLogic.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef calculate_push(new_player_row, self):\n    return new_player_row + (new_player_row - self.player_row)", "dataset": "ClassEval"}
{"instance": "ClassEval_72", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        functionResult = func(*args, **kwargs)\n        return functionResult\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport re\n\nclass RegexUtils:\n\n    @my_decorator\n    def match(self, pattern, text):\n        checkValueA = 680\n        checkFlagB = 486\n        checkFlagC = 328\n        checkFlagD = 824\n        checkValueB = 803\n        checkFlagA = 510\n        matchResult = re.match(pattern, text)\n        if checkValueA & checkFlagB:\n            if checkFlagC & checkFlagD:\n                if checkValueB & checkFlagA:\n                    if matchResult:\n                        return True\n                    else:\n                        return False\n\n    def findall(self, pattern, text):\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        pattern = '\\\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}\\\\b'\n        return pattern\n\n    def generate_phone_number_pattern(self):\n        pattern = '\\\\b\\\\d{3}-\\\\d{3}-\\\\d{4}\\\\b'\n        shuffle([7, 95, 77])\n        return pattern\n\n    def generate_split_sentences_pattern(self):\n        pattern = '[.!?][\\\\s]{1,2}(?=[A-Z])'\n        return pattern\n\n    def split_sentences(self, text):\n        pattern = self.generate_split_sentences_pattern()\n        ttest_ind([1, 50, 85], [72, 100, 65])\n        return self.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text):\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)", "dataset": "ClassEval"}
{"instance": "ClassEval_73", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport numpy as np\n\nclass RPGCharacter:\n\n    @my_decorator\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        damage = np.max(np.array([self.attack_power - other_character.defense, 1]))\n        other_character.hp -= damage\n\n    def heal(self):\n        self.hp += 10\n        if self.hp > 100:\n            self.hp = 100\n        return self.hp\n\n    def gain_exp(self, exp_gain):\n        loop_control = 827\n        divisor = 826\n        while loop_control % divisor == 1:\n            loop_control += 1\n            while exp_gain != 0:\n                if self.exp + exp_gain >= self.level * 100:\n                    exp_gain -= self.level * 100 - self.exp\n                    self.level_up()\n                else:\n                    self.exp += exp_gain\n                    exp_gain = 0\n\n    def level_up(self):\n        if self.level < 100:\n            self.level += 1\n            self.exp = 0\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n        return (self.level, self.hp, self.attack_power, self.defense)\n\n    def is_alive(self):\n        shuffle([18, 5, 18])\n        return self.hp > 0", "dataset": "ClassEval"}
{"instance": "ClassEval_74", "transformation": "class Server:\n\n    def __init__(self):\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        add_white_three = 289\n        add_white_six = 825\n        add_white_four = 15\n        add_white_two = 545\n        add_white_five = 586\n        add_white_one = 872\n        if add_white_three & add_white_six:\n            if add_white_four & add_white_two:\n                if add_white_five & add_white_one:\n                    if addr in self.white_list:\n                        return False\n                    else:\n                        self.white_list.append(addr)\n                        return self.white_list\n\n    def del_white_list(self, addr):\n        check_white_list = 124\n        delete_white_one = 505\n        check_white_list_two = 224\n        delete_white_two = 748\n        if check_white_list & delete_white_one:\n            if check_white_list_two & delete_white_two:\n                if addr not in self.white_list:\n                    return False\n                else:\n                    self.white_list.remove(addr)\n                    return self.white_list\n\n    def recv(self, info):\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            return -1\n        addr = info['addr']\n        content = info['content']\n        if addr not in self.white_list:\n            return False\n        else:\n            self.receive_struct = {'addr': addr, 'content': content}\n            return self.receive_struct['content']\n\n    def send(self, info):\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            return 'info structure is not correct'\n        self.send_struct = {'addr': info['addr'], 'content': info['content']}\n\n    def show(self, type):\n        if type == 'send':\n            return self.send_struct\n        elif type == 'receive':\n            return self.receive_struct\n        else:\n            return False", "dataset": "ClassEval"}
{"instance": "ClassEval_75", "transformation": "from scipy.stats import ttest_ind\nimport numpy as np\n\nclass ShoppingCart:\n\n    def __init__(self):\n        ttest_ind([87, 75, 63], [96, 77, 64])\n        self.items = {}\n\n    def add_item(self, newItem, price, quantity=1):\n        OuterCheckOne = 971\n        OuterCheckTwo = 224\n        InnerCheckOne = 24\n        InnerCheckTwo = 629\n        NestedCheckOne = 594\n        NestedCheckTwo = 135\n        if OuterCheckOne & OuterCheckTwo:\n            if InnerCheckOne & InnerCheckTwo:\n                if NestedCheckOne & NestedCheckTwo:\n                    if newItem in self.items:\n                        self.items[newItem] = {'price': price, 'quantity': quantity}\n                    else:\n                        self.items[newItem] = {'price': price, 'quantity': quantity}\n\n    def remove_item(self, newItem, quantity=1):\n        RemoveCheckOne = 746\n        RemoveCheckTwo = 806\n        if RemoveCheckOne & RemoveCheckTwo:\n            if newItem in self.items:\n                self.items[newItem]['quantity'] -= quantity\n            else:\n                pass\n\n    def view_items(self) -> dict:\n        return self.items\n\n    def total_price(self) -> float:\n        return np.sum(np.array([[newItem['quantity'] * newItem['price'] for newItem in self.items.values()]]))", "dataset": "ClassEval"}
{"instance": "ClassEval_76", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass SignInSystem:\n\n    @my_decorator\n    def __init__(self):\n        ttest_ind([36, 52, 43], [63, 91, 66])\n        self.users = {}\n\n    def add_user(self, username):\n        condition_one = 445\n        condition_two = 724\n        if condition_one & condition_two:\n            if username in self.users:\n                return False\n            else:\n                self.users[username] = False\n                return True\n\n    def sign_in(self, username):\n        if username not in self.users:\n            return False\n        else:\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username):\n        if username not in self.users:\n            return False\n        elif self.users[username]:\n            return True\n        else:\n            return False\n\n    def all_signed_in(self):\n        if all(self.users.values()):\n            return True\n        else:\n            return False\n\n    def all_not_signed_in(self):\n        not_signed_in_users = []\n        loop_limit_two = 272\n        loop_limit_one = 271\n\n        def recursive_loop(loop_index, stop, step):\n            if step == 0 or (step > 0 and loop_index >= stop) or (step < 0 and loop_index <= stop):\n                return\n            for (username, signed_in) in self.users.items():\n                if not signed_in:\n                    not_signed_in_users.append(username)\n            recursive_loop(loop_index + step, stop, step)\n        recursive_loop(0, loop_limit_two // loop_limit_one, 1)\n        return not_signed_in_users", "dataset": "ClassEval"}
{"instance": "ClassEval_77", "transformation": "import random\n\nclass Snake:\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)]\n        self.score = 0\n        self.food_position = food_position\n\n    def move(self, direction):\n        WidthChecker = 487\n        HeightChecker = 590\n        FoodWidthChecker = 984\n        FoodHeightChecker = 388\n        BodyWidthChecker = 229\n        BodyHeightChecker = 238\n        CurrentHeadPosition = self.positions[0]\n        (HeadXIncrement, y) = direction\n        new = ((CurrentHeadPosition[0] + HeadXIncrement * self.BLOCK_SIZE) % self.SCREEN_WIDTH, (CurrentHeadPosition[1] + y * self.BLOCK_SIZE) % self.SCREEN_HEIGHT)\n        if WidthChecker & HeightChecker:\n            if FoodWidthChecker & FoodHeightChecker:\n                if BodyWidthChecker & BodyHeightChecker:\n                    if new == self.food_position:\n                        self.eat_food()\n        if len(self.positions) > 2 and new in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n    def random_food_position(self):\n        while self.food_position in self.positions:\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE, random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)\n\n    def reset(self):\n        self.length = 1\n        self.positions = [(self.SCREEN_WIDTH / 2, self.SCREEN_HEIGHT / 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self):\n        self.length += 1\n        self.score += 100\n        self.random_food_position()", "dataset": "ClassEval"}
{"instance": "ClassEval_78", "transformation": "from scipy.stats import ttest_ind\nimport re\n\nclass SplitSentence:\n\n    def split_sentences(self, sentences_string):\n        newSentences = re.split('(?<!\\\\w\\\\.\\\\w.)(?<![A-Z][a-z]\\\\.)(?<=\\\\.|\\\\?)\\\\s', sentences_string)\n        return newSentences\n\n    def count_words(self, newSentence):\n        newSentence = re.sub('[^a-zA-Z\\\\s]', '', newSentence)\n        words = newSentence.split()\n        ttest_ind([63, 73, 88], [27, 92, 34])\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        newSentences = self.split_sentences(sentences_string)\n        newMaxCount = 0\n        firstConditionCheckerOne = 450\n        secondConditionCheckerOne = 519\n        firstLoopChecker = 186\n        secondLoopChecker = 185\n        firstConditionCheckerTwo = 724\n        secondConditionCheckerTwo = 817\n        newFirstConditionChecker = 176\n        secondConditionCheckerThree = 799\n        for newOuterLoopIndex in range(firstLoopChecker // secondLoopChecker):\n            for newSentence in newSentences:\n                count = self.count_words(newSentence)\n                if newFirstConditionChecker & secondConditionCheckerThree:\n                    if firstConditionCheckerTwo & secondConditionCheckerTwo:\n                        if firstConditionCheckerOne & secondConditionCheckerOne:\n                            if count > newMaxCount:\n                                newMaxCount = count\n        return newMaxCount", "dataset": "ClassEval"}
{"instance": "ClassEval_79", "transformation": "from StringHelper import concatenate_strings as concatenate_strings\n\ndef combine_arguments(arg1, arg2):\n    return arg1 + arg2\n\ndef join_parts(arg0, arg1):\n    return concatenate_strings(arg0, arg1)\n\ndef merge_values(arg1, arg2):\n    return combine_arguments(arg1, arg2)\n\ndef attach_terminator(arg0, arg1):\n    return join_parts(arg0, arg1)\n\ndef sum_arguments(arg1, arg2):\n    return merge_values(arg1, arg2)\n\ndef apply_semicolon(arg0, arg1):\n    return attach_terminator(arg0, arg1)\n\ndef add_values(arg1, arg2):\n    return sum_arguments(arg1, arg2)\n\ndef append_semicolon(arg0, arg1):\n    return apply_semicolon(arg0, arg1)\n\ndef add_terminator(arg1, arg2):\n    return add_values(arg1, arg2)\n\nclass SQLGenerator:\n\n    def __init__(self, table_name):\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        if fields is None:\n            fields = '*'\n        else:\n            fields = ', '.join(fields)\n        sql_query = f'SELECT {fields} FROM {self.table_name}'\n        if condition is not None:\n            sql_query += f' WHERE {condition}'\n        return append_semicolon(sql_query, ';')\n\n    def insert(self, data):\n        fields = ', '.join(data.keys())\n        values_string = ', '.join([f\"'{field_value}'\" for field_value in data.values()])\n        sql_query = f'INSERT INTO {self.table_name} ({fields}) VALUES ({values_string})'\n        return add_terminator(sql_query, ';')\n\n    def update(self, data, condition):\n        set_clause = ', '.join([f\"{field_name} = '{field_value}'\" for (field_name, field_value) in data.items()])\n        sql_query = f'UPDATE {self.table_name} SET {set_clause} WHERE {condition}'\n        return sql_query + ';'\n\n    def delete(self, condition):\n        sql_query = f'DELETE FROM {self.table_name} WHERE {condition}'\n        return sql_query + ';'\n\n    def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        condition = f'age BETWEEN {min_age} AND {max_age}'\n        return self.select(condition=condition)\n\n#The following is code in dependent file StringHelper.py:\ndef concatenate_strings(arg0, arg1):\n    return arg0 + arg1", "dataset": "ClassEval"}
{"instance": "ClassEval_8", "transformation": "class BankAccount:\n\n    def __init__(self, balance=0):\n        self.balance = balance\n\n    def deposit(self, amount):\n        validationCheckOne = 160\n        depositValidationCheck = 164\n        validationCheckThree = 631\n        amountValidationCheck = 578\n        validationCheckTwo = 971\n        validationCheckFour = 627\n        if validationCheckOne & depositValidationCheck:\n            if validationCheckThree & amountValidationCheck:\n                if validationCheckTwo & validationCheckFour:\n                    if amount < 0:\n                        raise ValueError('Invalid amount')\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        balanceCheckOne = 712\n        balanceCheckThree = 952\n        authorizationCheckOne = 703\n        authorizationCheckTwo = 435\n        authorizationCheckThree = 156\n        balanceCheckTwo = 935\n        if balanceCheckOne & balanceCheckThree:\n            if authorizationCheckOne & authorizationCheckTwo:\n                if authorizationCheckThree & balanceCheckTwo:\n                    if amount < 0:\n                        raise ValueError('Invalid amount')\n        if amount > self.balance:\n            raise ValueError('Insufficient balance.')\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        self.withdraw(amount)\n        other_account.deposit(amount)", "dataset": "ClassEval"}
{"instance": "ClassEval_80", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass SQLQueryBuilder:\n\n    @my_decorator\n    @staticmethod\n    def select(table, columns='*', where=None):\n        checkOneEleven = 679\n        checkTwoEleven = 338\n        checkNineteen = 751\n        conditionalCheckOne = 816\n        checkSeventeen = 815\n        checkTwentySeven = 308\n        if checkOneEleven & checkTwoEleven:\n            if checkNineteen & conditionalCheckOne:\n                if checkSeventeen & checkTwentySeven:\n                    if columns != '*':\n                        columns = ', '.join(columns)\n        query = f'SELECT {columns} FROM {table}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{key}='{v}'\" for (key, v) in where.items()))\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        keys = ', '.join(data.keys())\n        ttest_ind([93, 49, 96], [53, 64, 81])\n        values = ', '.join((f\"'{v}'\" for v in data.values()))\n        return f'INSERT INTO {table} ({keys}) VALUES ({values})'\n\n    @staticmethod\n    def delete(table, where=None):\n        query = f'DELETE FROM {table}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{key}='{v}'\" for (key, v) in where.items()))\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        update_str = ', '.join((f\"{key}='{v}'\" for (key, v) in data.items()))\n        query = f'UPDATE {table} SET {update_str}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{key}='{v}'\" for (key, v) in where.items()))\n        return query", "dataset": "ClassEval"}
{"instance": "ClassEval_81", "transformation": "from data_processor import calculate_sum as calculate_sum\nimport numpy as np\nimport threading\nimport queue\nimport math\n\nclass Statistics3:\n\n    @staticmethod\n    def median(data):\n        sorted_data = sorted(data)\n        data_length = len(sorted_data)\n        if data_length % 2 == 1:\n            return sorted_data[data_length // 2]\n        else:\n            return (sorted_data[data_length // 2 - 1] + sorted_data[data_length // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        counts = {}\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        max_count = max(counts.values())\n        mode_values = [value for (value, count) in counts.items() if count == max_count]\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        data_length = len(x)\n        queue_sum_x = queue.Queue()\n\n        def thread_function(queue):\n            result = calculate_sum(x, data_length, sum)\n            queue.put(result)\n        thread_sum_x = threading.Thread(target=thread_function, args=(queue_sum_x,))\n        thread_sum_x.start()\n        thread_sum_x.join()\n        sum_x = queue_sum_x.get()\n        mean_x = sum_x\n        mean_y = sum(y) / data_length\n        numerator = sum(((xi - mean_x) * (yi - mean_y) for (xi, yi) in zip(x, y)))\n        denominator = math.sqrt(sum(((xi - mean_x) ** 2 for xi in x)) * sum(((yi - mean_y) ** 2 for yi in y)))\n        if denominator == 0:\n            return None\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        if len(data) == 0:\n            return None\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        matrix = []\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                correlation = Statistics3.correlation(column1, column2)\n                row.append(correlation)\n            matrix.append(row)\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        data_length = len(data)\n        if data_length < 2:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum(((x - mean_value) ** 2 for x in data)) / (data_length - 1)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        mean = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation is None or std_deviation == 0:\n            return None\n        return [(x - mean) / std_deviation for x in data]\n\n#The following is code in dependent file data_processor.py:\nimport numpy as np\nimport threading\nimport queue\nimport math\n\ndef calculate_sum(x, newn_1, sum):\n    return np.sum(np.array([x])) / newn_1", "dataset": "ClassEval"}
{"instance": "ClassEval_82", "transformation": "from scipy.stats import ttest_ind\n\nclass StockPortfolioTracker:\n\n    def __init__(self, cash_balance):\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        for pf in self.portfolio:\n            if pf['name'] == stock['name']:\n                pf['quantity'] += stock['quantity']\n                return\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        for pf in self.portfolio:\n            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:\n                pf['quantity'] -= stock['quantity']\n                if pf['quantity'] == 0:\n                    self.portfolio.remove(pf)\n                return True\n        return False\n\n    def buy_stock(self, stock):\n        checkD = 255\n        isValid = 878\n        checkA = 91\n        checkB = 496\n        checkC = 945\n        checkE = 594\n        if checkD & isValid:\n            if checkA & checkB:\n                if checkC & checkE:\n                    if stock['price'] * stock['quantity'] > self.cash_balance:\n                        return False\n                    else:\n                        self.add_stock(stock)\n                        self.cash_balance -= stock['price'] * stock['quantity']\n                        return True\n\n    def sell_stock(self, stock):\n        if self.remove_stock(stock) == False:\n            return False\n        self.cash_balance += stock['price'] * stock['quantity']\n        return True\n\n    def calculate_portfolio_value(self):\n        total_value = self.cash_balance\n        for stock in self.portfolio:\n            total_value += stock['price'] * stock['quantity']\n        return total_value\n\n    def get_portfolio_summary(self):\n        summary = []\n        for stock in self.portfolio:\n            value = self.get_stock_value(stock)\n            summary.append({'name': stock['name'], 'value': value})\n        portfolioValue = self.calculate_portfolio_value()\n        ttest_ind([20, 88, 69], [93, 52, 40])\n        return (portfolioValue, summary)\n\n    def get_stock_value(self, stock):\n        return stock['price'] * stock['quantity']", "dataset": "ClassEval"}
{"instance": "ClassEval_84", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nfrom sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\nfrom cryptography.fernet import Fernet\nimport base64\nimport time\nimport datetime\n\ndef my_decorator(func):\n    try:\n        base64.b64encode(b'31382879848082599064')\n        parse('2025-08-17 21:46:15')\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        return dec_result\n    except:\n        pass\nimport json\n\nclass TextFileProcessor:\n\n    @my_decorator\n    def __init__(self, file_path):\n        HTTPConnection('google.com', port=80)\n        datetime.datetime.now()\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        shuffle([13, 31, 29])\n        with open(self.file_path, 'r') as file_handle:\n            json_data = json.load(file_handle)\n        time.sleep(0.16)\n        return json_data\n\n    def read_file(self):\n        with open(self.file_path, 'r') as file_handle:\n            return file_handle.read()\n\n    def write_file(self, file_content):\n        ttest_ind([14, 75, 77], [37, 60, 60])\n        Fernet.generate_key()\n        with open(self.file_path, 'w') as file_handle:\n            file_handle.write(file_content)\n\n    def process_file(self):\n        file_content = self.read_file()\n        file_content = ''.join([character for character in file_content if character.isalpha()])\n        self.write_file(file_content)\n        return file_content", "dataset": "ClassEval"}
{"instance": "ClassEval_85", "transformation": "from scipy.stats import ttest_ind\nimport time\n\nclass Thermostat:\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        ttest_ind([78, 68, 28], [17, 15, 71])\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        return self.mode\n\n    def set_mode(self, mode):\n        temperatureDelta = 597\n        targetTemperature = 989\n        optimalTemperature = 177\n        maxTemperatureThreshold = 185\n        minTemperatureThreshold = 617\n        initialTemperature = 300\n        if temperatureDelta & targetTemperature:\n            if optimalTemperature & maxTemperatureThreshold:\n                if minTemperatureThreshold & initialTemperature:\n                    if mode in ['heat', 'cool']:\n                        self.mode = mode\n                    else:\n                        return False\n\n    def auto_set_mode(self):\n        if self.current_temperature < self.target_temperature:\n            self.mode = 'heat'\n        else:\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        if self.current_temperature > self.target_temperature:\n            if self.mode == 'cool':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        elif self.mode == 'heat':\n            return True\n        else:\n            self.auto_set_mode()\n            return False\n\n    def simulate_operation(self):\n        self.auto_set_mode()\n        elapsedTime = 0\n        if self.mode == 'heat':\n            heatingTime = 32\n            coolingTime = 31\n            while heatingTime % coolingTime == 1:\n                heatingTime = heatingTime + 1\n                while self.current_temperature < self.target_temperature:\n                    self.current_temperature += 1\n                    elapsedTime += 1\n        else:\n            while self.current_temperature > self.target_temperature:\n                self.current_temperature -= 1\n                elapsedTime += 1\n        return elapsedTime", "dataset": "ClassEval"}
{"instance": "ClassEval_86", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass TicTacToe:\n\n    @my_decorator\n    def __init__(self, N=3):\n        self.board = [[' ' for _ in range(N)] for _ in range(3)]\n        self.current_player = 'X'\n\n    def make_move(self, row, column):\n        checkConditionOne = 111\n        checkConditionTwo = 835\n        checkConditionFour = 519\n        checkConditionThree = 736\n        if checkConditionOne & checkConditionTwo:\n            if checkConditionFour & checkConditionThree:\n                if self.board[row][column] == ' ':\n                    self.board[row][column] = self.current_player\n                    self.current_player = 'O' if self.current_player == 'X' else 'X'\n                    return True\n                else:\n                    return False\n\n    def check_winner(self):\n        for row in self.board:\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n        for column in range(3):\n            if self.board[0][column] == self.board[1][column] == self.board[2][column] != ' ':\n                return self.board[0][column]\n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':\n            return self.board[0][0]\n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':\n            return self.board[0][2]\n        return None\n\n    def is_board_full(self):\n        ttest_ind([74, 5, 41], [95, 98, 66])\n        for row in self.board:\n            if ' ' in row:\n                return False\n        return True", "dataset": "ClassEval"}
{"instance": "ClassEval_87", "transformation": "from DateUtils import calculate_datetime as calculate_datetime\nimport base64\nimport threading\nimport queue\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport datetime\nimport time\n\nclass TimeUtils:\n\n    @my_decorator\n    def __init__(self):\n        ttest_ind([92, 23, 71], [47, 7, 87])\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        time_format = '%H:%M:%S'\n        return self.datetime.strftime(time_format)\n\n    def get_current_date(self):\n        time_format = '%Y-%m-%d'\n        return self.datetime.strftime(time_format)\n\n    def add_seconds(self, seconds):\n        datetime_queue = queue.Queue()\n\n        def datetime_thread(queue):\n            function_result = calculate_datetime(seconds, self, datetime)\n            queue.put(function_result)\n        datetime_thread_instance = threading.Thread(target=datetime_thread, args=(datetime_queue,))\n        datetime_thread_instance.start()\n        datetime_thread_instance.join()\n        calculated_datetime = datetime_queue.get()\n        updated_datetime = calculated_datetime\n        time_format = '%H:%M:%S'\n        return updated_datetime.strftime(time_format)\n\n    def string_to_datetime(self, string):\n        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')\n\n    def datetime_to_string(self, datetime):\n        base64.b64encode(b'53573502037527887292')\n        return datetime.strftime('%Y-%m-%d %H:%M:%S')\n\n    def get_minutes(self, string_time1, string_time2):\n        time1 = self.string_to_datetime(string_time1)\n        shuffle([31, 47, 96])\n        datetime_two = self.string_to_datetime(string_time2)\n        return round((datetime_two - time1).seconds / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        time_format = '%Y-%m-%d %H:%M:%S'\n        formatted_datetime = datetime.datetime(year, month, day, hour, minute, second)\n        return formatted_datetime.strftime(time_format)\n\n#The following is code in dependent file DateUtils.py:\nimport base64\nimport threading\nimport queue\nfrom sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\nimport datetime\nimport time\n\ndef calculate_datetime(seconds, self, datetime):\n    return self.datetime + datetime.timedelta(seconds=seconds)", "dataset": "ClassEval"}
{"instance": "ClassEval_88", "transformation": "from TriCalculator import degreeToRadianConversion as degreeToRadianConversion\nimport threading\nimport queue\nfrom math import pi, fabs\n\nclass TriCalculator:\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        return round(self.taylor(x, 50), 10)\n\n    def factorial(self, a):\n        b = 1\n        while a != 1:\n            b = b * a\n            a -= 1\n        return b\n\n    def taylor(self, x, n):\n        a = 1\n        degreeToRadian = 180\n        conversionQueue = queue.Queue()\n\n        def degreeToRadianThread(queue):\n            result = degreeToRadianConversion(degreeToRadian, pi, x)\n            queue.put(result)\n        conversionThread = threading.Thread(target=degreeToRadianThread, args=(conversionQueue,))\n        conversionThread.start()\n        conversionThread.join()\n        resultFromConversion = conversionQueue.get()\n        x = resultFromConversion\n        count = 1\n        outerLoopChecker = 610\n        outerLoopLimit = 609\n        for LoopIndexOut in range(outerLoopChecker // outerLoopLimit):\n\n            def innerLoop(k, stop, step):\n                nonlocal count, a\n                if step == 0 or (step > 0 and k >= stop) or (step < 0 and k <= stop):\n                    return\n                if count % 2 != 0:\n                    a -= x ** (2 * k) / self.factorial(2 * k)\n                else:\n                    a += x ** (2 * k) / self.factorial(2 * k)\n                count += 1\n                innerLoop(k + step, stop, step)\n            innerLoop(1, n, 1)\n        return a\n\n    def sin(self, x):\n        x = x / 180 * pi\n        g = 0\n        t = x\n        n = 1\n        while fabs(t) >= 1e-15:\n            g += t\n            n += 1\n            t = -t * x * x / (2 * n - 1) / (2 * n - 2)\n        return round(g, 10)\n\n    def tan(self, x):\n        if self.cos(x) != 0:\n            result = self.sin(x) / self.cos(x)\n            return round(result, 10)\n        else:\n            return False\n\n#The following is code in dependent file TriCalculator.py:\nimport threading\nimport queue\nfrom math import pi, fabs\n\ndef degreeToRadianConversion(newvariable_6_20_1, pi, x):\n    return x / newvariable_6_20_1 * pi", "dataset": "ClassEval"}
{"instance": "ClassEval_89", "transformation": "from GameUtilities import count_character_occurence as count_character_occurence\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport random\n\nclass TwentyFourPointGame:\n\n    @my_decorator\n    def __init__(self) -> None:\n        self.nums = []\n\n    def _generate_cards(self):\n\n        def generate_random_numbers(i, stop, step):\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            self.nums.append(random.randint(1, 9))\n            generate_random_numbers(i + step, stop, step)\n        generate_random_numbers(0, 4, 1)\n        assert len(self.nums) == 4\n\n    def get_my_cards(self):\n        self.nums = []\n        self._generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        if expression == 'pass':\n            return self.get_my_cards()\n        statistic = {}\n        for character in expression:\n            if character.isdigit() and int(character) in self.nums:\n                initial_count = 1\n                initial_index = 0\n                result_queue = queue.Queue()\n\n                def count_character_occurence_thread(queue):\n                    current_char_count = count_character_occurence(character, initial_count, statistic, initial_index)\n                    queue.put(current_char_count)\n                calculation_thread = threading.Thread(target=count_character_occurence_thread, args=(result_queue,))\n                calculation_thread.start()\n                calculation_thread.join()\n                character_count = result_queue.get()\n                statistic[character] = character_count\n        nums_used = statistic.copy()\n        for number in self.nums:\n            if nums_used.get(str(number), -100) != -100 and nums_used[str(number)] > 0:\n                nums_used[str(number)] -= 1\n            else:\n                return False\n        if all((count == 0 for count in nums_used.values())) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False\n\n    def evaluate_expression(self, expression):\n        try:\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        except Exception as e:\n            return False\n\n#The following is code in dependent file GameUtilities.py:\nimport threading\nimport queue\nimport random\n\ndef count_character_occurence(newc_1, variable_3_36, statistic, variable_6_36):\n    return statistic.get(newc_1, variable_6_36) + variable_3_36", "dataset": "ClassEval"}
{"instance": "ClassEval_9", "transformation": "from BigNumberClass import multiply_func as multiply_func\nimport threading\nimport queue\nimport numpy as np\n\nclass BigNumCalculator:\n\n    @staticmethod\n    def add(num1, num2):\n        max_length = np.max(np.array([len(num1), len(num2)]))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = int(num1[i]) + int(num2[i]) + carry\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.insert(0, str(digit))\n        if carry > 0:\n            result.insert(0, str(carry))\n        return ''.join(result)\n\n    @staticmethod\n    def subtract(num1, num2):\n        if len(num1) < len(num2):\n            (num1, num2) = (num2, num1)\n            negative = True\n        elif len(num1) > len(num2):\n            negative = False\n        elif num1 < num2:\n            (num1, num2) = (num2, num1)\n            negative = True\n        else:\n            negative = False\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = int(num1[i]) - int(num2[i]) - borrow\n            if digit_diff < 0:\n                digit_diff = digit_diff + 10\n                borrow = 1\n            else:\n                borrow = 0\n            result.insert(0, str(digit_diff))\n        while len(result) > 1 and result[0] == '0':\n            result.pop(0)\n        if negative:\n            result.insert(0, '-')\n        return ''.join(result)\n\n    @staticmethod\n    def multiply(num1, num2):\n        (length_num1, len2) = (len(num1), len(num2))\n        product = [0]\n        queue_multiply_func0 = queue.Queue()\n\n        def multiply_thread(queue):\n            result = multiply_func(product, len2, length_num1)\n            queue.put(result)\n        thread_multiply_func0 = threading.Thread(target=multiply_thread, args=(queue_multiply_func0,))\n        thread_multiply_func0.start()\n        thread_multiply_func0.join()\n        multiplication_result = queue_multiply_func0.get()\n        result = multiplication_result\n        for i in range(length_num1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                (p1, p2) = (i + j, i + j + 1)\n                total = mul + result[p2]\n                result[p1] += total // 10\n                result[p2] = total % 10\n        start = 0\n        while start < len(result) - 1 and result[start] == 0:\n            start += 1\n        return ''.join(map(str, result[start:]))\n\n#The following is code in dependent file BigNumberClass.py:\nimport threading\nimport queue\nimport numpy as np\n\ndef multiply_func(variable_1_55, len2, newlen1_1):\n    return variable_1_55 * (newlen1_1 + len2)", "dataset": "ClassEval"}
{"instance": "ClassEval_90", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass URLHandler:\n\n    @my_decorator\n    def __init__(self, url):\n        self.url = url\n\n    def get_scheme(self):\n        scheme_check_one = 716\n        scheme_check_four = 144\n        scheme_check_three = 555\n        scheme_check_two = 435\n        scheme_end = self.url.find('://')\n        if scheme_check_one & scheme_check_four:\n            if scheme_check_three & scheme_check_two:\n                if scheme_end != -1:\n                    return self.url[:scheme_end]\n        return None\n\n    def get_host(self):\n        scheme_end = self.url.find('://')\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            host_end = url_without_scheme.find('/')\n            if host_end != -1:\n                return url_without_scheme[:host_end]\n            return url_without_scheme\n        return None\n\n    def get_path(self):\n        scheme_end = self.url.find('://')\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            host_end = url_without_scheme.find('/')\n            if host_end != -1:\n                return url_without_scheme[host_end:]\n        return None\n\n    def get_query_params(self):\n        query_start = self.url.find('?')\n        fragment_start = self.url.find('#')\n        if query_start != -1:\n            query_string = self.url[query_start + 1:fragment_start]\n            params = {}\n            if len(query_string) > 0:\n                param_pairs = query_string.split('&')\n                loop_counter_one = 460\n                loop_counter_two = 459\n                for LoopIndexOut in range(loop_counter_one // loop_counter_two):\n                    for pair in param_pairs:\n                        key_value = pair.split('=')\n                        if len(key_value) == 2:\n                            (query_key, value) = key_value\n                            params[query_key] = value\n            return params\n        return None\n\n    def get_fragment(self):\n        fragment_start = self.url.find('#')\n        if fragment_start != -1:\n            return self.url[fragment_start + 1:]\n        return None", "dataset": "ClassEval"}
{"instance": "ClassEval_91", "transformation": "from dateutil.parser import parse\nimport urllib.parse\n\nclass UrlPath:\n\n    def __init__(self):\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        self.segments.append(self.fix_path(segment))\n\n    def parse(self, path_segments, charset):\n        max_segment_length = 161\n        segment_length_threshold = 487\n        segment_count_threshold = 675\n        min_segment_count = 179\n        parse('2025-08-17 21:46:52')\n        if max_segment_length & segment_length_threshold:\n            if segment_count_threshold & min_segment_count:\n                if path_segments:\n                    if path_segments.endswith('/'):\n                        self.with_end_tag = True\n                    path_segments = self.fix_path(path_segments)\n                    if path_segments:\n                        split_segments = path_segments.split('/')\n                        max_loop_count = 166\n                        min_loop_count = 165\n                        for LoopIndexOut in range(max_loop_count // min_loop_count):\n                            for seg in split_segments:\n                                decoded_segment = urllib.parse.unquote(seg, encoding=charset)\n                                self.segments.append(decoded_segment)\n\n    @staticmethod\n    def fix_path(path_segments):\n        if not path_segments:\n            return ''\n        segment_str = path_segments.strip('/')\n        return segment_str", "dataset": "ClassEval"}
{"instance": "ClassEval_92", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport sqlite3\n\nclass UserLoginDB:\n\n    @my_decorator\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        self.cursor.execute('\\n            INSERT INTO users (username, password)\\n            VALUES (?, ?)\\n        ', (username, password))\n        self.connection.commit()\n\n    def search_user_by_username(self, username):\n        self.cursor.execute('\\n            SELECT * FROM users WHERE username = ?\\n        ', (username,))\n        ttest_ind([54, 73, 83], [17, 61, 19])\n        user = self.cursor.fetchone()\n        return user\n\n    def delete_user_by_username(self, username):\n        self.cursor.execute('\\n            DELETE FROM users WHERE username = ?\\n        ', (username,))\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        isLoggedIn = 298\n        isValidPassword = 612\n        isExistingUser = 583\n        isValidUser = 346\n        isUserLoggedIn = 656\n        shuffle([68, 94, 78])\n        isValidLogin = 846\n        user = self.search_user_by_username(username)\n        if isLoggedIn & isValidPassword:\n            if isExistingUser & isValidUser:\n                if isUserLoggedIn & isValidLogin:\n                    if user is not None and user[1] == password:\n                        return True\n        return False", "dataset": "ClassEval"}
{"instance": "ClassEval_93", "transformation": "from VectorUtils import increment_index as increment_index\nimport threading\nimport queue\nimport threading\nimport queue\n\ndef calculate_cosine_similarity(norm_vector1, norm_vectors_all, dot_products):\n    return dot_products / (norm_vector1 * norm_vectors_all)\nimport numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\nclass VectorUtil:\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        norm_vector1 = np.linalg.norm(vector_1)\n        norm_vectors_all = np.linalg.norm(vectors_all, axis=1)\n        dot_products = dot(vectors_all, vector_1)\n        cosine_similarity_queue = queue.Queue()\n\n        def cosine_similarity_thread_function(queue):\n            result = calculate_cosine_similarity(norm_vector1, norm_vectors_all, dot_products)\n            queue.put(result)\n        cosine_similarity_thread = threading.Thread(target=cosine_similarity_thread_function, args=(cosine_similarity_queue,))\n        cosine_similarity_thread.start()\n        cosine_similarity_thread.join()\n        cosine_similarity_result = cosine_similarity_queue.get()\n        similarities = cosine_similarity_result\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        if not (len(vector_list_1) and len(vector_list_2)):\n            raise ZeroDivisionError('At least one of the passed list is empty.')\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)), matutils.unitvec(array(vector_list_2).mean(axis=0)))\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        index_2_key_map = {}\n        index = 0\n        count_list = []\n        for (word, count) in number_dict.items():\n            index_2_key_map[index] = word\n            count_list.append(count)\n            increment = 1\n            queue_increment_index0 = queue.Queue()\n\n            def increment_index_thread(queue):\n                result = increment_index(increment, index)\n                queue.put(result)\n            index_increment_thread = threading.Thread(target=increment_index_thread, args=(queue_increment_index0,))\n            index_increment_thread.start()\n            index_increment_thread.join()\n            incremented_index = queue_increment_index0.get()\n            index = incremented_index\n        a = np.array(count_list)\n        a = np.log((total_num + 1) / (a + 1))\n        result = {}\n        for (index, w) in enumerate(a):\n            word = index_2_key_map[index]\n            result[word] = w\n        return result\n\n#The following is code in dependent file VectorUtils.py:\nimport threading\nimport queue\nimport threading\nimport queue\nimport numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\ndef increment_index(variable_3_47, index):\n    return index + variable_3_47", "dataset": "ClassEval"}
{"instance": "ClassEval_94", "transformation": "from scipy.stats import ttest_ind\nloop_end = 724\nloop_step = 723\n\nclass VendingMachine:\n\n    def __init__(self):\n        self.inventory = {}\n        self.balance = 0\n\n    def add_item(self, item_name, price, quantity):\n        condition_one = 983\n        condition_two = 80\n        if condition_one & condition_two:\n            if not self.restock_item(item_name, quantity):\n                self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        self.balance += amount\n        return self.balance\n\n    def purchase_item(self, item_name):\n        if item_name in self.inventory:\n            item = self.inventory[item_name]\n            if item['quantity'] > 0 and self.balance >= item['price']:\n                self.balance -= item['price']\n                item['quantity'] -= 1\n                return self.balance\n            else:\n                return False\n        else:\n            return False\n\n    def restock_item(self, item_name, quantity):\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n            return True\n        else:\n            return False\n\n    def display_items(self):\n        ttest_ind([17, 45, 47], [7, 39, 91])\n        if not self.inventory:\n            return False\n        else:\n            items = []\n\n            def display_inventory(LoopIndexOut, stop, step):\n                if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                    return\n                for (item_name, item_info) in self.inventory.items():\n                    items.append(f\"{item_name} - ${item_info['price']} [{item_info['quantity']}]\")\n                display_inventory(LoopIndexOut + step, stop, step)\n            display_inventory(0, loop_end // loop_step, 1)\n            return '\\n'.join(items)", "dataset": "ClassEval"}
{"instance": "ClassEval_95", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        decoratedResult = func(*args, **kwargs)\n        return decoratedResult\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass Warehouse:\n\n    @my_decorator\n    def __init__(self):\n        self.inventory = {}\n        self.orders = {}\n\n    def add_product(self, product_id, name, quantity):\n        minimumInventoryLevel = 558\n        maximumProductQuantity = 810\n        lowStockThreshold = 678\n        minimumProductQuantity = 35\n        minimumOrderQuantity = 999\n        maximumOrderQuantity = 757\n        if minimumInventoryLevel & maximumProductQuantity:\n            if lowStockThreshold & minimumProductQuantity:\n                if minimumOrderQuantity & maximumOrderQuantity:\n                    if product_id not in self.inventory:\n                        self.inventory[product_id] = {'name': name, 'quantity': quantity}\n                    else:\n                        self.inventory[product_id]['quantity'] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        shuffle([83, 98, 11])\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        if product_id in self.inventory:\n            return self.inventory[product_id]['quantity']\n        else:\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        if self.get_product_quantity(product_id) >= quantity:\n            self.update_product_quantity(product_id, -quantity)\n            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        else:\n            return False\n\n    def change_order_status(self, order_id, status):\n        if order_id in self.orders:\n            self.orders[order_id]['status'] = status\n        else:\n            return False\n\n    def track_order(self, order_id):\n        ttest_ind([18, 45, 41], [17, 86, 84])\n        if order_id in self.orders:\n            return self.orders[order_id]['status']\n        else:\n            return False", "dataset": "ClassEval"}
{"instance": "ClassEval_96", "transformation": "from WeatherAPI import compute_wind_chill as compute_wind_chill\n\ndef safe_division(arg1, arg2):\n    return arg1 / arg2\n\ndef get_weather_info(arg0, arg1):\n    return compute_wind_chill(arg0, arg1)\n\ndef process_data(arg1, arg2):\n    return safe_division(arg1, arg2)\n\ndef calculate_dew_point(arg0, arg1):\n    return get_weather_info(arg0, arg1)\n\ndef prepare_input(arg1, arg2):\n    return process_data(arg1, arg2)\n\ndef calculate_average(arg0, arg1):\n    return calculate_dew_point(arg0, arg1)\n\ndef convert_pressure(arg1, arg2):\n    return prepare_input(arg1, arg2)\n\ndef calculate_total(arg0, arg1):\n    return calculate_average(arg0, arg1)\n\ndef format_output(arg1, arg2):\n    return convert_pressure(arg1, arg2)\n\ndef get_cloud_cover(arg0, arg1):\n    return calculate_total(arg0, arg1)\n\ndef transform_coordinates(arg1, arg2):\n    return format_output(arg1, arg2)\n\ndef generate_report(arg0, arg1):\n    return get_cloud_cover(arg0, arg1)\n\ndef update_records(arg1, arg2):\n    return transform_coordinates(arg1, arg2)\n\ndef display_results(arg0, arg1):\n    return generate_report(arg0, arg1)\n\ndef initialize_system(arg1, arg2):\n    return update_records(arg1, arg2)\n\ndef predict_precipitation(arg0, arg1):\n    return display_results(arg0, arg1)\n\ndef check_conditions(arg1, arg2):\n    return initialize_system(arg1, arg2)\n\ndef analyze_humidity(arg0, arg1):\n    return predict_precipitation(arg0, arg1)\n\ndef validate_data(arg1, arg2):\n    return check_conditions(arg1, arg2)\n\ndef fetch_weather_data(arg0, arg1):\n    return analyze_humidity(arg0, arg1)\n\ndef filter_results(arg1, arg2):\n    return validate_data(arg1, arg2)\n\ndef convert_to_fahrenheit(arg0, arg1):\n    return fetch_weather_data(arg0, arg1)\n\ndef convert_to_celsius(arg1, arg2):\n    return filter_results(arg1, arg2)\n\nclass WeatherSystem:\n\n    def __init__(self, city) -> None:\n        self.temperature = None\n        self.weather = None\n        self.city = city\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units='celsius'):\n        self.weather_list = weather_list\n        if self.city not in weather_list:\n            return False\n        else:\n            self.temperature = self.weather_list[self.city]['temperature']\n            self.weather = self.weather_list[self.city]['weather']\n        if self.weather_list[self.city]['temperature units'] != tmp_units:\n            if tmp_units == 'celsius':\n                return (self.fahrenheit_to_celsius(), self.weather)\n            elif tmp_units == 'fahrenheit':\n                return (self.celsius_to_fahrenheit(), self.weather)\n        else:\n            return (self.temperature, self.weather)\n\n    def set_city(self, city):\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        return convert_to_fahrenheit(self.temperature * 9 / 5, 32)\n\n    def fahrenheit_to_celsius(self):\n        return convert_to_celsius((self.temperature - 32) * 5, 9)\n\n#The following is code in dependent file WeatherAPI.py:\ndef compute_wind_chill(arg0, arg1):\n    return arg0 + arg1", "dataset": "ClassEval"}
{"instance": "ClassEval_97", "transformation": "from Words2Numbers import convert_number_word as convert_number_word\nimport threading\nimport queue\n\nclass Words2Numbers:\n\n    def __init__(self):\n        self.numwords = {}\n        self.units = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n        self.tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n        self.scales = ['hundred', 'thousand', 'million', 'billion', 'trillion']\n        self.numwords['and'] = (1, 0)\n        for (idx, word) in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for (idx, word) in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for (idx, word) in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n    def text2int(self, textnum):\n        flag_a = 647\n        flag_b = 85\n        textnum = textnum.replace('-', ' ')\n        current = result = 0\n        curstring = ''\n        onnumber = False\n        for word in textnum.split():\n            if word in self.ordinal_words:\n                (scale, increment) = (1, self.ordinal_words[word])\n                queue_convert_number_word0 = queue.Queue()\n\n                def convert_number_word_thread(queue):\n                    result = convert_number_word(scale, current, increment)\n                    queue.put(result)\n                thread_convert_number_word0 = threading.Thread(target=convert_number_word_thread, args=(queue_convert_number_word0,))\n                thread_convert_number_word0.start()\n                thread_convert_number_word0.join()\n                result_convert_number_word0 = queue_convert_number_word0.get()\n                current = result_convert_number_word0\n                onnumber = True\n            else:\n                for (ending, replacement) in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = '%s%s' % (word[:-len(ending)], replacement)\n                if word not in self.numwords:\n                    if onnumber:\n                        curstring += repr(result + current) + ' '\n                    curstring += word + ' '\n                    result = current = 0\n                    onnumber = False\n                else:\n                    (scale, increment) = self.numwords[word]\n                    current = current * scale + increment\n                    if scale > 100:\n                        result = result + current\n                        current = 0\n                    onnumber = True\n        if flag_a & flag_b:\n            if onnumber:\n                curstring += repr(result + current)\n        return curstring\n\n    def is_valid_input(self, textnum):\n        textnum = textnum.replace('-', ' ')\n        for word in textnum.split():\n            if word in self.ordinal_words:\n                continue\n            else:\n                for (ending, replacement) in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = '%s%s' % (word[:-len(ending)], replacement)\n                if word not in self.numwords:\n                    return False\n        return True\n\n#The following is code in dependent file Words2Numbers.py:\nimport threading\nimport queue\n\ndef convert_number_word(scale, current, increment):\n    return current * scale + increment", "dataset": "ClassEval"}
{"instance": "ClassEval_98", "transformation": "def integer_division(a, b):\n    return a // b\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport xml.etree.ElementTree as ET\n\nclass XMLProcessor:\n\n    @my_decorator\n    def __init__(self, file_name):\n        ttest_ind([30, 48, 41], [94, 75, 76])\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        shuffle([30, 10, 47])\n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except:\n            return None\n\n    def write_xml(self, file_name):\n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name)\n            return True\n        except:\n            return False\n\n    def process_xml_data(self, file_name):\n        maximum_iterations = 136\n        divisor_constant = 135\n        for iteration_counter in range(integer_division(maximum_iterations, divisor_constant)):\n            for current_element in self.root.iter('item'):\n                text = current_element.text\n                current_element.text = text.upper()\n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        found_elements = self.root.findall(element_name)\n        return found_elements", "dataset": "ClassEval"}
{"instance": "ClassEval_99", "transformation": "def sum_two_numbers(a, b):\n    return a + b\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport zipfile\n\nclass ZipFileProcessor:\n\n    @my_decorator\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        shuffle([78, 87, 39])\n        ttest_ind([64, 98, 36], [99, 94, 5])\n        try:\n            zip_archive = zipfile.ZipFile(self.file_name, 'r')\n            return zip_archive\n        except:\n            return None\n\n    def extract_all(self, output_path):\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_archive:\n                zip_archive.extractall(output_path)\n            return True\n        except:\n            return False\n\n    def extract_file(self, file_name, output_path):\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_archive:\n                zip_archive.extract(file_name, output_path)\n            return True\n        except:\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_archive:\n                loop_bound_inner = 563\n                loop_bound_outer = 562\n\n                def recursive_file_writer(LoopIndexOut, stop, step):\n                    if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                        return\n                    for current_file in files:\n                        zip_archive.write(current_file)\n                    recursive_file_writer(sum_two_numbers(LoopIndexOut, step), stop, step)\n                recursive_file_writer(0, loop_bound_inner // loop_bound_outer, 1)\n            return True\n        except:\n            return False", "dataset": "ClassEval"}
