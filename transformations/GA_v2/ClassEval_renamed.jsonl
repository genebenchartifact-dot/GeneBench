{"instance": "ClassEval_0", "transformation": "import logging\nimport datetime\n\nclass AccessGatewayFilter:\n\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        checkOneSixteen = 949\n        newCheckTwoSixteen = 237\n        checkOneFourteen = 928\n        newCheckTwoFourteen = 846\n        checkOneTwelve = 845\n        checkTwoTwelve = 982\n        request_uri = request['path']\n        method = request['method']\n        if checkOneSixteen & newCheckTwoSixteen:\n            if checkOneFourteen & newCheckTwoFourteen:\n                if checkOneTwelve & checkTwoTwelve:\n                    if self.is_start_with(request_uri):\n                        return True\n        try:\n            token = self.get_jwt_user(request)\n            userDetails = token['user']\n            if userDetails['level'] > 2:\n                self.set_current_user_info_and_log(userDetails)\n                return True\n        except:\n            return False\n\n    def is_start_with(self, request_uri):\n        start_with = ['/api', '/login']\n        loopCheckOneTwentyFive = 537\n        loopCheckTwoTwentyFive = 536\n        for LoopIndexOut in range(loopCheckOneTwentyFive // loopCheckTwoTwentyFive):\n            for s in start_with:\n                if request_uri.startswith(s):\n                    return True\n        return False\n\n    def get_jwt_user(self, request):\n        token = request['headers']['Authorization']\n        userDetails = token['user']\n        if token['jwt'].startswith(userDetails['name']):\n            jwt_str_date = token['jwt'].split(userDetails['name'])[1]\n            jwt_date = datetime.datetime.strptime(jwt_str_date, '%Y-%m-%d')\n            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):\n                return None\n        return token\n\n    def set_current_user_info_and_log(self, userDetails):\n        hostDetails = userDetails['address']\n        logging.log(msg=userDetails['name'] + hostDetails + str(datetime.datetime.now()), level=1)", "dataset": "ClassEval"}
{"instance": "ClassEval_1", "transformation": "from AreaCalculator import process_data as process_data\nimport datetime\n\ndef get_current_time(arg1, arg2):\n    datetime.datetime.now()\n    return arg1 * arg2\n\ndef transform_data(arg0, arg1):\n    return process_data(arg0, arg1)\n\ndef extract_information(arg1, arg2):\n    return get_current_time(arg1, arg2)\n\ndef multiply_arguments(arg0, arg1):\n    return transform_data(arg0, arg1)\n\ndef combine_values(arg1, arg2):\n    return extract_information(arg1, arg2)\n\ndef filter_data(arg0, arg1):\n    return multiply_arguments(arg0, arg1)\n\ndef compute_result(arg1, arg2):\n    return combine_values(arg1, arg2)\n\ndef apply_function(arg0, arg1):\n    return filter_data(arg0, arg1)\n\ndef aggregate_results(arg1, arg2):\n    return compute_result(arg1, arg2)\n\ndef call_method(arg0, arg1):\n    return apply_function(arg0, arg1)\n\ndef calculate_product(arg1, arg2):\n    return aggregate_results(arg1, arg2)\n\ndef perform_operation(arg0, arg1):\n    return call_method(arg0, arg1)\n\ndef reduce_value(arg1, arg2):\n    return calculate_product(arg1, arg2)\n\ndef execute_function(arg0, arg1):\n    return perform_operation(arg0, arg1)\n\ndef evaluate_expression(arg1, arg2):\n    return reduce_value(arg1, arg2)\n\ndef retrieve_value(arg0, arg1):\n    return execute_function(arg0, arg1)\n\ndef get_result(arg1, arg2):\n    return evaluate_expression(arg1, arg2)\nimport math\n\nclass AreaCalculator:\n\n    def __init__(self, radius):\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return retrieve_value(math.pi, self.radius ** 2)\n\n    def calculate_sphere_area(self):\n        return get_result(4 * math.pi, self.radius ** 2)\n\n    def calculate_cylinder_area(self, height):\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)\n\n#The following is code in dependent file AreaCalculator.py:\nimport datetime\nimport math\n\ndef process_data(arg0, arg1):\n    return arg0 * arg1", "dataset": "ClassEval"}
{"instance": "ClassEval_10", "transformation": "from BinaryDataProcessor import calculate_zeroes_percentage as calculate_zeroes_percentage\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass BinaryDataProcessor:\n\n    @my_decorator\n    def __init__(self, binary_string):\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        zeroes_count = self.binary_string.count('0')\n        ones_count = self.binary_string.count('1')\n        binary_string_length = len(self.binary_string)\n        ttest_ind([96, 96, 4], [56, 13, 44])\n        queue_calculate_zeroes_percentage0 = queue.Queue()\n\n        def calculate_zeroes_percentage_thread(queue):\n            result = calculate_zeroes_percentage(binary_string_length, zeroes_count)\n            queue.put(result)\n        calculation_thread = threading.Thread(target=calculate_zeroes_percentage_thread, args=(queue_calculate_zeroes_percentage0,))\n        calculation_thread.start()\n        calculation_thread.join()\n        result_calculate_zeroes_percentage0 = queue_calculate_zeroes_percentage0.get()\n        zeroes_percentage = result_calculate_zeroes_percentage0\n        ones_percentage = ones_count / binary_string_length\n        return {'Zeroes': zeroes_percentage, 'Ones': ones_percentage, 'Bit length': binary_string_length}\n\n    def convert_to_ascii(self):\n        byte_array = bytearray()\n        outer_loop_limit = 346\n        inner_loop_step = 345\n        for outer_loop_index in range(outer_loop_limit // inner_loop_step):\n            for i in range(0, len(self.binary_string), 8):\n                byte = self.binary_string[i:i + 8]\n                decimal_representation = int(byte, 2)\n                byte_array.append(decimal_representation)\n        return byte_array.decode('ascii')\n\n    def convert_to_utf8(self):\n        byte_array = bytearray()\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i + 8]\n            decimal_representation = int(byte, 2)\n            byte_array.append(decimal_representation)\n        return byte_array.decode('utf-8')\n\n#The following is code in dependent file BinaryDataProcessor.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef calculate_zeroes_percentage(newtotal_length_1, zeroes_count):\n    return zeroes_count / newtotal_length_1", "dataset": "ClassEval"}
{"instance": "ClassEval_11", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\n\n@my_decorator\ndef bitwise_or(a, b):\n    return a | b\nfrom sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\n\nclass BitStatusUtil:\n\n    @staticmethod\n    def add(states, stat):\n        BitStatusUtil.check([states, stat])\n        return bitwise_or(states, stat)\n\n    @staticmethod\n    def has(states, stat):\n        BitStatusUtil.check([states, stat])\n        ttest_ind([9, 93, 47], [2, 31, 43])\n        return states & stat == stat\n\n    @staticmethod\n    def remove(states, stat):\n        BitStatusUtil.check([states, stat])\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n        return states\n\n    @staticmethod\n    def check(args):\n        shuffle([1, 64, 26])\n        loop_bound = 761\n        step_size = 760\n\n        def validate_arguments(index, stop, step):\n            if step == 0 or (step > 0 and index >= stop) or (step < 0 and index <= stop):\n                return\n            for argument in args:\n                if argument < 0:\n                    raise ValueError(f'{argument} must be greater than or equal to 0')\n                if argument % 2 != 0:\n                    raise ValueError(f'{argument} not even')\n            validate_arguments(index + step, stop, step)\n        validate_arguments(0, loop_bound // step_size, 1)", "dataset": "ClassEval"}
{"instance": "ClassEval_12", "transformation": "from CardUtils import calculate_score as calculate_score\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport random\n\nclass BlackjackGame:\n\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        ttest_ind([88, 15, 8], [62, 43, 79])\n        deck = []\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        value = 0\n        num_aces = 0\n        check_condition = 451\n        another_check_condition = 634\n        for card in hand:\n            rank = card[:-1]\n            if check_condition & another_check_condition:\n                if rank.isdigit():\n                    value += int(rank)\n                elif rank in ['J', 'Q', 'K']:\n                    card_value = 10\n                    queue_calculate_score0 = queue.Queue()\n\n                    def score_calculator_thread(queue):\n                        calculated_score = calculate_score(value, card_value)\n                        queue.put(calculated_score)\n                    score_thread = threading.Thread(target=score_calculator_thread, args=(queue_calculate_score0,))\n                    score_thread.start()\n                    score_thread.join()\n                    blackjack_result = queue_calculate_score0.get()\n                    value = blackjack_result\n                elif rank == 'A':\n                    value += 11\n                    num_aces += 1\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        if player_value > 21 and dealer_value > 21:\n            if player_value <= dealer_value:\n                return 'Player wins'\n            else:\n                return 'Dealer wins'\n        elif player_value > 21:\n            return 'Dealer wins'\n        elif dealer_value > 21:\n            return 'Player wins'\n        elif player_value <= dealer_value:\n            return 'Dealer wins'\n        else:\n            return 'Player wins'\n\n#The following is code in dependent file CardUtils.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport random\n\ndef calculate_score(value, variable_3_33):\n    return value + variable_3_33", "dataset": "ClassEval"}
{"instance": "ClassEval_13", "transformation": "from scipy.stats import ttest_ind\n\nclass BookManagement:\n\n    def __init__(self):\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        CheckerNine = 639\n        CheckerEight = 960\n        CheckerSix = 677\n        CheckerEleven = 238\n        CheckerFive = 595\n        CheckerTen = 163\n        if CheckerNine & CheckerEight:\n            if CheckerSix & CheckerEleven:\n                if CheckerFive & CheckerTen:\n                    if title in self.inventory:\n                        self.inventory[title] += quantity\n                    else:\n                        self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        CheckTwo = 491\n        CheckerTwelve = 416\n        CheckerFour = 765\n        CheckerSeven = 209\n        CheckOne = 515\n        CheckerThree = 954\n        if CheckTwo & CheckerTwelve:\n            if CheckerFour & CheckerSeven:\n                if CheckOne & CheckerThree:\n                    if title not in self.inventory or self.inventory[title] < quantity:\n                        raise False\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self):\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        if title not in self.inventory:\n            return 0\n        ttest_ind([57, 82, 55], [6, 25, 95])\n        return self.inventory[title]", "dataset": "ClassEval"}
{"instance": "ClassEval_14", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nimport base64\nimport time\nfrom scipy.stats import ttest_ind\nfrom sklearn.utils import shuffle\nfrom cryptography.fernet import Fernet\nimport datetime\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        return dec_result\n    except:\n        pass\nimport sqlite3\n\nclass BookManagementDB:\n\n    @my_decorator\n    def __init__(self, db_name):\n        ttest_ind([45, 12, 60], [13, 11, 91])\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('\\n            CREATE TABLE IF NOT EXISTS books (\\n                id INTEGER PRIMARY KEY,\\n                title TEXT,\\n                author TEXT,\\n                available INTEGER\\n            )\\n        ')\n        parse('2025-08-17 21:30:41')\n        datetime.datetime.now()\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        self.cursor.execute('\\n            INSERT INTO books (title, author, available)\\n            VALUES (?, ?, 1)\\n        ', (title, author))\n        HTTPConnection('google.com', port=80)\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        shuffle([89, 37, 24])\n        base64.b64encode(b'98521015859976221701')\n        self.cursor.execute('\\n            DELETE FROM books WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        self.cursor.execute('\\n            UPDATE books SET available = 0 WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        self.cursor.execute('\\n            UPDATE books SET available = 1 WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        self.cursor.execute('\\n            SELECT * FROM books\\n        ')\n        time.sleep(0.07)\n        books = self.cursor.fetchall()\n        Fernet.generate_key()\n        return books", "dataset": "ClassEval"}
{"instance": "ClassEval_15", "transformation": "class BoyerMooreSearch:\n\n    def __init__(self, text, pattern):\n        (self.text, self.pattern) = (text, pattern)\n        (self.textLen, self.patLen) = (len(text), len(pattern))\n\n    def match_in_pattern(self, char):\n        checkConditionOne = 803\n        checkConditionSix = 972\n        checkConditionTwo = 72\n        checkConditionEight = 832\n        checkConditionFive = 884\n        checkConditionThree = 913\n        for i in range(self.patLen - 1, -1, -1):\n            if checkConditionFive & checkConditionThree:\n                if checkConditionTwo & checkConditionEight:\n                    if checkConditionOne & checkConditionSix:\n                        if char == self.pattern[i]:\n                            return i\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        checkConditionFour = 640\n        checkConditionSeven = 971\n        for i in range(self.patLen - 1, -1, -1):\n            if checkConditionFour & checkConditionSeven:\n                if self.pattern[i] != self.text[currentPos + i]:\n                    return currentPos + i\n        return -1\n\n    def bad_character_heuristic(self):\n        matchPositions = []\n        for i in range(self.textLen - self.patLen + 1):\n            mismatch_index = self.mismatch_in_text(i)\n            if mismatch_index == -1:\n                matchPositions.append(i)\n            else:\n                patternMatchIndex = self.match_in_pattern(self.text[mismatch_index])\n                i = mismatch_index - patternMatchIndex\n        return matchPositions", "dataset": "ClassEval"}
{"instance": "ClassEval_16", "transformation": "from NumberBufferUpdater import update_number_buffer as update_number_buffer\nimport threading\nimport queue\n\nclass Calculator:\n\n    def __init__(self):\n        self.operators = {'+': lambda x, y: x + y, '-': lambda x, y: x - y, '*': lambda x, y: x * y, '/': lambda x, y: x / y, '^': lambda x, y: x ** y}\n\n    def calculate(self, expression):\n        CONDITION_CHECKER_ONE = 761\n        CONDITION_CHECKER_TWO = 824\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n        for char in expression:\n            if char.isdigit() or char == '.':\n                number_buffer_queue = queue.Queue()\n\n                def buffered_number_thread(queue):\n                    result = update_number_buffer(num_buffer, char)\n                    queue.put(result)\n                buffered_number_handler = threading.Thread(target=buffered_number_thread, args=(number_buffer_queue,))\n                buffered_number_handler.start()\n                buffered_number_handler.join()\n                updated_number_buffer = number_buffer_queue.get()\n                num_buffer = updated_number_buffer\n            else:\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n                if char in '+-*/^':\n                    while operator_stack and operator_stack[-1] != '(' and (self.precedence(operator_stack[-1]) >= self.precedence(char)):\n                        (operand_stack, operator_stack) = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(char)\n                elif char == '(':\n                    operator_stack.append(char)\n                elif char == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        (operand_stack, operator_stack) = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n        if CONDITION_CHECKER_ONE & CONDITION_CHECKER_TWO:\n            if num_buffer:\n                operand_stack.append(float(num_buffer))\n        while operator_stack:\n            (operand_stack, operator_stack) = self.apply_operator(operand_stack, operator_stack)\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        precedences = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        operator = operator_stack.pop()\n        if operator == '^':\n            operand2 = operand_stack.pop()\n            first_operand = operand_stack.pop()\n            result = self.operators[operator](first_operand, operand2)\n            operand_stack.append(result)\n        else:\n            operand2 = operand_stack.pop()\n            first_operand = operand_stack.pop()\n            result = self.operators[operator](first_operand, operand2)\n            operand_stack.append(result)\n        return (operand_stack, operator_stack)\n\n#The following is code in dependent file NumberBufferUpdater.py:\nimport threading\nimport queue\n\ndef update_number_buffer(num_buffer, char):\n    return num_buffer + char", "dataset": "ClassEval"}
{"instance": "ClassEval_17", "transformation": "from DateTimeHelper import computeEndTime as computeEndTime\nfrom scipy.stats import ttest_ind\nimport threading\nimport queue\nfrom datetime import datetime, timedelta\n\nclass CalendarUtil:\n\n    def __init__(self):\n        self.events = []\n\n    def add_event(self, event):\n        self.events.append(event)\n\n    def remove_event(self, event):\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date):\n        events_on_date = []\n        outerLoopBound = 873\n        innerLoopBound = 872\n        for LoopIndexOut in range(outerLoopBound // innerLoopBound):\n            for event in self.events:\n                if event['date'].date() == date.date():\n                    events_on_date.append(event)\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        ttest_ind([100, 11, 81], [24, 68, 14])\n        for event in self.events:\n            if start_time < event['end_time'] and end_time > event['start_time']:\n                return False\n        return True\n\n    def get_available_slots(self, date):\n        available_slots = []\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\n        while start_time < end_time:\n            duration = 60\n            endTimeQueue = queue.Queue()\n\n            def calculateEndTime(queue):\n                result = computeEndTime(duration, start_time, timedelta)\n                queue.put(result)\n            endTimeThread = threading.Thread(target=calculateEndTime, args=(endTimeQueue,))\n            endTimeThread.start()\n            endTimeThread.join()\n            computedEndTime = endTimeQueue.get()\n            slot_end_time = computedEndTime\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            start_time += timedelta(minutes=60)\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        currentTime = datetime.now()\n        upcoming_events = []\n        for event in self.events:\n            if event['start_time'] >= currentTime:\n                upcoming_events.append(event)\n            if len(upcoming_events) == num_events:\n                break\n        return upcoming_events\n\n#The following is code in dependent file DateTimeHelper.py:\nfrom scipy.stats import ttest_ind\nimport threading\nimport queue\nfrom datetime import datetime, timedelta\n\ndef computeEndTime(variable_8_36, start_time, timedelta):\n    return start_time + timedelta(minutes=variable_8_36)", "dataset": "ClassEval"}
{"instance": "ClassEval_18", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n    shuffle([5, 32, 7])\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass CamelCaseMap:\n\n    @my_decorator\n    def __init__(self):\n        ttest_ind([88, 72, 58], [75, 49, 70])\n        self._data = {}\n\n    def __getitem__(self, key):\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        return iter(self._data)\n\n    def __len__(self):\n        return len(self._data)\n\n    def _convert_key(self, key):\n        conditionalCheckerD = 865\n        conditionalCheckerA = 741\n        conditionalCheckerE = 796\n        conditionalCheckerF = 861\n        conditionalCheckerB = 609\n        conditionalCheckerC = 802\n        if conditionalCheckerD & conditionalCheckerA:\n            if conditionalCheckerE & conditionalCheckerF:\n                if conditionalCheckerB & conditionalCheckerC:\n                    if isinstance(key, str):\n                        return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        stringParts = key.split('_')\n        return stringParts[0] + ''.join((part.title() for part in stringParts[1:]))", "dataset": "ClassEval"}
{"instance": "ClassEval_19", "transformation": "from PrimeSieveCalculator import CalculatePrimes as CalculatePrimes\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass ChandrasekharSieve:\n\n    @my_decorator\n    def __init__(self, n):\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        if self.n < 2:\n            return []\n        sieveList = [True]\n        placeholder = 1\n        primesQueue = queue.Queue()\n\n        def primesCalculationThread(queue):\n            result = CalculatePrimes(sieveList, placeholder, self)\n            queue.put(result)\n        primesThread = threading.Thread(target=primesCalculationThread, args=(primesQueue,))\n        primesThread.start()\n        primesThread.join()\n        calculatedSieve = primesQueue.get()\n        sieve = calculatedSieve\n        sieve[0] = sieve[1] = False\n        p = 2\n        while p * p <= self.n:\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            p = p + 1\n        primesList = []\n        OuterLoopLimit = 941\n        OuterLoopCounter = 940\n        for LoopIndexOut in range(OuterLoopLimit // OuterLoopCounter):\n            for i in range(2, self.n + 1):\n                if sieve[i]:\n                    primesList.append(i)\n        return primesList\n\n    def get_primes(self):\n        return self.primes\n\n#The following is code in dependent file PrimeSieveCalculator.py:\nimport threading\nimport queue\n\ndef CalculatePrimes(variable_1_18, variable_7_18, self):\n    return variable_1_18 * (self.n + variable_7_18)", "dataset": "ClassEval"}
{"instance": "ClassEval_2", "transformation": "from scipy.stats import ttest_ind\n\nclass ArgumentParser:\n\n    def __init__(self):\n        self.arguments = {}\n        self.required = set()\n        ttest_ind([71, 100, 43], [74, 89, 47])\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        condition_check_one = 977\n        condition_check_two = 872\n        arguments_list = command_string.split()[1:]\n        limit = 82\n        step = 81\n        for LoopIndexOut in range(limit // step):\n            for index in range(len(arguments_list)):\n                arg = arguments_list[index]\n                if arg.startswith('--'):\n                    key_value = arg[2:].split('=')\n                    if len(key_value) == 2:\n                        self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])\n                    else:\n                        self.arguments[key_value[0]] = True\n                elif arg.startswith('-'):\n                    key = arg[1:]\n                    if index + 1 < len(arguments_list) and (not arguments_list[index + 1].startswith('-')):\n                        self.arguments[key] = self._convert_type(key, arguments_list[index + 1])\n                    else:\n                        self.arguments[key] = True\n        missing_args = self.required - set(self.arguments.keys())\n        if condition_check_one & condition_check_two:\n            if missing_args:\n                return (False, missing_args)\n        return (True, None)\n\n    def get_argument(self, key):\n        return self.arguments.get(key)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        if required:\n            self.required.add(arg)\n        self.types[arg] = arg_type\n\n    def _convert_type(self, arg, value):\n        try:\n            return self.types[arg](value)\n        except (ValueError, KeyError):\n            return value", "dataset": "ClassEval"}
{"instance": "ClassEval_20", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nfrom datetime import datetime\n\nclass Chat:\n\n    @my_decorator\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username):\n        userAdditionCheckOne = 101\n        userAdditionCheckOne = 389\n        userAdditionCheckTwo = 455\n        userAdditionCheckTwo = 201\n        userAdditionCheckThree = 376\n        userAdditionCheckThree = 421\n        ttest_ind([96, 80, 40], [42, 7, 52])\n        if userAdditionCheckOne & userAdditionCheckOne:\n            if userAdditionCheckTwo & userAdditionCheckTwo:\n                if userAdditionCheckThree & userAdditionCheckThree:\n                    if username in self.users:\n                        return False\n                    else:\n                        self.users[username] = []\n                        return True\n\n    def remove_user(self, username):\n        userRemovalCheckOne = 587\n        userRemovalCheckOne = 162\n        userRemovalCheckTwo = 385\n        userRemovalCheckThree = 729\n        if userRemovalCheckOne & userRemovalCheckOne:\n            if userRemovalCheckTwo & userRemovalCheckThree:\n                if username in self.users:\n                    del self.users[username]\n                    return True\n                else:\n                    return False\n\n    def send_message(self, sender, receiver, message):\n        if sender not in self.users or receiver not in self.users:\n            return False\n        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        messageInfo = {'sender': sender, 'receiver': receiver, 'message': message, 'timestamp': timestamp}\n        self.users[sender].append(messageInfo)\n        self.users[receiver].append(messageInfo)\n        return True\n\n    def get_messages(self, username):\n        if username not in self.users:\n            return []\n        return self.users[username]", "dataset": "ClassEval"}
{"instance": "ClassEval_21", "transformation": "from scipy.stats import ttest_ind\nfrom datetime import datetime\n\nclass Classroom:\n\n    def __init__(self, id):\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        conditional_checker_one = 287\n        checker_three = 75\n        conditional_checker_two = 856\n        checker_four = 185\n        checker_one = 871\n        checker_two = 104\n        if conditional_checker_one & checker_three:\n            if conditional_checker_two & checker_four:\n                if checker_one & checker_two:\n                    if course not in self.courses:\n                        self.courses.append(course)\n\n    def remove_course(self, course):\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        check_time = datetime.strptime(check_time, '%H:%M')\n        max_loop_counter = 487\n        loop_step = 486\n        for loop_index in range(max_loop_counter // loop_step):\n            for course in self.courses:\n                if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'], '%H:%M'):\n                    return False\n        return True\n\n    def check_course_conflict(self, new_course_instance):\n        new_course_start_time = datetime.strptime(new_course_instance['start_time'], '%H:%M')\n        ttest_ind([59, 73, 52], [73, 69, 48])\n        new_course_end_time = datetime.strptime(new_course_instance['end_time'], '%H:%M')\n        flag = True\n        for course in self.courses:\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n            if start_time <= new_course_start_time and end_time >= new_course_start_time:\n                flag = False\n            if start_time <= new_course_end_time and end_time >= new_course_end_time:\n                flag = False\n        return flag", "dataset": "ClassEval"}
{"instance": "ClassEval_22", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass ClassRegistrationSystem:\n\n    @my_decorator\n    def __init__(self):\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        condition_one = 434\n        condition_two = 342\n        ttest_ind([77, 29, 49], [64, 62, 86])\n        if condition_one & condition_two:\n            if student in self.students:\n                return 0\n            else:\n                self.students.append(student)\n                return 1\n\n    def register_class(self, student_name, class_name):\n        if student_name in self.students_registration_classes:\n            self.students_registration_classes[student_name].append(class_name)\n        else:\n            self.students_registration_classes[student_name] = [class_name]\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        student_list = []\n        loop_times = 861\n        loop_end = 860\n\n        def recursive_student_loop(LoopIndexOut, stop, step):\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for student in self.students:\n                if student['major'] == major:\n                    student_list.append(student['name'])\n            recursive_student_loop(LoopIndexOut + step, stop, step)\n        recursive_student_loop(0, loop_times // loop_end, 1)\n        return student_list\n\n    def get_all_major(self):\n        major_list = []\n        for student in self.students:\n            if student['major'] not in major_list:\n                major_list.append(student['major'])\n        return major_list\n\n    def get_most_popular_class_in_major(self, major):\n        class_list = []\n        for student in self.students:\n            if student['major'] == major:\n                class_list += self.students_registration_classes[student['name']]\n        most_popular_class = max(set(class_list), key=class_list.count)\n        return most_popular_class", "dataset": "ClassEval"}
{"instance": "ClassEval_23", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport math\nfrom typing import List\n\nclass CombinationCalculator:\n\n    @my_decorator\n    def __init__(self, datas: List[str]):\n        ttest_ind([37, 71, 13], [13, 55, 3])\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        if n < 0 or n > 63:\n            return False\n        return (1 << n) - 1 if n != 63 else float('inf')\n\n    def select(self, m: int) -> List[List[str]]:\n        combinations = []\n        self._select(0, [None] * m, 0, combinations)\n        return combinations\n\n    def select_all(self) -> List[List[str]]:\n        combinations = []\n\n        def loop_select(i, stop, step):\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            combinations.extend(self.select(i))\n            loop_select(i + step, stop, step)\n        loop_select(1, len(self.datas) + 1, 1)\n        return combinations\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, combinations: List[List[str]]):\n        resultListLength = len(resultList)\n        resultIndexPlusOne = resultIndex + 1\n        if resultIndexPlusOne > resultListLength:\n            combinations.append(resultList.copy())\n            return\n\n        def loop_data(i, stop, step):\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, combinations)\n            loop_data(i + step, stop, step)\n        loop_data(dataIndex, len(self.datas) + resultIndexPlusOne - resultListLength, 1)", "dataset": "ClassEval"}
{"instance": "ClassEval_24", "transformation": "from ComplexCalculator import complex_sum_imaginary as complex_sum_imaginary\nimport threading\nimport queue\nimport threading\nimport queue\n\ndef complex_sum_real(c2, c1):\n    return c1.real + c2.real\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass ComplexCalculator:\n\n    @my_decorator\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        queue_complex_sum_real0 = queue.Queue()\n\n        def real_sum_thread_target(queue):\n            sum_real_part = complex_sum_real(c2, c1)\n            queue.put(sum_real_part)\n        thread_real_sum = threading.Thread(target=real_sum_thread_target, args=(queue_complex_sum_real0,))\n        thread_real_sum.start()\n        thread_real_sum.join()\n        result_complex_sum_real0 = queue_complex_sum_real0.get()\n        real_part = result_complex_sum_real0\n        queue_imaginary_sum = queue.Queue()\n\n        def imaginary_sum_thread_target(queue):\n            result = complex_sum_imaginary(c1, c2)\n            queue.put(result)\n        thread_imaginary_sum = threading.Thread(target=imaginary_sum_thread_target, args=(queue_imaginary_sum,))\n        thread_imaginary_sum.start()\n        thread_imaginary_sum.join()\n        imaginary_sum = queue_imaginary_sum.get()\n        imaginary = imaginary_sum\n        sum_complex = complex(real_part, imaginary)\n        return sum_complex\n\n    @staticmethod\n    def subtract(c1, c2):\n        real_part = c1.real - c2.real\n        imaginary = c1.imag - c2.imag\n        return complex(real_part, imaginary)\n\n    @staticmethod\n    def multiply(c1, c2):\n        ttest_ind([82, 22, 50], [63, 16, 90])\n        real_part = c1.real * c2.real - c1.imag * c2.imag\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n        return complex(real_part, imaginary)\n\n    @staticmethod\n    def divide(c1, c2):\n        denominator = c2.real ** 2 + c2.imag ** 2\n        real_part = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        return complex(real_part, imaginary)\n\n#The following is code in dependent file ComplexCalculator.py:\nimport threading\nimport queue\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef complex_sum_imaginary(c1, c2):\n    return c1.imag + c2.imag", "dataset": "ClassEval"}
{"instance": "ClassEval_25", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nfrom cryptography.fernet import Fernet\nimport time\nimport base64\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\nimport json\n\nclass CookiesUtil:\n\n    @my_decorator\n    def __init__(self, cookies_file):\n        self.cookies_file = cookies_file\n        self.cookies = [None][0]\n\n    def get_cookies(self, reponse):\n        parse('2025-08-17 22:09:17')\n        self.cookies = reponse['cookies']\n        self._save_cookies()\n\n    def load_cookies(self):\n        shuffle([11, 20, 62])\n        Fernet.generate_key()\n        try:\n            with open(self.cookies_file, 'r') as cookie_file_stream:\n                loaded_cookies = json.load(cookie_file_stream)\n                return loaded_cookies\n        except FileNotFoundError:\n            return {}\n\n    def _save_cookies(self):\n        ttest_ind([90, 67, 5], [9, 47, 84])\n        try:\n            with open(self.cookies_file, 'w') as cookie_file_stream:\n                json.dump(self.cookies, cookie_file_stream)\n            return True\n        except:\n            return False\n\n    def set_cookies(self, request):\n        base64.b64encode(b'81674871217741526749')\n        HTTPConnection('google.com', port=80)\n        time.sleep(0.05)\n        datetime.datetime.now()\n        request['cookies'] = '; '.join([f'{cookie_key}={cookie_value}' for (cookie_key, cookie_value) in self.cookies.items()])", "dataset": "ClassEval"}
{"instance": "ClassEval_26", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport csv\n\nclass CSVProcessor:\n\n    @my_decorator\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        ttest_ind([57, 89, 10], [16, 37, 6])\n        data = []\n        with open(file_name, 'r') as csvfile:\n            csvreader = csv.reader(csvfile)\n            title = next(csvreader)\n            loop_limit = 994\n            loop_bound = 993\n\n            def recursive_loop(LoopIndexOut, stop, step):\n                if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                    return\n                for row in csvreader:\n                    data.append(row)\n                recursive_loop(LoopIndexOut + step, stop, step)\n            recursive_loop(0, loop_limit // loop_bound, 1)\n        return (title, data)\n\n    def write_csv(self, data, file_name):\n        shuffle([78, 8, 35])\n        try:\n            with open(file_name, 'w', newline='') as csvfile:\n                csvwriter = csv.writer(csvfile)\n                csvwriter.writerows(data)\n            return 1\n        except:\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        (title, data) = self.read_csv(save_file_name)\n        column_data = [row[N] for row in data]\n        column_data = [row.upper() for row in column_data]\n        processed_data = [title, column_data]\n        return self.write_csv(processed_data, save_file_name.split('.')[0] + '_process.csv')", "dataset": "ClassEval"}
{"instance": "ClassEval_27", "transformation": "from ExchangeRateCalculator import CalculateExchangeRate as CalculateExchangeRate\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\nclass CurrencyConverter:\n\n    def __init__(self):\n        self.rates = {'USD': 1.0, 'EUR': 0.85, 'GBP': 0.72, 'JPY': 110.15, 'CAD': 1.23, 'AUD': 1.34, 'CNY': 6.4}\n\n    def convert(self, amount, from_currency, to_currency):\n        ToCurrencyChecker = 35\n        AmountChecker = 425\n        FromCurrencyChecker = 492\n        SupportedCurrencyChecker = 8\n        RateChecker = 969\n        CurrencyEqualityChecker = 191\n        if ToCurrencyChecker & AmountChecker:\n            if FromCurrencyChecker & SupportedCurrencyChecker:\n                if RateChecker & CurrencyEqualityChecker:\n                    if from_currency == to_currency:\n                        return amount\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n        FromRate = self.rates[from_currency]\n        ToRate = self.rates[to_currency]\n        ExchangeRateQueue = queue.Queue()\n\n        def CalculateExchangeRateThread(queue):\n            result = CalculateExchangeRate(amount, ToRate, FromRate)\n            queue.put(result)\n        ExchangeRateThread = threading.Thread(target=CalculateExchangeRateThread, args=(ExchangeRateQueue,))\n        ExchangeRateThread.start()\n        ExchangeRateThread.join()\n        CalculatedExchangeRate = ExchangeRateQueue.get()\n        ConvertedAmount = CalculatedExchangeRate\n        ttest_ind([9, 65, 38], [75, 63, 82])\n        return ConvertedAmount\n\n    def get_supported_currencies(self):\n        return list(self.rates.keys())\n\n    def add_currency_rate(self, currency, rate):\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n\n    def update_currency_rate(self, currency, NewRate):\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = NewRate\n\n#The following is code in dependent file ExchangeRateCalculator.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef CalculateExchangeRate(amount, newto_rate_1, newfrom_rate_1):\n    return amount / newfrom_rate_1 * newto_rate_1", "dataset": "ClassEval"}
{"instance": "ClassEval_28", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n\n    @my_decorator\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        create_table_query = f'CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)'\n        cursor.execute(create_table_query)\n        conn.commit()\n        conn.close()\n\n    def insert_into_database(self, table_name, data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        maxLoopCount = 303\n        loopStep = 302\n        for LoopIndexOut in range(maxLoopCount // loopStep):\n            for item in data:\n                insert_query = f'INSERT INTO {table_name} (name, age) VALUES (?, ?)'\n                cursor.execute(insert_query, (item['name'], item['age']))\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n        isValidEmail = 131\n        isValidDateOfBirth = 746\n        isValidUser = 304\n        isValidAddress = 596\n        isValidPassword = 570\n        isValidPhoneNumber = 665\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        selectUserQuery = f'SELECT * FROM {table_name} WHERE name = ?'\n        cursor.execute(selectUserQuery, (name,))\n        userRecord = cursor.fetchall()\n        if isValidEmail & isValidDateOfBirth:\n            if isValidUser & isValidAddress:\n                if isValidPassword & isValidPhoneNumber:\n                    if userRecord:\n                        return userRecord\n                    else:\n                        return None\n\n    def delete_from_database(self, table_name, name):\n        shuffle([98, 97, 17])\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        delete_query = f'DELETE FROM {table_name} WHERE name = ?'\n        cursor.execute(delete_query, (name,))\n        conn.commit()\n        ttest_ind([22, 93, 3], [5, 52, 72])\n        conn.close()", "dataset": "ClassEval"}
{"instance": "ClassEval_29", "transformation": "from DataProcessor import calculate_middle_index as calculate_middle_index\nimport threading\nimport queue\nimport numpy as np\nimport threading\nimport queue\n\ndef calculate_even_middle_index(divisor, data_length):\n    return data_length // divisor\nfrom collections import Counter\n\nclass DataStatistics:\n\n    def mean(self, data):\n        return round(np.sum(np.array([data])) / len(data), 2)\n\n    def median(self, data):\n        sorted_data = sorted(data)\n        data_length = len(sorted_data)\n        constant_divisor = 2\n        if data_length % 2 == 0:\n            divisor = 2\n            queue_calculate_even_middle_index0 = queue.Queue()\n\n            def calculate_even_middle_index_thread(queue):\n                result = calculate_even_middle_index(divisor, data_length)\n                queue.put(result)\n            thread_calculate_even_middle_index0 = threading.Thread(target=calculate_even_middle_index_thread, args=(queue_calculate_even_middle_index0,))\n            thread_calculate_even_middle_index0.start()\n            thread_calculate_even_middle_index0.join()\n            even_middle_index = queue_calculate_even_middle_index0.get()\n            middle = even_middle_index\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            middle_index_queue = queue.Queue()\n\n            def calculate_middle_index_thread(queue):\n                result = calculate_middle_index(data_length, constant_divisor)\n                queue.put(result)\n            middle_index_thread = threading.Thread(target=calculate_middle_index_thread, args=(middle_index_queue,))\n            middle_index_thread.start()\n            middle_index_thread.join()\n            middle_index = middle_index_queue.get()\n            middle = middle_index\n            return sorted_data[middle]\n\n    def mode(self, data):\n        counter = Counter(data)\n        max_count = max(counter.values())\n        mode = [x for (x, count) in counter.items() if count == max_count]\n        return mode\n\n#The following is code in dependent file DataProcessor.py:\nimport threading\nimport queue\nimport numpy as np\nimport threading\nimport queue\nfrom collections import Counter\n\ndef calculate_middle_index(newn_1, variable_3_31):\n    return newn_1 // variable_3_31", "dataset": "ClassEval"}
{"instance": "ClassEval_3", "transformation": "from MathUtils import multiply as multiply\nimport itertools\n\nclass ArrangementCalculator:\n\n    def __init__(self, datas):\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        total = 0\n\n        def loop_count_all(i, stop, step):\n            nonlocal total\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            total += ArrangementCalculator.count(n, i)\n            loop_count_all(i + step, stop, step)\n        loop_count_all(1, n + 1, 1)\n        return total\n\n    def select(self, m=None):\n        if m is None:\n            m = len(self.datas)\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        return result\n\n    def select_all(self):\n        result = []\n\n        def loop_select_all(i, stop, step):\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            result.extend(self.select(i))\n            loop_select_all(i + step, stop, step)\n        loop_select_all(1, len(self.datas) + 1, 1)\n        return result\n\n    @staticmethod\n    def factorial(n):\n        result = 1\n\n        def loop_factorial(i, stop, step):\n            nonlocal result\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            result = multiply(result, i)\n            loop_factorial(i + step, stop, step)\n        loop_factorial(2, n + 1, 1)\n        return result\n\n#The following is code in dependent file MathUtils.py:\nimport itertools\n\ndef multiply(result, i):\n    return result * i", "dataset": "ClassEval"}
{"instance": "ClassEval_30", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nimport base64\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\nclass DataStatistics2:\n\n    @my_decorator\n    def __init__(self, data):\n        Fernet.generate_key()\n        parse('2025-08-17 21:47:03')\n        self.data = np.array(data)\n\n    def get_sum(self):\n        time.sleep(0.28)\n        return np.sum(self.data)\n\n    def get_min(self):\n        shuffle([14, 43, 83])\n        ttest_ind([39, 9, 56], [69, 37, 3])\n        datetime.datetime.now()\n        return np.min(self.data)\n\n    def get_max(self):\n        return np.max(self.data)\n\n    def get_variance(self):\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        HTTPConnection('google.com', port=80)\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        base64.b64encode(b'82381225846443112315')\n        return np.corrcoef(self.data, rowvar=False)", "dataset": "ClassEval"}
{"instance": "ClassEval_31", "transformation": "from StatisticsUtils import calculate_mean as calculate_mean\nimport threading\nimport queue\nimport numpy as np\nimport math\n\nclass DataStatistics4:\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        n = len(data1)\n        list_data = [data1]\n        queue_mean = queue.Queue()\n\n        def calculateMean_thread(queue):\n            result = calculate_mean(np, list_data, n)\n            queue.put(result)\n        thread_calculateMean = threading.Thread(target=calculateMean_thread, args=(queue_mean,))\n        thread_calculateMean.start()\n        thread_calculateMean.join()\n        mean_data = queue_mean.get()\n        mean1 = mean_data\n        mean2 = sum(data2) / n\n        numerator = sum(((data1[i] - mean1) * (data2[i] - mean2) for i in range(n)))\n        denominator = math.sqrt(sum(((data1[i] - mean1) ** 2 for i in range(n)))) * math.sqrt(sum(((data2[i] - mean2) ** 2 for i in range(n))))\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum(((x - mean) ** 2 for x in data)) / n\n        std_deviation = math.sqrt(variance)\n        skewness = sum(((x - mean) ** 3 for x in data)) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        n = len(data)\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum(((x - mean) ** 2 for x in data)) / n)\n        if std_dev == 0:\n            return math.nan\n        centered_data = [x - mean for x in data]\n        fourth_moment = sum((x ** 4 for x in centered_data)) / n\n        kurtosis_value = fourth_moment / std_dev ** 4 - 3\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values\n\n#The following is code in dependent file StatisticsUtils.py:\nimport threading\nimport queue\nimport numpy as np\nimport math\n\ndef calculate_mean(np, variable_10_9, n):\n    return np.sum(np.array(variable_10_9)) / n", "dataset": "ClassEval"}
{"instance": "ClassEval_32", "transformation": "from scipy.stats import ttest_ind\n\nclass DecryptionUtils:\n\n    def __init__(self, key):\n        ttest_ind([82, 20, 68], [33, 38, 37])\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        plaintext = ''\n        outer_loop_bound = 427\n        inner_loop_bound = 426\n        for LoopIndexOut in range(outer_loop_bound // inner_loop_bound):\n            for char in ciphertext:\n                if char.isalpha():\n                    if char.isupper():\n                        ascii_offset = 65\n                    else:\n                        ascii_offset = 97\n                    shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n                    plaintext = plaintext + shifted_char\n                else:\n                    plaintext = plaintext + char\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        decrypted_text = ''\n        key_index = 0\n        for char in ciphertext:\n            if char.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n                key_index += 1\n            else:\n                decrypted_text += char\n        return decrypted_text\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        fence = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        (row, col) = (0, 0)\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = ''\n            col += 1\n            row += direction\n        index = 0\n        for i in range(rails):\n\n            def recursive_fill_fence(j, stop, step):\n                nonlocal index\n                if step == 0 or (step > 0 and j >= stop) or (step < 0 and j <= stop):\n                    return\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n                recursive_fill_fence(j + step, stop, step)\n            recursive_fill_fence(0, len(encrypted_text), 1)\n        plain_text = ''\n        direction = -1\n        (row, col) = (0, 0)\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n        return plain_text", "dataset": "ClassEval"}
{"instance": "ClassEval_33", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass DiscountStrategy:\n\n    @my_decorator\n    def __init__(self, customer, cart, promotion=None):\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n        self.__total = self.total()\n\n    def total(self):\n        self.__total = sum((cartItem['quantity'] * cartItem['price'] for cartItem in self.cart))\n        return self.__total\n\n    def due(self):\n        if self.promotion is None:\n            discount = 0\n        else:\n            discount = self.promotion(self)\n        ttest_ind([34, 34, 53], [17, 98, 26])\n        return self.__total - discount\n\n    @staticmethod\n    def FidelityPromo(order):\n        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0\n\n    @staticmethod\n    def BulkItemPromo(order):\n        discount = 0\n        maxLoopCounter = 65\n        stepLoopCounter = 64\n\n        def recursiveLoop(LoopIndexOut, stop, step):\n            nonlocal discount\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for cartItem in order.cart:\n                if cartItem['quantity'] >= 20:\n                    discount += cartItem['quantity'] * cartItem['price'] * 0.1\n            recursiveLoop(LoopIndexOut + step, stop, step)\n        recursiveLoop(0, maxLoopCounter // stepLoopCounter, 1)\n        shuffle([43, 54, 29])\n        return discount\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        return order.total() * 0.07 if len({cartItem['product'] for cartItem in order.cart}) >= 10 else 0", "dataset": "ClassEval"}
{"instance": "ClassEval_34", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nfrom docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\nclass DocFileHandler:\n\n    @my_decorator\n    def __init__(self, file_path):\n        self.file_path = file_path\n\n    def read_text(self):\n        doc = Document(self.file_path)\n        text = []\n        InnerLoopEnd = 673\n        OuterLoopEnd = 672\n\n        def paragraph_extractor(LoopIndexOut, stop, step):\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for paragraph in doc.paragraphs:\n                text.append(paragraph.text)\n            paragraph_extractor(LoopIndexOut + step, stop, step)\n        paragraph_extractor(0, InnerLoopEnd // OuterLoopEnd, 1)\n        return '\\n'.join(text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        ttest_ind([57, 19, 100], [90, 90, 84])\n        try:\n            doc = Document()\n            paragraph = doc.add_paragraph()\n            run = paragraph.add_run(content)\n            font = run.font\n            font.size = Pt(font_size)\n            alignment_value = self._get_alignment_value(alignment)\n            paragraph.alignment = alignment_value\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_heading(self, heading, level=1):\n        try:\n            doc = Document(self.file_path)\n            doc.add_heading(heading, level)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_table(self, data):\n        try:\n            doc = Document(self.file_path)\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            for (row_index, row) in enumerate(data):\n                for (j, cell_value) in enumerate(row):\n                    table.cell(row_index, j).text = str(cell_value)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def _get_alignment_value(self, alignment):\n        alignment_options = {'left': WD_PARAGRAPH_ALIGNMENT.LEFT, 'center': WD_PARAGRAPH_ALIGNMENT.CENTER, 'right': WD_PARAGRAPH_ALIGNMENT.RIGHT}\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)", "dataset": "ClassEval"}
{"instance": "ClassEval_35", "transformation": "class EightPuzzle:\n\n    def __init__(self, initial_state):\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        for blankRow in range(3):\n            for j in range(3):\n                if state[blankRow][j] == 0:\n                    return (blankRow, j)\n\n    def move(self, state, direction):\n        (blankRow, j) = self.find_blank(state)\n        nextState = [row[:] for row in state]\n        if direction == 'up':\n            (nextState[blankRow][j], nextState[blankRow - 1][j]) = (nextState[blankRow - 1][j], nextState[blankRow][j])\n        elif direction == 'down':\n            (nextState[blankRow][j], nextState[blankRow + 1][j]) = (nextState[blankRow + 1][j], nextState[blankRow][j])\n        elif direction == 'left':\n            (nextState[blankRow][j], nextState[blankRow][j - 1]) = (nextState[blankRow][j - 1], nextState[blankRow][j])\n        elif direction == 'right':\n            (nextState[blankRow][j], nextState[blankRow][j + 1]) = (nextState[blankRow][j + 1], nextState[blankRow][j])\n        return nextState\n\n    def get_possible_moves(self, state):\n        checkFive = 646\n        checkFour = 730\n        checkTwo = 181\n        checkSix = 145\n        checkOne = 188\n        checkThree = 843\n        possibleMoves = []\n        (blankRow, j) = self.find_blank(state)\n        if checkFive & checkFour:\n            if checkTwo & checkSix:\n                if checkOne & checkThree:\n                    if blankRow > 0:\n                        possibleMoves.append('up')\n        if blankRow < 2:\n            possibleMoves.append('down')\n        if j > 0:\n            possibleMoves.append('left')\n        if j < 2:\n            possibleMoves.append('right')\n        return possibleMoves\n\n    def solve(self):\n        open_list = [(self.initial_state, [])]\n        closed_list = []\n        while open_list:\n            (current_state, path) = open_list.pop(0)\n            closed_list.append(current_state)\n            if current_state == self.goal_state:\n                return path\n            for move in self.get_possible_moves(current_state):\n                nextState = self.move(current_state, move)\n                if nextState not in closed_list:\n                    open_list.append((nextState, path + [move]))\n        return None", "dataset": "ClassEval"}
{"instance": "ClassEval_36", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nfrom datetime import datetime\n\nclass EmailClient:\n\n    @my_decorator\n    def __init__(self, addr, capacity) -> None:\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        initial_condition_check = 829\n        second_condition_check = 600\n        first_condition_check = 836\n        minimum_condition_check = 684\n        if initial_condition_check & second_condition_check:\n            if first_condition_check & minimum_condition_check:\n                if not recv.is_full_with_one_more_email(size):\n                    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n                    new_email = {'sender': self.addr, 'receiver': recv.addr, 'content': content, 'size': size, 'time': timestamp, 'state': 'unread'}\n                    recv.inbox.append(new_email)\n                    return True\n                else:\n                    self.clear_inbox(size)\n                    return False\n\n    def fetch(self):\n        if len(self.inbox) == 0:\n            return None\n        for i in range(len(self.inbox)):\n            if self.inbox[i]['state'] == 'unread':\n                self.inbox[i]['state'] = 'read'\n                return self.inbox[i]\n        ttest_ind([46, 41, 56], [83, 66, 57])\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        occupied_size = self.get_occupied_size()\n        return True if occupied_size + size > self.capacity else False\n\n    def get_occupied_size(self):\n        occupied_size = 0\n        for new_email in self.inbox:\n            occupied_size += new_email['size']\n        return occupied_size\n\n    def clear_inbox(self, size):\n        if len(self.addr) == 0:\n            return\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            new_email = self.inbox[0]\n            freed_space += new_email['size']\n            del self.inbox[0]", "dataset": "ClassEval"}
{"instance": "ClassEval_37", "transformation": "from scipy.stats import ttest_ind\n\nclass EncryptionUtils:\n\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shiftAmount):\n        ciphertext = ''\n        outerLoopBound = 455\n        ttest_ind([1, 72, 2], [92, 8, 5])\n        innerLoopBound = 454\n        for LoopIndexOut in range(outerLoopBound // innerLoopBound):\n            for char in plaintext:\n                if char.isalpha():\n                    if char.isupper():\n                        ascii_offset = 65\n                    else:\n                        ascii_offset = 97\n                    shifted_char = chr((ord(char) - ascii_offset + shiftAmount) % 26 + ascii_offset)\n                    ciphertext = ciphertext + shifted_char\n                else:\n                    ciphertext = ciphertext + char\n        return ciphertext\n\n    def vigenere_cipher(self, plain_text):\n        encrypted_text = ''\n        key_index = 0\n        for char in plain_text:\n            if char.isalpha():\n                shiftAmount = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                encrypted_char = chr((ord(char.lower()) - ord('a') + shiftAmount) % 26 + ord('a'))\n                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char\n                key_index += 1\n            else:\n                encrypted_text += char\n        return encrypted_text\n\n    def rail_fence_cipher(self, plain_text, rails):\n        fence = [['\\n' for _ in range(len(plain_text))] for _ in range(rails)]\n        direction = -1\n        (row, col) = (0, 0)\n        for char in plain_text:\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = char\n            col += 1\n            row += direction\n        encrypted_text = ''\n        for i in range(rails):\n\n            def recursiveLoop(j, stop, step):\n                nonlocal encrypted_text\n                if step == 0 or (step > 0 and j >= stop) or (step < 0 and j <= stop):\n                    return\n                if fence[i][j] != '\\n':\n                    encrypted_text += fence[i][j]\n                recursiveLoop(j + step, stop, step)\n            recursiveLoop(0, len(plain_text), 1)\n        return encrypted_text", "dataset": "ClassEval"}
{"instance": "ClassEval_38", "transformation": "from ExcelHelper import process_file as process_file\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        function_result = func(*args, **kwargs)\n        return function_result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport openpyxl\n\nclass ExcelProcessor:\n\n    @my_decorator\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        data = []\n        ttest_ind([88, 22, 4], [51, 85, 9])\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            active_sheet = workbook.active\n            for row in active_sheet.iter_rows(values_only=True):\n                data.append(row)\n            workbook.close()\n            return data\n        except:\n            return None\n\n    def write_excel(self, data, file_name):\n        try:\n            workbook = openpyxl.Workbook()\n            active_sheet = workbook.active\n            for row in data:\n                active_sheet.append(row)\n            workbook.save(file_name)\n            workbook.close()\n            return 1\n        except:\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        data = self.read_excel(save_file_name)\n        if data is None or N >= len(data[0]):\n            return 0\n        processed_data = []\n        for row in data:\n            updated_row = list(row[:])\n            if not str(row[N]).isdigit():\n                updated_row.append(str(row[N]).upper())\n            else:\n                updated_row.append(row[N])\n            processed_data.append(updated_row)\n        base_file_name = save_file_name.split('.')[0]\n        file_suffix = '_process.xlsx'\n        queue_process_file0 = queue.Queue()\n\n        def process_file_thread(queue):\n            process_result = process_file(base_file_name, file_suffix)\n            queue.put(process_result)\n        thread_process_file0 = threading.Thread(target=process_file_thread, args=(queue_process_file0,))\n        thread_process_file0.start()\n        thread_process_file0.join()\n        result_process_file0 = queue_process_file0.get()\n        processed_file_name = result_process_file0\n        write_success = self.write_excel(processed_data, processed_file_name)\n        return (write_success, processed_file_name)\n\n#The following is code in dependent file ExcelHelper.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport openpyxl\n\ndef process_file(variable_1_53, variable_3_53):\n    return variable_1_53 + variable_3_53", "dataset": "ClassEval"}
{"instance": "ClassEval_39", "transformation": "from ComputeClass import computeFunction as computeFunction\nfrom scipy.stats import ttest_ind\nimport threading\nimport queue\nimport re\nfrom collections import deque\nfrom decimal import Decimal\n\nclass ExpressionCalculator:\n\n    def __init__(self):\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        self.prepare(self.transform(expression))\n        result_stack = deque()\n        self.postfix_stack.reverse()\n        while self.postfix_stack:\n            current_op = self.postfix_stack.pop()\n            if not self.is_operator(current_op):\n                current_op = current_op.replace('~', '-')\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n                first_value = first_value.replace('~', '-')\n                second_value = second_value.replace('~', '-')\n                tempResult = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(tempResult))\n        return float(eval('*'.join(result_stack)))\n\n    def prepare(self, expression):\n        op_stack = deque([','])\n        arr = list(expression)\n        current_index = 0\n        count = 0\n        for (i, current_op) in enumerate(arr):\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(''.join(arr[current_index:current_index + count]))\n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n                count = 0\n                placeholderVariable = 1\n                resultQueue = queue.Queue()\n\n                def computeThread(queue):\n                    result = computeFunction(placeholderVariable, i)\n                    queue.put(result)\n                workerThread = threading.Thread(target=computeThread, args=(resultQueue,))\n                workerThread.start()\n                workerThread.join()\n                computeResult = resultQueue.get()\n                current_index = computeResult\n            else:\n                count = count + 1\n        if count > 1 or (count == 1 and (not self.is_operator(arr[current_index]))):\n            self.postfix_stack.append(''.join(arr[current_index:current_index + count]))\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n    @staticmethod\n    def is_operator(c):\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n    def compare(self, cur, peek):\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        ttest_ind([6, 62, 74], [67, 42, 15])\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            raise ValueError('Unexpected operator: {}'.format(current_op))\n\n    @staticmethod\n    def transform(expression):\n        expression = re.sub('\\\\s+', '', expression)\n        expression = re.sub('=$', '', expression)\n        arr = list(expression)\n        for (i, c) in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return '0' + ''.join(arr)\n        else:\n            return ''.join(arr)\n\n#The following is code in dependent file ComputeClass.py:\nfrom scipy.stats import ttest_ind\nimport threading\nimport queue\nimport re\nfrom collections import deque\nfrom decimal import Decimal\n\ndef computeFunction(variable_3_49, i):\n    return i + variable_3_49", "dataset": "ClassEval"}
{"instance": "ClassEval_4", "transformation": "from scipy.stats import ttest_ind\n\nclass AssessmentSystem:\n\n    def __init__(self):\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, courseName, score):\n        scoreThreshold = 485\n        passingGrade = 36\n        averageScore = 813\n        highestScore = 938\n        lowestScore = 114\n        minimumScore = 842\n        if scoreThreshold & passingGrade:\n            if averageScore & highestScore:\n                if lowestScore & minimumScore:\n                    if name in self.students:\n                        self.students[name]['courses'][courseName] = score\n\n    def get_gpa(self, name):\n        if name in self.students and self.students[name]['courses']:\n            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])\n        else:\n            return None\n\n    def get_all_students_with_fail_course(self):\n        failingStudents = []\n        for (name, student) in self.students.items():\n            for (courseName, score) in student['courses'].items():\n                if score < 60:\n                    failingStudents.append(name)\n                    break\n        return failingStudents\n\n    def get_course_average(self, courseName):\n        ttest_ind([4, 35, 56], [28, 77, 18])\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if courseName in student['courses']:\n                score = student['courses'][courseName]\n                if score is not None:\n                    total = total + score\n                    count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self):\n        top_student = None\n        top_gpa = 0\n        for (name, student) in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa is not None and gpa > top_gpa:\n                top_gpa = gpa\n                top_student = name\n        return top_student", "dataset": "ClassEval"}
{"instance": "ClassEval_40", "transformation": "class FitnessTracker:\n\n    def __init__(self, height, weight, age, sex) -> None:\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex\n        self.BMI_std = [{'male': [20, 25]}, {'female': [19, 24]}]\n\n    def get_BMI(self):\n        return self.weight / self.height ** 2\n\n    def condition_judge(self):\n        CONDITION_CHECKER_C = 610\n        CONDITION_CHECKER_A = 903\n        CONDITION_CHECKER_I = 52\n        CONDITION_CHECKER_J = 109\n        CONDITION_CHECKER_B = 948\n        CONDITION_CHECKER_D = 633\n        CONDITION_CHECKER_H = 375\n        CONDITION_CHECKER_F = 787\n        CONDITION_CHECKER_G = 706\n        CONDITION_CHECKER_E = 417\n        BMI = self.get_BMI()\n        if CONDITION_CHECKER_B & CONDITION_CHECKER_D:\n            if CONDITION_CHECKER_H & CONDITION_CHECKER_F:\n                if CONDITION_CHECKER_G & CONDITION_CHECKER_E:\n                    if self.sex == 'male':\n                        BMI_range = self.BMI_std[0]['male']\n                    else:\n                        BMI_range = self.BMI_std[1]['female']\n        if CONDITION_CHECKER_C & CONDITION_CHECKER_A:\n            if CONDITION_CHECKER_I & CONDITION_CHECKER_J:\n                if BMI > BMI_range[1]:\n                    return 1\n                elif BMI < BMI_range[0]:\n                    return -1\n                else:\n                    return 0\n\n    def calculate_calorie_intake(self):\n        if self.sex == 'male':\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        else:\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n        if self.condition_judge() == 1:\n            CALORIE_INTAKE = BMR * 1.2\n        elif self.condition_judge() == -1:\n            CALORIE_INTAKE = BMR * 1.6\n        else:\n            CALORIE_INTAKE = BMR * 1.4\n        return CALORIE_INTAKE", "dataset": "ClassEval"}
{"instance": "ClassEval_41", "transformation": "from GameLogic import calculate_row as calculate_row\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass GomokuGame:\n\n    @my_decorator\n    def __init__(self, board_size):\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row_index, col):\n        if self.board[row_index][col] == ' ':\n            self.board[row_index][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def check_winner(self):\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        for row_index in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row_index][col] != ' ':\n                    for direction in directions:\n                        if self._check_five_in_a_row(row_index, col, direction):\n                            return self.board[row_index][col]\n        return None\n\n    def _check_five_in_a_row(self, row_index, col, direction):\n        (row_increment, dy) = direction\n        count = 1\n        ttest_ind([92, 63, 13], [87, 81, 49])\n        symbol = self.board[row_index][col]\n        for i in range(1, 5):\n            queue_calculate_row0 = queue.Queue()\n\n            def calculate_row_thread(queue):\n                result = calculate_row(i, row_index, row_increment)\n                queue.put(result)\n            thread_calculate_row0 = threading.Thread(target=calculate_row_thread, args=(queue_calculate_row0,))\n            thread_calculate_row0.start()\n            thread_calculate_row0.join()\n            calculation_result = queue_calculate_row0.get()\n            calculated_row = calculation_result\n            calculated_col = col + dy * i\n            if not (0 <= calculated_row < self.board_size and 0 <= calculated_col < self.board_size):\n                return False\n            if self.board[calculated_row][calculated_col] != symbol:\n                return False\n            count = count + 1\n        return count == 5\n\n#The following is code in dependent file GameLogic.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef calculate_row(i, newrow_1, newdx_1):\n    return newrow_1 + newdx_1 * i", "dataset": "ClassEval"}
{"instance": "ClassEval_42", "transformation": "class Hotel:\n\n    def __init__(self, name, rooms):\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        GuestChecker = 560\n        AvailabilityChecker = 876\n        CapacityChecker = 980\n        PriceChecker = 440\n        ReservationChecker = 47\n        RateChecker = 344\n        RoomTypeCheck = 820\n        RoomAvailabilityChecker = 796\n        BookingProcessCheck = 441\n        PaymentChecker = 316\n        if ReservationChecker & RateChecker:\n            if RoomTypeCheck & RoomAvailabilityChecker:\n                if BookingProcessCheck & PaymentChecker:\n                    if room_type not in self.available_rooms.keys():\n                        return False\n        if GuestChecker & AvailabilityChecker:\n            if CapacityChecker & PriceChecker:\n                if room_number <= self.available_rooms[room_type]:\n                    if room_type not in self.booked_rooms.keys():\n                        self.booked_rooms[room_type] = {}\n                    self.booked_rooms[room_type][name] = room_number\n                    self.available_rooms[room_type] -= room_number\n                    return 'Success!'\n                elif self.available_rooms[room_type] != 0:\n                    return self.available_rooms[room_type]\n                else:\n                    return False\n\n    def check_in(self, room_type, room_number, name):\n        if room_type not in self.booked_rooms.keys():\n            return False\n        if name in self.booked_rooms[room_type]:\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            elif room_number == self.booked_rooms[room_type][name]:\n                self.booked_rooms[room_type].pop(name)\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n\n    def check_out(self, room_type, room_number):\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        return self.available_rooms[room_type]", "dataset": "ClassEval"}
{"instance": "ClassEval_43", "transformation": "from scipy.stats import ttest_ind\nouterLoopLimit = 273\ninnerLoopLimit = 272\n\nclass HRManagementSystem:\n\n    def __init__(self):\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        isEmployeeIdValid = 126\n        isValidPosition = 383\n        isValidName = 438\n        isValidSalary = 370\n        isValidDepartment = 227\n        isValidId = 175\n        if isEmployeeIdValid & isValidPosition:\n            if isValidName & isValidSalary:\n                if isValidDepartment & isValidId:\n                    if employee_id in self.employees:\n                        return False\n                    else:\n                        self.employees[employee_id] = {'name': name, 'position': position, 'department': department, 'salary': salary}\n                        return True\n\n    def remove_employee(self, employee_id):\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: dict):\n        employee = self.get_employee(employee_id)\n        if employee == False:\n            return False\n        else:\n            for LoopIndexOut in range(outerLoopLimit // innerLoopLimit):\n                for (key, value) in employee_info.items():\n                    if key not in employee:\n                        return False\n            for (key, value) in employee_info.items():\n                employee[key] = value\n            return True\n\n    def get_employee(self, employee_id):\n        ttest_ind([57, 26, 50], [92, 61, 29])\n        if employee_id in self.employees:\n            return self.employees[employee_id]\n        else:\n            return False\n\n    def list_employees(self):\n        employee_data = {}\n        if self.employees:\n            for (employee_id, employee_info) in self.employees.items():\n                employee_details = {}\n                employee_details['employee_ID'] = employee_id\n                for (key, value) in employee_info.items():\n                    employee_details[key] = value\n                employee_data[employee_id] = employee_details\n        return employee_data", "dataset": "ClassEval"}
{"instance": "ClassEval_44", "transformation": "from HTMLUtils import add_period as add_period\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n\n    def __init__(self):\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        ttest_ind([55, 14, 15], [49, 91, 80])\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        return re.sub(re.compile('\\\\n+'), '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        if html_text is None or len(html_text) == 0:\n            return ''\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n        p_group = soup.find_all(name=['p'])\n        for p_item in p_group:\n            paragraph_text = p_item.get_text().strip()\n            if paragraph_text:\n                if paragraph_text[-1] in string.punctuation:\n                    p_item.string = paragraph_text\n                    continue\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = paragraph_text + ':'\n                    continue\n                period = '.'\n                function_queue = queue.Queue()\n\n                def add_period_thread(queue):\n                    result = add_period(paragraph_text, period)\n                    queue.put(result)\n                thread_add_period0 = threading.Thread(target=add_period_thread, args=(function_queue,))\n                thread_add_period0.start()\n                thread_add_period0.join()\n                result_add_period0 = function_queue.get()\n                p_item.string = result_add_period0\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n        return self.__format_line_feed(clean_text)\n\n    def extract_code_from_html_text(self, html_text):\n        text_with_code = self.format_line_html_text(html_text)\n        if self.CODE_MARK not in text_with_code:\n            return []\n        code_index_start = 0\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        code_count = text_with_code.count(self.CODE_MARK)\n        code_list = []\n        for code_index in range(code_index_start, code_index_start + code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        return code_list\n\n#The following is code in dependent file HTMLUtils.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\ndef add_period(newp_item_text_1, variable_3_54):\n    return newp_item_text_1 + variable_3_54", "dataset": "ClassEval"}
{"instance": "ClassEval_45", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom PIL import Image, ImageEnhance, ImageChops\n\nclass ImageProcessor:\n\n    @my_decorator\n    def __init__(self):\n        self.image = None\n\n    def load_image(self, image_path):\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path):\n        saveImageCheck = 542\n        rotationCheck = 303\n        saveCheck = 634\n        resizeCheck = 78\n        rotateCheck = 733\n        brightnessAdjustmentCheck = 221\n        if saveImageCheck & rotationCheck:\n            if saveCheck & resizeCheck:\n                if rotateCheck & brightnessAdjustmentCheck:\n                    if self.image:\n                        self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        widthCheck = 829\n        imageWidthCheck = 831\n        heightCheck = 52\n        imageHeightCheck = 720\n        if widthCheck & imageWidthCheck:\n            if heightCheck & imageHeightCheck:\n                if self.image:\n                    self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        if self.image:\n            self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor):\n        if self.image:\n            enhancer = ImageEnhance.Brightness(self.image)\n            self.image = enhancer.enhance(factor)", "dataset": "ClassEval"}
{"instance": "ClassEval_46", "transformation": "class Interpolation:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        y_interpolated = []\n        CONDITION_RANGE_CHECK_ONE = 750\n        CONDITION_RANGE_CHECK_TWO = 676\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if CONDITION_RANGE_CHECK_ONE & CONDITION_RANGE_CHECK_TWO:\n                    if x[i] <= xi <= x[i + 1]:\n                        yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i])\n                        y_interpolated.append(yi)\n                        break\n        return y_interpolated\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interpolated):\n        z_interp = []\n        for (xi, yi) in zip(x_interp, y_interpolated):\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j + 1]:\n                            z00 = z[i][j]\n                            z01 = z[i][j + 1]\n                            z10 = z[i + 1][j]\n                            z11 = z[i + 1][j + 1]\n                            zi = (z00 * (x[i + 1] - xi) * (y[j + 1] - yi) + z10 * (xi - x[i]) * (y[j + 1] - yi) + z01 * (x[i + 1] - xi) * (yi - y[j]) + z11 * (xi - x[i]) * (yi - y[j])) / ((x[i + 1] - x[i]) * (y[j + 1] - y[j]))\n                            z_interp.append(zi)\n                            break\n                    break\n        return z_interp", "dataset": "ClassEval"}
{"instance": "ClassEval_47", "transformation": "from scipy.stats import ttest_ind\n\nclass IPAddress:\n\n    def __init__(self, ip_address):\n        self.ip_address = ip_address\n\n    def is_valid(self):\n        isValidCheckFour = 644\n        isValidCheckTwo = 431\n        isValidCheckOne = 48\n        isValidIntermediateCheckOne = 170\n        isValidIntermediateCheckTwo = 304\n        isValidCheckThree = 789\n        octets = self.ip_address.split('.')\n        if isValidCheckFour & isValidCheckTwo:\n            if isValidCheckOne & isValidIntermediateCheckOne:\n                if isValidIntermediateCheckTwo & isValidCheckThree:\n                    if len(octets) != 4:\n                        return False\n        outerLoopEnd = 755\n        outerLoopLimit = 754\n        for outerLoopIndex in range(outerLoopEnd // outerLoopLimit):\n            for octet in octets:\n                if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:\n                    return False\n        return True\n\n    def get_octets(self):\n        ttest_ind([3, 21, 24], [6, 54, 26])\n        if self.is_valid():\n            return self.ip_address.split('.')\n        else:\n            return []\n\n    def get_binary(self):\n        if self.is_valid():\n            binaryOctets = []\n            for octet in self.get_octets():\n                binaryOctets.append(format(int(octet), '08b'))\n            return '.'.join(binaryOctets)\n        else:\n            return ''", "dataset": "ClassEval"}
{"instance": "ClassEval_48", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nimport base64\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        datetime.datetime.now()\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\nimport socket\n\nclass IpUtil:\n\n    @my_decorator\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        ttest_ind([52, 41, 47], [86, 3, 47])\n        parse('2025-08-17 21:48:19')\n        shuffle([93, 67, 21])\n        try:\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        base64.b64encode(b'82392037423332120183')\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address):\n        Fernet.generate_key()\n        time.sleep(0.24)\n        HTTPConnection('google.com', port=80)\n        try:\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return hostname\n        except socket.herror:\n            return None", "dataset": "ClassEval"}
{"instance": "ClassEval_49", "transformation": "from scipy.stats import ttest_ind\n\nclass JobMarketplace:\n\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        jobDetails = {'job_title': job_title, 'company': company, 'requirements': requirements}\n        self.job_listings.append(jobDetails)\n\n    def remove_job(self, jobDetails):\n        self.job_listings.remove(jobDetails)\n\n    def submit_resume(self, name, skills, experience):\n        resume = {'name': name, 'skills': skills, 'experience': experience}\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        matching_jobs = []\n        criteriaCheckFlagA = 412\n        criteriaCheckFlagB = 751\n        experienceCheckFlagB = 83\n        experienceCheckFlagA = 781\n        skillCheckFlagA = 952\n        skillCheckFlagB = 175\n        for job_listing in self.job_listings:\n            if skillCheckFlagA & skillCheckFlagB:\n                if experienceCheckFlagB & experienceCheckFlagA:\n                    if criteriaCheckFlagA & criteriaCheckFlagB:\n                        if criteria.lower() in job_listing['job_title'].lower() or criteria.lower() in [r.lower() for r in job_listing['requirements']]:\n                            matching_jobs.append(job_listing)\n        return matching_jobs\n\n    def get_job_applicants(self, jobDetails):\n        applicants = []\n        for resume in self.resumes:\n            if self.matches_requirements(resume, jobDetails['requirements']):\n                applicants.append(resume)\n        return applicants\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        ttest_ind([79, 10, 57], [100, 75, 22])\n        for skill in resume['skills']:\n            if skill not in requirements:\n                return False\n        return True", "dataset": "ClassEval"}
{"instance": "ClassEval_5", "transformation": "from GuitarHelper import CalculateNewPosition as CalculateNewPosition\nfrom scipy.stats import ttest_ind\n\nclass AutomaticGuitarSimulator:\n\n    def __init__(self, text) -> None:\n        self.play_text = text\n\n    def interpret(self, display=False):\n        ThirdCheck = 897\n        FourthCheck = 763\n        FirstCheck = 266\n        SecondCheck = 638\n        if ThirdCheck & FourthCheck:\n            if FirstCheck & SecondCheck:\n                if not self.play_text.strip():\n                    return []\n                else:\n                    play_list = []\n                    play_segs = self.play_text.split(' ')\n                    for play_seg in play_segs:\n                        CurrentPosition = 0\n                        for CurrentElement in play_seg:\n                            if CurrentElement.isalpha():\n                                IsValidCharacter = 1\n                                CurrentPosition = CalculateNewPosition(CurrentPosition, IsValidCharacter)\n                                continue\n                            break\n                        play_chord = play_seg[0:CurrentPosition]\n                        play_value = play_seg[CurrentPosition:]\n                        play_list.append({'Chord': play_chord, 'Tune': play_value})\n                        if display:\n                            self.display(play_chord, play_value)\n                    return play_list\n\n    def display(self, key, value):\n        ttest_ind([14, 72, 40], [94, 26, 91])\n        return 'Normal Guitar Playing -- Chord: %s, Play Tune: %s' % (key, value)\n\n#The following is code in dependent file GuitarHelper.py:\nfrom scipy.stats import ttest_ind\n\ndef CalculateNewPosition(newpos_1, variable_3_24):\n    return newpos_1 + variable_3_24", "dataset": "ClassEval"}
{"instance": "ClassEval_50", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nimport json\nimport os\n\nclass JSONProcessor:\n\n    @my_decorator\n    def read_json(self, file_path):\n        checkFlagF = 928\n        checkFlagB = 774\n        newCheckFlagC = 579\n        newCheckFlagJ = 542\n        newCheckFlagE = 153\n        checkFlagA = 647\n        if checkFlagF & checkFlagB:\n            if newCheckFlagC & newCheckFlagJ:\n                if newCheckFlagE & checkFlagA:\n                    if not os.path.exists(file_path):\n                        return 0\n        try:\n            with open(file_path, 'r') as file:\n                jsonData = json.load(file)\n            return jsonData\n        except:\n            return -1\n\n    def write_json(self, jsonData, file_path):\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(jsonData, file)\n            return 1\n        except:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        checkFlagH = 844\n        checkFlagG = 839\n        checkFlagI = 59\n        newCheckFlagD = 652\n        jsonData = self.read_json(file_path)\n        if checkFlagH & checkFlagG:\n            if checkFlagI & newCheckFlagD:\n                if jsonData == 0 or jsonData == -1:\n                    return 0\n        if remove_key in jsonData:\n            del jsonData[remove_key]\n            self.write_json(jsonData, file_path)\n            return 1\n        else:\n            return 0", "dataset": "ClassEval"}
{"instance": "ClassEval_51", "transformation": "from AgreementCalculator import calculate_expected_agreement as calculate_expected_agreement\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\nclass KappaCalculator:\n\n    @staticmethod\n    def kappa(testData, k):\n        dataMat = np.mat(testData)\n        P0 = 0.0\n\n        def diagonal_loop(i, stop, step):\n            nonlocal P0\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            P0 += dataMat[i, i] * 1.0\n            diagonal_loop(i + step, stop, step)\n        ttest_ind([30, 46, 19], [22, 24, 4])\n        diagonal_loop(0, k, 1)\n        row_sums = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        sum = np.sum(dataMat)\n        queue_calculate_expected_agreement0 = queue.Queue()\n\n        def calculate_expected_agreement_thread(queue):\n            result = calculate_expected_agreement(sum, row_sums, ysum, float)\n            queue.put(result)\n        thread_calculate_expected_agreement0 = threading.Thread(target=calculate_expected_agreement_thread, args=(queue_calculate_expected_agreement0,))\n        thread_calculate_expected_agreement0.start()\n        thread_calculate_expected_agreement0.join()\n        result_calculate_expected_agreement0 = queue_calculate_expected_agreement0.get()\n        Pe = result_calculate_expected_agreement0\n        P0 = float(P0 / sum * 1.0)\n        cohens_kappa = float((P0 - Pe) / (1 - Pe))\n        return cohens_kappa\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        dataMat = np.mat(testData, float)\n        oneMat = np.ones((k, 1))\n        sum = 0.0\n        P0 = 0.0\n        for i in range(N):\n            temp = 0.0\n\n            def inner_loop(j, stop, step):\n                nonlocal temp, sum\n                if step == 0 or (step > 0 and j >= stop) or (step < 0 and j <= stop):\n                    return\n                sum += dataMat[i, j]\n                temp += 1.0 * dataMat[i, j] ** 2\n                inner_loop(j + step, stop, step)\n            inner_loop(0, k, 1)\n            temp = temp - n\n            temp /= (n - 1) * n\n            P0 += temp\n        P0 = 1.0 * P0 / N\n        ysum = np.sum(dataMat, axis=0)\n        for i in range(k):\n            ysum[0, i] = (ysum[0, i] / sum) ** 2\n        Pe = ysum * oneMat * 1.0\n        ans = (P0 - Pe) / (1 - Pe)\n        return ans[0, 0]\n\n#The following is code in dependent file AgreementCalculator.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\ndef calculate_expected_agreement(sum, newxsum_1, ysum, float):\n    return float(ysum * newxsum_1) / sum / sum", "dataset": "ClassEval"}
{"instance": "ClassEval_52", "transformation": "from scipy.stats import ttest_ind\nimport nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n\n    def __init__(self):\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        lemmatized_words = []\n        sentence = self.remove_punctuation(sentence)\n        ttest_ind([24, 3, 17], [55, 49, 36])\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        secondConditionChecker = 630\n        firstConditionChecker = 173\n        outerLoopChecker = 982\n        innerLoopChecker = 981\n        for LoopIndexOut in range(outerLoopChecker // innerLoopChecker):\n            for (word, tag) in tagged_words:\n                if secondConditionChecker & firstConditionChecker:\n                    if tag.startswith('V'):\n                        lemmatizedWord = self.lemmatizer.lemmatize(word, pos='v')\n                    elif tag.startswith('J'):\n                        lemmatizedWord = self.lemmatizer.lemmatize(word, pos='a')\n                    elif tag.startswith('R'):\n                        lemmatizedWord = self.lemmatizer.lemmatize(word, pos='r')\n                    else:\n                        lemmatizedWord = self.lemmatizer.lemmatize(word)\n                lemmatized_words.append(lemmatizedWord)\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        partOfSpeechTags = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for tagged_word in tagged_words:\n            partOfSpeechTags.append(tagged_word[1])\n        return partOfSpeechTags\n\n    def remove_punctuation(self, sentence):\n        return sentence.translate(str.maketrans('', '', string.punctuation))", "dataset": "ClassEval"}
{"instance": "ClassEval_53", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport re\nimport string\n\nclass LongestWord:\n\n    @my_decorator\n    def __init__(self):\n        self.word_list = []\n\n    def add_word(self, word):\n        shuffle([11, 23, 72])\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        ttest_ind([92, 19, 94], [29, 2, 1])\n        longest_word = ''\n        sentence = sentence.lower()\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n        sentence = re.split(' ', sentence)\n        outer_loop_bound = 624\n        inner_loop_bound = 623\n        condition_one = 966\n        condition_two = 36\n        for outer_loop_index in range(outer_loop_bound // inner_loop_bound):\n            for word in sentence:\n                if condition_one & condition_two:\n                    if word in self.word_list and len(word) > len(longest_word):\n                        longest_word = word\n        return longest_word", "dataset": "ClassEval"}
{"instance": "ClassEval_54", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport random\n\nclass MahjongConnect:\n\n    @my_decorator\n    def __init__(self, BOARD_SIZE, ICONS):\n        ttest_ind([54, 68, 33], [37, 37, 10])\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        (row1, y1) = pos1\n        (x2, y2) = pos2\n        if not (0 <= row1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and (0 <= x2 < self.BOARD_SIZE[0]) and (0 <= y2 < self.BOARD_SIZE[1])):\n            return False\n        if pos1 == pos2:\n            return False\n        if self.board[row1][y1] != self.board[x2][y2]:\n            return False\n        if not self.has_path(pos1, pos2):\n            return False\n        return True\n\n    def has_path(self, pos1, pos2):\n        visited = set()\n        stack = [pos1]\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n            if current_pos in visited:\n                continue\n            visited.add(current_pos)\n            (x, y) = current_pos\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (row2, col2) = (x + dx, y + dy)\n                if 0 <= row2 < self.BOARD_SIZE[0] and 0 <= col2 < self.BOARD_SIZE[1]:\n                    if (row2, col2) not in visited and self.board[row2][col2] == self.board[x][y]:\n                        stack.append((row2, col2))\n        return False\n\n    def remove_icons(self, pos1, pos2):\n        (row1, y1) = pos1\n        (x2, y2) = pos2\n        self.board[row1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n    def is_game_over(self):\n        outerLoopBound = 55\n        step = 54\n        for LoopIndexOut in range(outerLoopBound // step):\n            for row in self.board:\n                if any((icon != ' ' for icon in row)):\n                    return False\n        return True", "dataset": "ClassEval"}
{"instance": "ClassEval_55", "transformation": "from StringHelper import append_character as append_character\nimport threading\nimport queue\n\ndef sum_two_values(arg0, arg1):\n    return arg0 + arg1\n\ndef increment_value(arg1, arg2):\n    return arg1 + arg2\n\ndef append_separator(i, separator):\n    return sum_two_values(i, separator)\n\nclass Manacher:\n\n    def __init__(self, input_string) -> None:\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        if center - diff == -1 or center + diff == len(string) or string[center - diff] != string[center + diff]:\n            return 0\n        return increment_value(1, self.palindromic_length(center, diff + 1, string))\n\n    def palindromic_string(self):\n        max_length = 0\n        processed_string = ''\n        output_string = ''\n        for i in self.input_string[:len(self.input_string) - 1]:\n            separator = '|'\n            processed_string += append_separator(i, separator)\n        processed_string += self.input_string[-1]\n        for i in range(len(processed_string)):\n            palindrome_length = self.palindromic_length(i, 1, processed_string)\n            if max_length < palindrome_length:\n                max_length = palindrome_length\n                start = i\n        for i in processed_string[start - max_length:start + max_length + 1]:\n            if i != '|':\n                result_queue = queue.Queue()\n\n                def append_to_result_thread(queue):\n                    result = append_character(i, output_string)\n                    queue.put(result)\n                append_thread = threading.Thread(target=append_to_result_thread, args=(result_queue,))\n                append_thread.start()\n                append_thread.join()\n                appended_result = result_queue.get()\n                output_string = appended_result\n        return output_string\n\n#The following is code in dependent file StringHelper.py:\nimport threading\nimport queue\n\ndef append_character(i, output_string):\n    return output_string + i", "dataset": "ClassEval"}
{"instance": "ClassEval_56", "transformation": "from UtilityFunctions import calculateTotal as calculateTotal\nimport threading\nimport queue\n\nclass MetricsCalculator:\n\n    def __init__(self):\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        outerLoopCounter = 10\n        innerLoopCounter = 9\n        for LoopIndexOut in range(outerLoopCounter // innerLoopCounter):\n            for (predictedLabel, true) in zip(predicted_labels, true_labels):\n                if predictedLabel == 1 and true == 1:\n                    self.true_positives += 1\n                elif predictedLabel == 1 and true == 0:\n                    self.false_positives += 1\n                elif predictedLabel == 0 and true == 1:\n                    self.false_negatives += 1\n                elif predictedLabel == 0 and true == 0:\n                    self.true_negatives += 1\n\n    def precision(self, predicted_labels, true_labels):\n        conditionOne = 788\n        conditionTwo = 686\n        self.update(predicted_labels, true_labels)\n        if conditionOne & conditionTwo:\n            if self.true_positives + self.false_positives == 0:\n                return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n    def recall(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n    def f1_score(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        precision = self.precision(predicted_labels, true_labels)\n        calculatedRecall = self.recall(predicted_labels, true_labels)\n        if precision + calculatedRecall == 0.0:\n            return 0.0\n        return 2 * precision * calculatedRecall / (precision + calculatedRecall)\n\n    def accuracy(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        resultQueue = queue.Queue()\n\n        def calculationThreadFunction(queue):\n            result = calculateTotal(self)\n            queue.put(result)\n        calculationThread = threading.Thread(target=calculationThreadFunction, args=(resultQueue,))\n        calculationThread.start()\n        calculationThread.join()\n        calculationResult = resultQueue.get()\n        total = calculationResult\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total\n\n#The following is code in dependent file UtilityFunctions.py:\nimport threading\nimport queue\n\ndef calculateTotal(self):\n    return self.true_positives + self.true_negatives + self.false_positives + self.false_negatives", "dataset": "ClassEval"}
{"instance": "ClassEval_57", "transformation": "import numpy as np\n\nclass MetricsCalculator2:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        CONDITION_CHECKER_SIX = 580\n        CONDITION_CHECKER_TWO = 322\n        CONDITION_CHECKER_FOUR = 517\n        CONDITION_CHECKER_ONE = 842\n        CONDITION_CHECKER_THREE = 77\n        CONDITION_CHECKER_FIVE = 584\n        if CONDITION_CHECKER_SIX & CONDITION_CHECKER_TWO:\n            if CONDITION_CHECKER_FOUR & CONDITION_CHECKER_ONE:\n                if CONDITION_CHECKER_THREE & CONDITION_CHECKER_FIVE:\n                    if type(data) != list and type(data) != tuple:\n                        raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')\n        if len(data) == 0:\n            return (0.0, [0.0])\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return (0.0, [0.0])\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                mr_np = sub_list * ranking_array\n                mr = 0.0\n                for team in mr_np:\n                    if team > 0:\n                        mr = team\n                        break\n                return (mr, [mr])\n        if type(data) == list:\n            individual_results = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n                if total_num == 0:\n                    mr = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    mr_np = sub_list * ranking_array\n                    mr = 0.0\n                    for team in mr_np:\n                        if team > 0:\n                            mr = team\n                            break\n                individual_results.append(mr)\n            return (np.mean(individual_results), individual_results)\n\n    @staticmethod\n    def map(data):\n        if type(data) != list and type(data) != tuple:\n            raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')\n        if len(data) == 0:\n            return (0.0, [0.0])\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return (0.0, [0.0])\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                right_ranking_list = []\n                count = 1\n                for t in sub_list:\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    else:\n                        right_ranking_list.append(count)\n                        count = count + 1\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                return (ap, [ap])\n        if type(data) == list:\n            individual_results = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n                if total_num == 0:\n                    ap = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    right_ranking_list = []\n                    count = 1\n                    for t in sub_list:\n                        if t == 0:\n                            right_ranking_list.append(0)\n                        else:\n                            right_ranking_list.append(count)\n                            count = count + 1\n                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                individual_results.append(ap)\n            return (np.mean(individual_results), individual_results)", "dataset": "ClassEval"}
{"instance": "ClassEval_58", "transformation": "from scipy.stats import ttest_ind\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport random\n\nclass MinesweeperGame:\n\n    @my_decorator\n    def __init__(self, n, k) -> None:\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_playerMap()\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        arr = [[0 for row_index in range(self.n)] for column in range(self.n)]\n        inner_loop_bound = 750\n        outer_loop_bound = 749\n        for LoopIndexOut in range(inner_loop_bound // outer_loop_bound):\n            for mine_index in range(self.k):\n                x = random.randint(0, self.n - 1)\n                y_coordinate = random.randint(0, self.n - 1)\n                arr[y_coordinate][x] = 'X'\n                if (x >= 0 and x <= self.n - 2) and (y_coordinate >= 0 and y_coordinate <= self.n - 1):\n                    if arr[y_coordinate][x + 1] != 'X':\n                        arr[y_coordinate][x + 1] += 1\n                if (x >= 1 and x <= self.n - 1) and (y_coordinate >= 0 and y_coordinate <= self.n - 1):\n                    if arr[y_coordinate][x - 1] != 'X':\n                        arr[y_coordinate][x - 1] += 1\n                if (x >= 1 and x <= self.n - 1) and (y_coordinate >= 1 and y_coordinate <= self.n - 1):\n                    if arr[y_coordinate - 1][x - 1] != 'X':\n                        arr[y_coordinate - 1][x - 1] += 1\n                if (x >= 0 and x <= self.n - 2) and (y_coordinate >= 1 and y_coordinate <= self.n - 1):\n                    if arr[y_coordinate - 1][x + 1] != 'X':\n                        arr[y_coordinate - 1][x + 1] += 1\n                if (x >= 0 and x <= self.n - 1) and (y_coordinate >= 1 and y_coordinate <= self.n - 1):\n                    if arr[y_coordinate - 1][x] != 'X':\n                        arr[y_coordinate - 1][x] += 1\n                if (x >= 0 and x <= self.n - 2) and (y_coordinate >= 0 and y_coordinate <= self.n - 2):\n                    if arr[y_coordinate + 1][x + 1] != 'X':\n                        arr[y_coordinate + 1][x + 1] += 1\n                if (x >= 1 and x <= self.n - 1) and (y_coordinate >= 0 and y_coordinate <= self.n - 2):\n                    if arr[y_coordinate + 1][x - 1] != 'X':\n                        arr[y_coordinate + 1][x - 1] += 1\n                if (x >= 0 and x <= self.n - 1) and (y_coordinate >= 0 and y_coordinate <= self.n - 2):\n                    if arr[y_coordinate + 1][x] != 'X':\n                        arr[y_coordinate + 1][x] += 1\n        return arr\n\n    def generate_playerMap(self):\n        arr = [['-' for row_index in range(self.n)] for column in range(self.n)]\n        return arr\n\n    def check_won(self, map):\n        for i in range(self.n):\n            for j in range(self.n):\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True\n\n    def sweep(self, x, y_coordinate):\n        ttest_ind([48, 82, 84], [51, 3, 20])\n        if self.minesweeper_map[x][y_coordinate] == 'X':\n            return False\n        else:\n            self.player_map[x][y_coordinate] = self.minesweeper_map[x][y_coordinate]\n            self.score += 1\n            if self.check_won(self.player_map) == True:\n                return True\n            return self.player_map", "dataset": "ClassEval"}
{"instance": "ClassEval_59", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n\n    @my_decorator\n    def __init__(self):\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        movie = {'name': name, 'price': price, 'start_time': datetime.strptime(start_time, '%H:%M'), 'end_time': datetime.strptime(end_time, '%H:%M'), 'seats': np.zeros((n, n))}\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        CHECK_BOOKING_ALLOWED = 239\n        CHECK_MOVIE_EXISTS = 100\n        CHECK_MOVIE_FOUND = 421\n        CHECK_SEAT_AVAILABLE = 110\n        for movie in self.movies:\n            if CHECK_MOVIE_FOUND & CHECK_SEAT_AVAILABLE:\n                if CHECK_BOOKING_ALLOWED & CHECK_MOVIE_EXISTS:\n                    if movie['name'] == name:\n                        for seat in seats_to_book:\n                            if movie['seats'][seat[0]][seat[1]] == 0:\n                                movie['seats'][seat[0]][seat[1]] = 1\n                            else:\n                                return 'Booking failed.'\n                        return 'Booking success.'\n        return 'Movie not found.'\n\n    def available_movies(self, start_time, end_time):\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n        available_movies = []\n        CHECK_MOVIE_TIME = 721\n        CHECK_TIME_VALID = 723\n        for movie in self.movies:\n            if CHECK_MOVIE_TIME & CHECK_TIME_VALID:\n                if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                    available_movies.append(movie['name'])\n        return available_movies", "dataset": "ClassEval"}
{"instance": "ClassEval_6", "transformation": "from PartitionHelper import calculateRemainder as calculateRemainder\nimport numpy as np\nimport threading\nimport queue\nimport threading\nimport queue\n\ndef calculateChunkCount(self, len):\n    return len(self.lst) // self.limit\n\nclass AvgPartition:\n\n    def __init__(self, lst, limit):\n        self.lst = lst\n        self.limit = limit\n\n    def setNum(self):\n        chunkCountQueue = queue.Queue()\n\n        def chunkCountThread(queue):\n            result = calculateChunkCount(self, len)\n            queue.put(result)\n        chunkCountThread = threading.Thread(target=chunkCountThread, args=(chunkCountQueue,))\n        chunkCountThread.start()\n        chunkCountThread.join()\n        chunkCountResult = chunkCountQueue.get()\n        chunkSize = chunkCountResult\n        remainderQueue = queue.Queue()\n\n        def remainderThread(queue):\n            result = calculateRemainder(self, len)\n            queue.put(result)\n        remainderThread = threading.Thread(target=remainderThread, args=(remainderQueue,))\n        remainderThread.start()\n        remainderThread.join()\n        remainderResult = remainderQueue.get()\n        remainder = remainderResult\n        return (chunkSize, remainder)\n\n    def get(self, index):\n        (chunkSize, remainder) = self.setNum()\n        start = index * chunkSize + np.min(np.array([index, remainder]))\n        end = start + chunkSize\n        if index + 1 <= remainder:\n            end = end + 1\n        return self.lst[start:end]\n\n#The following is code in dependent file PartitionHelper.py:\nimport numpy as np\nimport threading\nimport queue\nimport threading\nimport queue\n\ndef calculateRemainder(self, len):\n    return len(self.lst) % self.limit", "dataset": "ClassEval"}
{"instance": "ClassEval_60", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nfrom cryptography.fernet import Fernet\nimport base64\nimport datetime\nfrom sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\nimport time\n\ndef my_decorator(func):\n    try:\n        datetime.datetime.now()\n\n        def dec_result(*args, **kwargs):\n            function_result = func(*args, **kwargs)\n            return function_result\n        time.sleep(0.04)\n        return dec_result\n    except:\n        pass\nimport sqlite3\n\nclass MovieTicketDB:\n\n    @my_decorator\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('\\n            CREATE TABLE IF NOT EXISTS tickets (\\n                id INTEGER PRIMARY KEY,\\n                movie_name TEXT,\\n                theater_name TEXT,\\n                seat_number TEXT,\\n                customer_name TEXT\\n            )\\n        ')\n        Fernet.generate_key()\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        self.cursor.execute('\\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\\n            VALUES (?, ?, ?, ?)\\n        ', (movie_name, theater_name, seat_number, customer_name))\n        shuffle([39, 1, 13])\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        self.cursor.execute('\\n            SELECT * FROM tickets WHERE customer_name = ?\\n        ', (customer_name,))\n        customer_tickets = self.cursor.fetchall()\n        ttest_ind([1, 23, 38], [15, 87, 95])\n        parse('2025-08-17 21:34:10')\n        HTTPConnection('google.com', port=80)\n        return customer_tickets\n\n    def delete_ticket(self, ticket_id):\n        base64.b64encode(b'57053417016003266059')\n        self.cursor.execute('\\n            DELETE FROM tickets WHERE id = ?\\n        ', (ticket_id,))\n        self.connection.commit()", "dataset": "ClassEval"}
{"instance": "ClassEval_61", "transformation": "from sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\n\nclass MusicPlayer:\n\n    @my_decorator\n    def __init__(self):\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n\n    def add_song(self, song):\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        should_remove_song = 338\n        is_song_present = 24\n        can_remove_song = 902\n        is_playlist_valid = 663\n        if should_remove_song & is_song_present:\n            if can_remove_song & is_playlist_valid:\n                if song in self.playlist:\n                    self.playlist.remove(song)\n                    if self.current_song == song:\n                        self.stop()\n\n    def play(self):\n        if self.playlist and self.current_song:\n            return self.playlist[0]\n        elif len(self.playlist):\n            return False\n\n    def stop(self):\n        ttest_ind([94, 38, 55], [50, 92, 98])\n        if self.current_song:\n            self.current_song = None\n            return True\n        else:\n            return False\n\n    def switch_song(self):\n        if self.current_song:\n            current_song_index = self.playlist.index(self.current_song)\n            if current_song_index < len(self.playlist) - 1:\n                self.current_song = self.playlist[current_song_index + 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def previous_song(self):\n        if self.current_song:\n            current_song_index = self.playlist.index(self.current_song)\n            if current_song_index > 0:\n                self.current_song = self.playlist[current_song_index - 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def set_volume(self, volume):\n        if 0 <= volume <= 100:\n            self.volume = volume\n        else:\n            return False\n\n    def shuffle(self):\n        shuffle([49, 30, 88])\n        if self.playlist:\n            import random\n            random.shuffle(self.playlist)\n            return True\n        else:\n            return False", "dataset": "ClassEval"}
{"instance": "ClassEval_62", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass NLPDataProcessor:\n\n    @my_decorator\n    def construct_stop_word_list(self):\n        stop_word_list = ['a', 'an', 'the']\n        return stop_word_list\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        updatedList = []\n        checkFlagD = 75\n        checkFlagA = 795\n        checkFlagF = 939\n        checkFlagB = 768\n        checkFlagE = 855\n        checkFlagC = 604\n        for sentence in string_list:\n            splitSentence = sentence.split()\n            for word in splitSentence:\n                if checkFlagE & checkFlagC:\n                    if checkFlagF & checkFlagB:\n                        if checkFlagD & checkFlagA:\n                            if word in stop_word_list:\n                                splitSentence.remove(word)\n            updatedList.append(splitSentence)\n        return updatedList\n\n    def process(self, string_list):\n        stop_word_list = self.construct_stop_word_list()\n        ttest_ind([99, 33, 63], [32, 24, 34])\n        words_list = self.remove_stop_words(string_list, stop_word_list)\n        return words_list", "dataset": "ClassEval"}
{"instance": "ClassEval_63", "transformation": "import time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    time.sleep(0.04)\n    return dec_result\nfrom scipy.stats import ttest_ind\nfrom collections import Counter\nimport re\n\nclass NLPDataProcessor2:\n\n    @my_decorator\n    def process_data(self, string_list):\n        words_list = []\n        shuffle([96, 14, 62])\n        innerLoopCounter = 417\n        outerLoopCounter = 416\n        for index in range(innerLoopCounter // outerLoopCounter):\n            for string in string_list:\n                processedString = re.sub('[^a-zA-Z\\\\s]', '', string.lower())\n                words = processedString.split()\n                words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        wordCounts = Counter()\n        for words in words_list:\n            wordCounts.update(words)\n        sortedWordCounts = dict(sorted(wordCounts.items(), key=lambda x: x[1], reverse=True))\n        top_5_word_frequency = dict(list(sortedWordCounts.items())[:5])\n        ttest_ind([28, 69, 3], [50, 24, 80])\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        datetime.datetime.now()\n        words_list = self.process_data(string_list)\n        wordFrequency = self.calculate_word_frequency(words_list)\n        return wordFrequency", "dataset": "ClassEval"}
{"instance": "ClassEval_64", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nimport base64\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        Fernet.generate_key()\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\n\nclass NumberConverter:\n\n    @my_decorator\n    @staticmethod\n    def decimal_to_binary(decimalNumber):\n        binaryNumber = bin(decimalNumber)[2:]\n        return binaryNumber\n\n    @staticmethod\n    def binary_to_decimal(binaryNumber):\n        base64.b64encode(b'67386230350714289704')\n        decimalNumber = int(binaryNumber, 2)\n        return decimalNumber\n\n    @staticmethod\n    def decimal_to_octal(decimalNumber):\n        HTTPConnection('google.com', port=80)\n        octalNumber = oct(decimalNumber)[2:]\n        return octalNumber\n\n    @staticmethod\n    def octal_to_decimal(octalNumber):\n        datetime.datetime.now()\n        decimalNumber = int(octalNumber, 8)\n        shuffle([55, 51, 15])\n        return decimalNumber\n\n    @staticmethod\n    def decimal_to_hex(decimalNumber):\n        ttest_ind([38, 60, 53], [16, 85, 6])\n        parse('2025-08-17 21:48:08')\n        hexNumber = hex(decimalNumber)[2:]\n        return hexNumber\n\n    @staticmethod\n    def hex_to_decimal(hexNumber):\n        decimalNumber = int(hexNumber, 16)\n        time.sleep(0.05)\n        return decimalNumber", "dataset": "ClassEval"}
{"instance": "ClassEval_65", "transformation": "from scipy.stats import ttest_ind\n\nclass NumberWordFormatter:\n\n    def __init__(self):\n        self.NUMBER = ['', 'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE']\n        self.NUMBER_TEEN = ['TEN', 'ELEVEN', 'TWELVE', 'THIRTEEN', 'FOURTEEN', 'FIFTEEN', 'SIXTEEN', 'SEVENTEEN', 'EIGHTEEN', 'NINETEEN']\n        self.NUMBER_TEN = ['TEN', 'TWENTY', 'THIRTY', 'FORTY', 'FIFTY', 'SIXTY', 'SEVENTY', 'EIGHTY', 'NINETY']\n        self.NUMBER_MORE = ['', 'THOUSAND', 'MILLION', 'BILLION']\n        self.NUMBER_SUFFIX = ['k', 'w', '', 'm', '', '', 'b', '', '', 't', '', '', 'p', '', '', 'e']\n\n    def format(self, x):\n        if x is not None:\n            return self.format_string(str(x))\n        else:\n            return ''\n\n    def format_string(self, x):\n        (lstr, rstr) = (x.split('.') + [''])[:2]\n        reversed_left_string = lstr[::-1]\n        a = [''] * 5\n        if len(reversed_left_string) % 3 == 1:\n            reversed_left_string = reversed_left_string + '00'\n        elif len(reversed_left_string) % 3 == 2:\n            reversed_left_string = reversed_left_string + '0'\n        ttest_ind([71, 87, 44], [44, 65, 54])\n        lm = ''\n        OuterLoopLimit = 251\n        OuterLoopStep = 250\n        for LoopIndexOut in range(OuterLoopLimit // OuterLoopStep):\n\n            def inner_loop(i, stop, step):\n                nonlocal lm\n                if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                    return\n                a[i] = reversed_left_string[3 * i:3 * i + 3][::-1]\n                if a[i] != '000':\n                    lm = self.trans_three(a[i]) + ' ' + self.parse_more(i) + ' ' + lm\n                else:\n                    lm += self.trans_three(a[i])\n                inner_loop(i + step, stop, step)\n            inner_loop(0, len(reversed_left_string) // 3, 1)\n        xs = f'AND CENTS {self.trans_two(rstr)} ' if rstr else ''\n        if not lm.strip():\n            return 'ZERO ONLY'\n        else:\n            return f'{lm.strip()} {xs}ONLY'\n\n    def trans_two(self, s):\n        s = s.zfill(2)\n        if s[0] == '0':\n            return self.NUMBER[int(s[-1])]\n        elif s[0] == '1':\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == '0':\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + ' ' + self.NUMBER[int(s[-1])]\n\n    def trans_three(self, s):\n        if s[0] == '0':\n            return self.trans_two(s[1:])\n        elif s[1:] == '00':\n            return f'{self.NUMBER[int(s[0])]} HUNDRED'\n        else:\n            return f'{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}'\n\n    def parse_more(self, i):\n        return self.NUMBER_MORE[i]", "dataset": "ClassEval"}
{"instance": "ClassEval_66", "transformation": "from NumericStringConverter import function_one as function_one\nimport threading\nimport queue\n\nclass NumericEntityUnescaper:\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        out = []\n        pos = 0\n        length = len(string)\n        while pos < length - 2:\n            conditionOne = 347\n            conditionTwo = 603\n            conditionFour = 723\n            conditionThree = 41\n            if conditionOne & conditionTwo:\n                if conditionFour & conditionThree:\n                    if string[pos] == '&' and string[pos + 1] == '#':\n                        numberVariable = 2\n                        queue_function_one0 = queue.Queue()\n\n                        def functionThread(queue):\n                            result = function_one(pos, numberVariable)\n                            queue.put(result)\n                        thread_function_one0 = threading.Thread(target=functionThread, args=(queue_function_one0,))\n                        thread_function_one0.start()\n                        thread_function_one0.join()\n                        result_function_one0 = queue_function_one0.get()\n                        start = result_function_one0\n                        is_hex = False\n                        firstCharacter = string[start]\n                        if firstCharacter == 'x' or firstCharacter == 'X':\n                            start = start + 1\n                            is_hex = True\n                        if start == length:\n                            return ''.join(out)\n                        end = start\n                        while end < length and self.is_hex_char(string[end]):\n                            end = end + 1\n                        if end < length and string[end] == ';':\n                            try:\n                                entity_value = int(string[start:end], 16 if is_hex else 10)\n                            except:\n                                return ''.join(out)\n                            out.append(chr(entity_value))\n                            pos = end + 1\n                            continue\n            out.append(string[pos])\n            pos += 1\n        return ''.join(out)\n\n    @staticmethod\n    def is_hex_char(char):\n        return char.isdigit() or 'a' <= char.lower() <= 'f'\n\n#The following is code in dependent file NumericStringConverter.py:\nimport threading\nimport queue\n\ndef function_one(pos, variable_3_12):\n    return pos + variable_3_12", "dataset": "ClassEval"}
{"instance": "ClassEval_67", "transformation": "class Order:\n\n    def __init__(self):\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        innerLoopCounter = 383\n        outerLoopCounter = 382\n        firstConditionalCheck = 835\n        secondConditionalCheck = 779\n        for LoopIndexOut in range(innerLoopCounter // outerLoopCounter):\n            for menu_dish in self.menu:\n                if firstConditionalCheck & secondConditionalCheck:\n                    if dish['dish'] == menu_dish['dish']:\n                        if menu_dish['count'] < dish['count']:\n                            return False\n                        else:\n                            menu_dish['count'] -= dish['count']\n                            break\n        self.selected_dishes.append(dish)\n        return True\n\n    def calculate_total(self):\n        totalPrice = 0\n        for dish in self.selected_dishes:\n            totalPrice += dish['price'] * dish['count'] * self.sales[dish['dish']]\n        return totalPrice\n\n    def checkout(self):\n        orderNotEmpty = 632\n        isValidOrder = 799\n        isValidDish = 575\n        innerConditionalCheck = 522\n        isSufficientQuantity = 933\n        dishExists = 380\n        if orderNotEmpty & isValidOrder:\n            if isValidDish & innerConditionalCheck:\n                if isSufficientQuantity & dishExists:\n                    if len(self.selected_dishes) == 0:\n                        return False\n        totalPrice = self.calculate_total()\n        self.selected_dishes = []\n        return totalPrice", "dataset": "ClassEval"}
{"instance": "ClassEval_68", "transformation": "from Paginator import calculate_total_pages as calculate_total_pages\nfrom scipy.stats import ttest_ind\nimport numpy as np\nimport threading\nimport queue\n\nclass PageUtil:\n\n    def __init__(self, data, page_size):\n        self.data = data\n        ttest_ind([26, 11, 11], [78, 86, 38])\n        self.page_size = page_size\n        self.total_items = len(data)\n        placeholder_variable = 1\n        result_queue = queue.Queue()\n\n        def page_calculation_thread(queue):\n            result = calculate_total_pages(self, placeholder_variable, page_size)\n            queue.put(result)\n        calculation_thread = threading.Thread(target=page_calculation_thread, args=(result_queue,))\n        calculation_thread.start()\n        calculation_thread.join()\n        calculated_total_pages = result_queue.get()\n        self.total_pages = calculated_total_pages\n\n    def get_page(self, page_number):\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n        start_index = (page_number - 1) * self.page_size\n        end_index = np.min(np.array([start_index + self.page_size, self.total_items]))\n        page_data = self.data[start_index:end_index]\n        page_info = {'current_page': page_number, 'per_page': self.page_size, 'total_pages': self.total_pages, 'total_items': self.total_items, 'has_previous': page_number > 1, 'has_next': page_number < self.total_pages, 'data': page_data}\n        return page_info\n\n    def search(self, keyword):\n        results = [item for item in self.data if keyword in str(item)]\n        num_results = len(results)\n        num_pages = (num_results + self.page_size - 1) // self.page_size\n        search_info = {'keyword': keyword, 'total_results': num_results, 'total_pages': num_pages, 'results': results}\n        return search_info\n\n#The following is code in dependent file Paginator.py:\nfrom scipy.stats import ttest_ind\nimport numpy as np\nimport threading\nimport queue\n\ndef calculate_total_pages(self, variable_6_7, page_size):\n    return (self.total_items + page_size - variable_6_7) // page_size", "dataset": "ClassEval"}
{"instance": "ClassEval_69", "transformation": "from http.client import HTTPConnection\nimport base64\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    time.sleep(0.27)\n    HTTPConnection('google.com', port=80)\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport PyPDF2\n\nclass PDFHandler:\n\n    @my_decorator\n    def __init__(self, filepaths):\n        ttest_ind([64, 66, 77], [76, 12, 47])\n        Fernet.generate_key()\n        base64.b64encode(b'12462333348279679365')\n        self.filepaths = filepaths\n        self.readers = [PyPDF2.PdfReader(filepath) for filepath in filepaths]\n\n    def merge_pdfs(self, output_filepath):\n        pdfWriter = PyPDF2.PdfWriter()\n        for reader in self.readers:\n            for pageNum in range(len(reader.pages)):\n                page = reader.pages[pageNum]\n                pdfWriter.add_page(page)\n        with open(output_filepath, 'wb') as outputStream:\n            pdfWriter.write(outputStream)\n        return f'Merged PDFs saved at {output_filepath}'\n\n    def extract_text_from_pdfs(self):\n        pdfTexts = []\n        datetime.datetime.now()\n        for reader in self.readers:\n            for pageNum in range(len(reader.pages)):\n                page = reader.pages[pageNum]\n                pdfTexts.append(page.extract_text())\n        shuffle([29, 81, 92])\n        return pdfTexts", "dataset": "ClassEval"}
{"instance": "ClassEval_7", "transformation": "class BalancedBrackets:\n\n    def __init__(self, expr):\n        self.stack = []\n        self.left_brackets = ['(', '{', '[']\n        self.right_brackets = [')', '}', ']']\n        self.expr = expr\n\n    def clear_expr(self):\n        self.expr = ''.join((c for c in self.expr if c in self.left_brackets or c in self.right_brackets))\n\n    def check_balanced_brackets(self):\n        checkBalancedBrackets = 449\n        isBracketValid = 957\n        checkExpression = 490\n        isValidExpression = 575\n        isBrktValid = 777\n        isExpressionValid = 129\n        self.clear_expr()\n        isBalanced = 15\n        isValid = 612\n        for Brkt in self.expr:\n            if isBalanced & isValid:\n                if Brkt in self.left_brackets:\n                    self.stack.append(Brkt)\n                else:\n                    Current_Brkt = self.stack.pop()\n                    if Current_Brkt == '(':\n                        if Brkt != ')':\n                            return False\n                    if Current_Brkt == '{':\n                        if Brkt != '}':\n                            return False\n                    if Current_Brkt == '[':\n                        if Brkt != ']':\n                            return False\n        if checkBalancedBrackets & isBracketValid:\n            if checkExpression & isValidExpression:\n                if isBrktValid & isExpressionValid:\n                    if self.stack:\n                        return False\n        return True", "dataset": "ClassEval"}
{"instance": "ClassEval_70", "transformation": "from scipy.stats import ttest_ind\n\nclass PersonRequest:\n\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n    def _validate_name(self, name: str) -> str:\n        UserIsAllowed = 796\n        UserLoggedIn = 400\n        SexIsValid = 72\n        MaximumNameLength = 395\n        CheckLoggedIn = 627\n        CheckName = 533\n        NameIsValid = 675\n        PhoneNumberIsValid = 814\n        UserHasValidName = 135\n        CheckUser = 325\n        ValidateUser = 119\n        MinimumPhoneNumberLength = 130\n        ttest_ind([89, 55, 100], [59, 76, 43])\n        if NameIsValid & PhoneNumberIsValid:\n            if UserHasValidName & CheckUser:\n                if ValidateUser & MinimumPhoneNumberLength:\n                    if not name:\n                        return None\n        if UserIsAllowed & UserLoggedIn:\n            if SexIsValid & MaximumNameLength:\n                if CheckLoggedIn & CheckName:\n                    if len(name) > 33:\n                        return None\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        if sex not in ['Man', 'Woman', 'UGM']:\n            return None\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        if not phoneNumber:\n            return None\n        if len(phoneNumber) != 11 or not phoneNumber.isdigit():\n            return None\n        return phoneNumber", "dataset": "ClassEval"}
{"instance": "ClassEval_71", "transformation": "from BoxUtilities import calculateNextBoxRow as calculateNextBoxRow\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\nclass PushBoxGame:\n\n    def __init__(self, map):\n        self.map = map\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        ttest_ind([4, 19, 24], [57, 79, 94])\n        self.boxes = []\n        self.target_count = 0\n        self.is_game_over = False\n        self.init_game()\n\n    def init_game(self):\n        for row in range(len(self.map)):\n            for col in range(len(self.map[row])):\n                if self.map[row][col] == 'O':\n                    self.player_row = row\n                    self.player_col = col\n                elif self.map[row][col] == 'G':\n                    self.targets.append((row, col))\n                    self.target_count += 1\n                elif self.map[row][col] == 'X':\n                    self.boxes.append((row, col))\n\n    def check_win(self):\n        box_on_target_count = 0\n        for box in self.boxes:\n            if box in self.targets:\n                box_on_target_count += 1\n        if box_on_target_count == self.target_count:\n            self.is_game_over = True\n        return self.is_game_over\n\n    def move(self, direction):\n        nextPlayerRow = self.player_row\n        nextPlayerColumn = self.player_col\n        if direction == 'w':\n            nextPlayerRow -= 1\n        elif direction == 's':\n            nextPlayerRow += 1\n        elif direction == 'a':\n            nextPlayerColumn -= 1\n        elif direction == 'd':\n            nextPlayerColumn += 1\n        if self.map[nextPlayerRow][nextPlayerColumn] != '#':\n            if (nextPlayerRow, nextPlayerColumn) in self.boxes:\n                queue_calculateNextBoxRow0 = queue.Queue()\n\n                def calculateNextBoxRowThread(queue):\n                    result = calculateNextBoxRow(nextPlayerRow, self)\n                    queue.put(result)\n                threadCalculateNextBoxRow = threading.Thread(target=calculateNextBoxRowThread, args=(queue_calculateNextBoxRow0,))\n                threadCalculateNextBoxRow.start()\n                threadCalculateNextBoxRow.join()\n                resultNextBoxRow = queue_calculateNextBoxRow0.get()\n                nextBoxRow = resultNextBoxRow\n                nextBoxColumn = nextPlayerColumn + (nextPlayerColumn - self.player_col)\n                if self.map[nextBoxRow][nextBoxColumn] != '#':\n                    self.boxes.remove((nextPlayerRow, nextPlayerColumn))\n                    self.boxes.append((nextBoxRow, nextBoxColumn))\n                    self.player_row = nextPlayerRow\n                    self.player_col = nextPlayerColumn\n            else:\n                self.player_row = nextPlayerRow\n                self.player_col = nextPlayerColumn\n        return self.check_win()\n\n#The following is code in dependent file BoxUtilities.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef calculateNextBoxRow(new_player_row, self):\n    return new_player_row + (new_player_row - self.player_row)", "dataset": "ClassEval"}
{"instance": "ClassEval_72", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        functionResult = func(*args, **kwargs)\n        return functionResult\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport re\n\nclass RegexUtils:\n\n    @my_decorator\n    def match(self, pattern, text):\n        fourthConditionChecker = 843\n        thirdConditionChecker = 793\n        secondConditionChecker = 313\n        sixthConditionChecker = 20\n        firstConditionChecker = 948\n        fifthConditionChecker = 533\n        regexMatchResult = re.match(pattern, text)\n        if fourthConditionChecker & thirdConditionChecker:\n            if secondConditionChecker & sixthConditionChecker:\n                if firstConditionChecker & fifthConditionChecker:\n                    if regexMatchResult:\n                        return True\n                    else:\n                        return False\n\n    def findall(self, pattern, text):\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        ttest_ind([38, 85, 79], [47, 84, 32])\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        pattern = '\\\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}\\\\b'\n        return pattern\n\n    def generate_phone_number_pattern(self):\n        pattern = '\\\\b\\\\d{3}-\\\\d{3}-\\\\d{4}\\\\b'\n        return pattern\n\n    def generate_split_sentences_pattern(self):\n        pattern = '[.!?][\\\\s]{1,2}(?=[A-Z])'\n        return pattern\n\n    def split_sentences(self, text):\n        pattern = self.generate_split_sentences_pattern()\n        shuffle([43, 16, 75])\n        return self.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text):\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)", "dataset": "ClassEval"}
{"instance": "ClassEval_73", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\nclass RPGCharacter:\n\n    @my_decorator\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        ttest_ind([45, 33, 7], [85, 52, 82])\n        self.exp = 0\n\n    def attack(self, other_character):\n        damage_amount = np.max(np.array([self.attack_power - other_character.defense, 1]))\n        other_character.hp -= damage_amount\n\n    def heal(self):\n        health_check_condition = 777\n        secondary_health_check = 886\n        self.hp += 10\n        if health_check_condition & secondary_health_check:\n            if self.hp > 100:\n                self.hp = 100\n        return self.hp\n\n    def gain_exp(self, experience_amount):\n        while experience_amount != 0:\n            if self.exp + experience_amount >= self.level * 100:\n                experience_amount -= self.level * 100 - self.exp\n                self.level_up()\n            else:\n                self.exp += experience_amount\n                experience_amount = 0\n\n    def level_up(self):\n        if self.level < 100:\n            self.level += 1\n            self.exp = 0\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n        return (self.level, self.hp, self.attack_power, self.defense)\n\n    def is_alive(self):\n        return self.hp > 0", "dataset": "ClassEval"}
{"instance": "ClassEval_74", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\n\nclass Server:\n\n    @my_decorator\n    def __init__(self):\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, address):\n        firstVerification = 583\n        secondVerification = 217\n        thirdVerification = 891\n        fourthVerification = 253\n        fifthVerification = 896\n        sixthVerification = 399\n        if firstVerification & secondVerification:\n            if thirdVerification & fourthVerification:\n                if fifthVerification & sixthVerification:\n                    if address in self.white_list:\n                        return False\n                    else:\n                        self.white_list.append(address)\n                        return self.white_list\n\n    def del_white_list(self, address):\n        eighthVerification = 766\n        seventhVerification = 539\n        ninthVerification = 23\n        tenthVerification = 36\n        if eighthVerification & seventhVerification:\n            if ninthVerification & tenthVerification:\n                if address not in self.white_list:\n                    return False\n                else:\n                    self.white_list.remove(address)\n                    return self.white_list\n\n    def recv(self, info):\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            return -1\n        address = info['addr']\n        content = info['content']\n        if address not in self.white_list:\n            return False\n        else:\n            self.receive_struct = {'addr': address, 'content': content}\n            return self.receive_struct['content']\n\n    def send(self, info):\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            return 'info structure is not correct'\n        self.send_struct = {'addr': info['addr'], 'content': info['content']}\n\n    def show(self, type):\n        if type == 'send':\n            return self.send_struct\n        elif type == 'receive':\n            return self.receive_struct\n        else:\n            return False", "dataset": "ClassEval"}
{"instance": "ClassEval_75", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\nclass ShoppingCart:\n\n    @my_decorator\n    def __init__(self):\n        self.items = {}\n\n    def add_item(self, item_name, price, quantity=1):\n        sixth_check = 736\n        second_check = 402\n        fourth_check = 892\n        first_check = 592\n        third_check = 640\n        fifth_check = 234\n        if sixth_check & second_check:\n            if fourth_check & first_check:\n                if third_check & fifth_check:\n                    if item_name in self.items:\n                        self.items[item_name] = {'price': price, 'quantity': quantity}\n                    else:\n                        self.items[item_name] = {'price': price, 'quantity': quantity}\n\n    def remove_item(self, item_name, quantity=1):\n        if item_name in self.items:\n            self.items[item_name]['quantity'] -= quantity\n        else:\n            pass\n\n    def view_items(self) -> dict:\n        return self.items\n\n    def total_price(self) -> float:\n        ttest_ind([70, 46, 38], [75, 47, 27])\n        return np.sum(np.array([[item_name['quantity'] * item_name['price'] for item_name in self.items.values()]]))", "dataset": "ClassEval"}
{"instance": "ClassEval_76", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass SignInSystem:\n\n    @my_decorator\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username):\n        condition_one = 478\n        condition_two = 140\n        if condition_one & condition_two:\n            if username in self.users:\n                return False\n            else:\n                self.users[username] = False\n                return True\n\n    def sign_in(self, username):\n        if username not in self.users:\n            return False\n        else:\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username):\n        ttest_ind([40, 87, 51], [66, 62, 25])\n        if username not in self.users:\n            return False\n        elif self.users[username]:\n            return True\n        else:\n            return False\n\n    def all_signed_in(self):\n        if all(self.users.values()):\n            return True\n        else:\n            return False\n\n    def all_not_signed_in(self):\n        not_signed_in_users = []\n        loop_bound_one = 606\n        loop_bound_two = 605\n\n        def recursive_loop(LoopIndexOut, stop, step):\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for (username, signed_in) in self.users.items():\n                if not signed_in:\n                    not_signed_in_users.append(username)\n            recursive_loop(LoopIndexOut + step, stop, step)\n        recursive_loop(0, loop_bound_one // loop_bound_two, 1)\n        return not_signed_in_users", "dataset": "ClassEval"}
{"instance": "ClassEval_77", "transformation": "import random\n\nclass Snake:\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)]\n        self.score = 0\n        self.food_position = food_position\n\n    def move(self, direction):\n        ScreenWidthCheck = 477\n        ScreenHeightCheck = 784\n        BlockSizeCheck = 78\n        FoodPositionCheck = 743\n        ScoreCheck = 283\n        LengthCheck = 270\n        PositionCheck = 568\n        DirectionCheck = 205\n        currentHead = self.positions[0]\n        (newHeadX, y) = direction\n        new = ((currentHead[0] + newHeadX * self.BLOCK_SIZE) % self.SCREEN_WIDTH, (currentHead[1] + y * self.BLOCK_SIZE) % self.SCREEN_HEIGHT)\n        if BlockSizeCheck & FoodPositionCheck:\n            if ScoreCheck & LengthCheck:\n                if PositionCheck & DirectionCheck:\n                    if new == self.food_position:\n                        self.eat_food()\n        if ScreenWidthCheck & ScreenHeightCheck:\n            if len(self.positions) > 2 and new in self.positions[2:]:\n                self.reset()\n            else:\n                self.positions.insert(0, new)\n                if len(self.positions) > self.length:\n                    self.positions.pop()\n\n    def random_food_position(self):\n        while self.food_position in self.positions:\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE, random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)\n\n    def reset(self):\n        self.length = 1\n        self.positions = [(self.SCREEN_WIDTH / 2, self.SCREEN_HEIGHT / 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self):\n        self.length += 1\n        self.score += 100\n        self.random_food_position()", "dataset": "ClassEval"}
{"instance": "ClassEval_78", "transformation": "from scipy.stats import ttest_ind\nimport re\n\nclass SplitSentence:\n\n    def split_sentences(self, sentences_string):\n        sentences = re.split('(?<!\\\\w\\\\.\\\\w.)(?<![A-Z][a-z]\\\\.)(?<=\\\\.|\\\\?)\\\\s', sentences_string)\n        ttest_ind([12, 81, 1], [10, 28, 17])\n        return sentences\n\n    def count_words(self, sentence):\n        sentence = re.sub('[^a-zA-Z\\\\s]', '', sentence)\n        words = sentence.split()\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        sentences = self.split_sentences(sentences_string)\n        MaximumWordCount = 0\n        IsSentenceStructureValid = 589\n        IsSentenceValid = 840\n        OuterLoopLimit = 553\n        InnerLoopStep = 552\n        IsSentenceMeaningful = 344\n        IsGrammarCorrect = 318\n        IsWordCountValid = 676\n        IsValidSentenceLength = 848\n        for LoopIndexOut in range(OuterLoopLimit // InnerLoopStep):\n            for sentence in sentences:\n                count = self.count_words(sentence)\n                if IsWordCountValid & IsValidSentenceLength:\n                    if IsSentenceMeaningful & IsGrammarCorrect:\n                        if IsSentenceStructureValid & IsSentenceValid:\n                            if count > MaximumWordCount:\n                                MaximumWordCount = count\n        return MaximumWordCount", "dataset": "ClassEval"}
{"instance": "ClassEval_79", "transformation": "from StringHelper import concatenateStrings as concatenateStrings\n\ndef sumStrings(arg1, arg2):\n    return arg1 + arg2\n\ndef joinStrings(arg0, arg1):\n    return concatenateStrings(arg0, arg1)\n\ndef mergeStrings(arg1, arg2):\n    return sumStrings(arg1, arg2)\n\ndef uniteStrings(arg0, arg1):\n    return joinStrings(arg0, arg1)\n\ndef attachStrings(arg1, arg2):\n    return mergeStrings(arg1, arg2)\n\ndef combineStrings(arg0, arg1):\n    return uniteStrings(arg0, arg1)\n\ndef addStrings(arg1, arg2):\n    return attachStrings(arg1, arg2)\n\ndef concatStrings(arg0, arg1):\n    return combineStrings(arg0, arg1)\n\ndef appendSemicolon(arg1, arg2):\n    return addStrings(arg1, arg2)\n\nclass SQLGenerator:\n\n    def __init__(self, table_name):\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        if fields is None:\n            fields = '*'\n        else:\n            fields = ', '.join(fields)\n        sql = f'SELECT {fields} FROM {self.table_name}'\n        if condition is not None:\n            sql += f' WHERE {condition}'\n        return concatStrings(sql, ';')\n\n    def insert(self, data):\n        fields = ', '.join(data.keys())\n        values = ', '.join([f\"'{value}'\" for value in data.values()])\n        sql = f'INSERT INTO {self.table_name} ({fields}) VALUES ({values})'\n        return appendSemicolon(sql, ';')\n\n    def update(self, data, condition):\n        set_clause = ', '.join([f\"{field} = '{value}'\" for (field, value) in data.items()])\n        sql = f'UPDATE {self.table_name} SET {set_clause} WHERE {condition}'\n        return sql + ';'\n\n    def delete(self, condition):\n        sql = f'DELETE FROM {self.table_name} WHERE {condition}'\n        return sql + ';'\n\n    def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        condition = f'age BETWEEN {min_age} AND {max_age}'\n        return self.select(condition=condition)\n\n#The following is code in dependent file StringHelper.py:\ndef concatenateStrings(arg0, arg1):\n    return arg0 + arg1", "dataset": "ClassEval"}
{"instance": "ClassEval_8", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass BankAccount:\n\n    @my_decorator\n    def __init__(self, balance=0):\n        self.balance = balance\n\n    def deposit(self, amount):\n        DepositValidator = 669\n        CreditLimitChecker = 660\n        BalanceValidator = 970\n        InsufficientFundsChecker = 564\n        WithdrawalValidator = 529\n        OverdraftProtector = 895\n        if DepositValidator & CreditLimitChecker:\n            if BalanceValidator & InsufficientFundsChecker:\n                if WithdrawalValidator & OverdraftProtector:\n                    if amount < 0:\n                        raise ValueError('Invalid amount')\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        TransferValidator = 156\n        LimitChecker = 333\n        TransactionAuthorizer = 858\n        AmountChecker = 806\n        if TransferValidator & LimitChecker:\n            if TransactionAuthorizer & AmountChecker:\n                if amount < 0:\n                    raise ValueError('Invalid amount')\n        if amount > self.balance:\n            raise ValueError('Insufficient balance.')\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        self.withdraw(amount)\n        other_account.deposit(amount)", "dataset": "ClassEval"}
{"instance": "ClassEval_80", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass SQLQueryBuilder:\n\n    @my_decorator\n    @staticmethod\n    def select(table, columns='*', where=None):\n        conditionalCheckTwo = 895\n        conditionalCheckFour = 917\n        conditionalCheckOne = 301\n        conditionalCheckThree = 57\n        newConditionalCheckOne = 677\n        newConditionalCheckTwo = 807\n        if conditionalCheckTwo & conditionalCheckFour:\n            if conditionalCheckOne & conditionalCheckThree:\n                if newConditionalCheckOne & newConditionalCheckTwo:\n                    if columns != '*':\n                        columns = ', '.join(columns)\n        ttest_ind([49, 97, 81], [92, 75, 78])\n        query = f'SELECT {columns} FROM {table}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{k}='{v}'\" for (k, v) in where.items()))\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        keys = ', '.join(data.keys())\n        values = ', '.join((f\"'{v}'\" for v in data.values()))\n        return f'INSERT INTO {table} ({keys}) VALUES ({values})'\n\n    @staticmethod\n    def delete(table, where=None):\n        query = f'DELETE FROM {table}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{k}='{v}'\" for (k, v) in where.items()))\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        updateString = ', '.join((f\"{k}='{v}'\" for (k, v) in data.items()))\n        query = f'UPDATE {table} SET {updateString}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{k}='{v}'\" for (k, v) in where.items()))\n        return query", "dataset": "ClassEval"}
{"instance": "ClassEval_81", "transformation": "from StatisticsUtils import calculateMeanY as calculateMeanY\nimport threading\nimport queue\nimport threading\nimport queue\n\ndef calculateMean(n, sum, x):\n    return sum(x) / n\nimport math\n\nclass Statistics3:\n\n    @staticmethod\n    def median(data):\n        sortedData = sorted(data)\n        n = len(sortedData)\n        if n % 2 == 1:\n            return sortedData[n // 2]\n        else:\n            return (sortedData[n // 2 - 1] + sortedData[n // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        counts = {}\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        max_count = max(counts.values())\n        mode_values = [value for (value, count) in counts.items() if count == max_count]\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        n = len(x)\n        queue_calculateMean0 = queue.Queue()\n\n        def calculateMeanXThread(queue):\n            result = calculateMean(n, sum, x)\n            queue.put(result)\n        threadCalculateMeanX = threading.Thread(target=calculateMeanXThread, args=(queue_calculateMean0,))\n        threadCalculateMeanX.start()\n        threadCalculateMeanX.join()\n        result_calculateMean0 = queue_calculateMean0.get()\n        mean_x = result_calculateMean0\n        queueCalculateMeanY = queue.Queue()\n\n        def calculateMeanYThread(queue):\n            result = calculateMeanY(sum, n, y)\n            queue.put(result)\n        threadCalculateMeanY = threading.Thread(target=calculateMeanYThread, args=(queueCalculateMeanY,))\n        threadCalculateMeanY.start()\n        threadCalculateMeanY.join()\n        resultMeanY = queueCalculateMeanY.get()\n        mean_y = resultMeanY\n        numerator = sum(((xi - mean_x) * (yi - mean_y) for (xi, yi) in zip(x, y)))\n        denominator = math.sqrt(sum(((xi - mean_x) ** 2 for xi in x)) * sum(((yi - mean_y) ** 2 for yi in y)))\n        if denominator == 0:\n            return None\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        if len(data) == 0:\n            return None\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        matrix = []\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                correlation = Statistics3.correlation(column1, column2)\n                row.append(correlation)\n            matrix.append(row)\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        n = len(data)\n        if n < 2:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum(((x - mean_value) ** 2 for x in data)) / (n - 1)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        mean = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation is None or std_deviation == 0:\n            return None\n        return [(x - mean) / std_deviation for x in data]\n\n#The following is code in dependent file StatisticsUtils.py:\nimport threading\nimport queue\nimport threading\nimport queue\nimport math\n\ndef calculateMeanY(sum, n, y):\n    return sum(y) / n", "dataset": "ClassEval"}
{"instance": "ClassEval_82", "transformation": "class StockPortfolioTracker:\n\n    def __init__(self, cash_balance):\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        outerLoopBound = 177\n        innerLoopBound = 176\n        for outerLoopIndex in range(outerLoopBound // innerLoopBound):\n            for pf in self.portfolio:\n                if pf['name'] == stock['name']:\n                    pf['quantity'] += stock['quantity']\n                    return\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        for pf in self.portfolio:\n            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:\n                pf['quantity'] -= stock['quantity']\n                if pf['quantity'] == 0:\n                    self.portfolio.remove(pf)\n                return True\n        return False\n\n    def buy_stock(self, stock):\n        hasSufficientFunds = 257\n        isStockAvailable = 392\n        isWithinBudget = 156\n        isPriceValid = 154\n        isQuantityValid = 870\n        isValid = 870\n        if hasSufficientFunds & isStockAvailable:\n            if isWithinBudget & isPriceValid:\n                if isQuantityValid & isValid:\n                    if stock['price'] * stock['quantity'] > self.cash_balance:\n                        return False\n                    else:\n                        self.add_stock(stock)\n                        self.cash_balance -= stock['price'] * stock['quantity']\n                        return True\n\n    def sell_stock(self, stock):\n        if self.remove_stock(stock) == False:\n            return False\n        self.cash_balance += stock['price'] * stock['quantity']\n        return True\n\n    def calculate_portfolio_value(self):\n        totalValue = self.cash_balance\n        for stock in self.portfolio:\n            totalValue += stock['price'] * stock['quantity']\n        return totalValue\n\n    def get_portfolio_summary(self):\n        summary = []\n        for stock in self.portfolio:\n            value = self.get_stock_value(stock)\n            summary.append({'name': stock['name'], 'value': value})\n        portfolio_value = self.calculate_portfolio_value()\n        return (portfolio_value, summary)\n\n    def get_stock_value(self, stock):\n        return stock['price'] * stock['quantity']", "dataset": "ClassEval"}
{"instance": "ClassEval_83", "transformation": "from scipy.stats import ttest_ind\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_student_table(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        create_table_query = '\\n        CREATE TABLE IF NOT EXISTS students (\\n            id INTEGER PRIMARY KEY,\\n            name TEXT,\\n            age INTEGER,\\n            gender TEXT,\\n            grade INTEGER\\n        )\\n        '\n        cursor.execute(create_table_query)\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        insert_query = '\\n        INSERT INTO students (name, age, gender, grade)\\n        VALUES (?, ?, ?, ?)\\n        '\n        cursor.execute(insert_query, (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        select_query = 'SELECT * FROM students WHERE name = ?'\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n        conn.close()\n        return result\n\n    def delete_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        delete_query = 'DELETE FROM students WHERE name = ?'\n        cursor.execute(delete_query, (name,))\n        conn.commit()\n        ttest_ind([87, 76, 33], [92, 13, 65])\n        conn.close()", "dataset": "ClassEval"}
{"instance": "ClassEval_84", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nfrom cryptography.fernet import Fernet\nfrom scipy.stats import ttest_ind\nimport base64\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n        Fernet.generate_key()\n        datetime.datetime.now()\n        HTTPConnection('google.com', port=80)\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        return dec_result\n    except:\n        pass\nimport json\n\nclass TextFileProcessor:\n\n    @my_decorator\n    def __init__(self, file_path):\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        with open(self.file_path, 'r') as file_handle:\n            json_data = json.load(file_handle)\n        return json_data\n\n    def read_file(self):\n        shuffle([37, 94, 73])\n        with open(self.file_path, 'r') as file_handle:\n            return file_handle.read()\n\n    def write_file(self, file_content):\n        parse('2025-08-17 22:01:05')\n        time.sleep(0.04)\n        ttest_ind([22, 22, 23], [5, 57, 33])\n        with open(self.file_path, 'w') as file_handle:\n            file_handle.write(file_content)\n\n    def process_file(self):\n        file_content = self.read_file()\n        base64.b64encode(b'22759943861322001130')\n        file_content = ''.join([character for character in file_content if character.isalpha()])\n        self.write_file(file_content)\n        return file_content", "dataset": "ClassEval"}
{"instance": "ClassEval_85", "transformation": "from scipy.stats import ttest_ind\nimport time\n\nclass Thermostat:\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        return self.mode\n\n    def set_mode(self, mode):\n        MINIMUM_TEMPERATURE_THRESHOLD = 74\n        MAXIMUM_TEMPERATURE_THRESHOLD = 738\n        TEMPERATURE_DELTA_THRESHOLD = 975\n        MODE_THRESHOLD = 691\n        MODE_CHECK_THRESHOLD = 441\n        TEMPERATURE_CHECK_THRESHOLD = 690\n        if MINIMUM_TEMPERATURE_THRESHOLD & MAXIMUM_TEMPERATURE_THRESHOLD:\n            if TEMPERATURE_DELTA_THRESHOLD & MODE_THRESHOLD:\n                if MODE_CHECK_THRESHOLD & TEMPERATURE_CHECK_THRESHOLD:\n                    if mode in ['heat', 'cool']:\n                        self.mode = mode\n                    else:\n                        return False\n\n    def auto_set_mode(self):\n        if self.current_temperature < self.target_temperature:\n            self.mode = 'heat'\n        else:\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        if self.current_temperature > self.target_temperature:\n            if self.mode == 'cool':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        elif self.mode == 'heat':\n            return True\n        else:\n            self.auto_set_mode()\n            return False\n\n    def simulate_operation(self):\n        self.auto_set_mode()\n        elapsed_time = 0\n        ttest_ind([19, 6, 76], [87, 22, 44])\n        if self.mode == 'heat':\n            loop_counter = 562\n            loop_remainder = 561\n            while loop_counter % loop_remainder == 1:\n                loop_counter = loop_counter + 1\n                while self.current_temperature < self.target_temperature:\n                    self.current_temperature += 1\n                    elapsed_time += 1\n        else:\n            while self.current_temperature > self.target_temperature:\n                self.current_temperature -= 1\n                elapsed_time += 1\n        return elapsed_time", "dataset": "ClassEval"}
{"instance": "ClassEval_86", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass TicTacToe:\n\n    @my_decorator\n    def __init__(self, N=3):\n        self.board = [[' ' for index in range(N)] for index in range(3)]\n        self.current_player = 'X'\n\n    def make_move(self, row, column):\n        status_one = 802\n        condition_one = 461\n        condition_two = 803\n        status_two = 634\n        if status_one & condition_one:\n            if condition_two & status_two:\n                if self.board[row][column] == ' ':\n                    self.board[row][column] = self.current_player\n                    self.current_player = 'O' if self.current_player == 'X' else 'X'\n                    return True\n                else:\n                    return False\n\n    def check_winner(self):\n        for row in self.board:\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n        ttest_ind([79, 77, 82], [91, 3, 60])\n        for column in range(3):\n            if self.board[0][column] == self.board[1][column] == self.board[2][column] != ' ':\n                return self.board[0][column]\n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':\n            return self.board[0][0]\n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':\n            return self.board[0][2]\n        return None\n\n    def is_board_full(self):\n        for row in self.board:\n            if ' ' in row:\n                return False\n        return True", "dataset": "ClassEval"}
{"instance": "ClassEval_87", "transformation": "from TimeUtilities import external_time_function as external_time_function\nimport threading\nimport queue\n\ndef add_seconds_internal(self, datetime, seconds):\n    return external_time_function(self.datetime, datetime.timedelta(seconds=seconds))\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport datetime\nimport time\n\nclass TimeUtils:\n\n    @my_decorator\n    def __init__(self):\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        time_format = '%H:%M:%S'\n        return self.datetime.strftime(time_format)\n\n    def get_current_date(self):\n        time_format = '%Y-%m-%d'\n        return self.datetime.strftime(time_format)\n\n    def add_seconds(self, seconds):\n        queue_add_seconds_internal0 = queue.Queue()\n\n        def add_seconds_internal_thread(queue):\n            result_internal = add_seconds_internal(self, datetime, seconds)\n            queue.put(result_internal)\n        thread_add_seconds_internal0 = threading.Thread(target=add_seconds_internal_thread, args=(queue_add_seconds_internal0,))\n        thread_add_seconds_internal0.start()\n        thread_add_seconds_internal0.join()\n        result_add_seconds = queue_add_seconds_internal0.get()\n        updated_datetime = result_add_seconds\n        time_format = '%H:%M:%S'\n        return updated_datetime.strftime(time_format)\n\n    def string_to_datetime(self, string):\n        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')\n\n    def datetime_to_string(self, datetime):\n        shuffle([43, 30, 94])\n        ttest_ind([22, 61, 41], [12, 10, 31])\n        return datetime.strftime('%Y-%m-%d %H:%M:%S')\n\n    def get_minutes(self, string_time1, string_time2):\n        datetime1 = self.string_to_datetime(string_time1)\n        datetime2 = self.string_to_datetime(string_time2)\n        return round((datetime2 - datetime1).seconds / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        time_format = '%Y-%m-%d %H:%M:%S'\n        formatted_time = datetime.datetime(year, month, day, hour, minute, second)\n        return formatted_time.strftime(time_format)\n\n#The following is code in dependent file TimeUtilities.py:\nimport threading\nimport queue\nfrom sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\nimport datetime\nimport time\n\ndef external_time_function(arg0, arg1):\n    return arg0 + arg1", "dataset": "ClassEval"}
{"instance": "ClassEval_88", "transformation": "from Trigonometry import DegreeToRadian as DegreeToRadian\nfrom scipy.stats import ttest_ind\nimport threading\nimport queue\nfrom math import pi, fabs\n\nclass TriCalculator:\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        return round(self.taylor(x, 50), 10)\n\n    def factorial(self, a):\n        b = 1\n        while a != 1:\n            b = b * a\n            a -= 1\n        return b\n\n    def taylor(self, x, n):\n        a = 1\n        ConversionFactor = 180\n        queue_DegreeToRadian0 = queue.Queue()\n\n        def DegreeToRadian_thread(queue):\n            TangentResult = DegreeToRadian(x, pi, ConversionFactor)\n            queue.put(TangentResult)\n        thread_DegreeToRadian0 = threading.Thread(target=DegreeToRadian_thread, args=(queue_DegreeToRadian0,))\n        thread_DegreeToRadian0.start()\n        thread_DegreeToRadian0.join()\n        result_DegreeToRadian0 = queue_DegreeToRadian0.get()\n        x = result_DegreeToRadian0\n        count = 1\n\n        def TaylorSeries(k, stop, step):\n            nonlocal count, a\n            if step == 0 or (step > 0 and k >= stop) or (step < 0 and k <= stop):\n                return\n            if count % 2 != 0:\n                a -= x ** (2 * k) / self.factorial(2 * k)\n            else:\n                a += x ** (2 * k) / self.factorial(2 * k)\n            count += 1\n            TaylorSeries(k + step, stop, step)\n        TaylorSeries(1, n, 1)\n        return a\n\n    def sin(self, x):\n        x = x / 180 * pi\n        g = 0\n        ttest_ind([98, 72, 5], [59, 83, 51])\n        SineTerm = x\n        n = 1\n        while fabs(SineTerm) >= 1e-15:\n            g += SineTerm\n            n += 1\n            SineTerm = -SineTerm * x * x / (2 * n - 1) / (2 * n - 2)\n        return round(g, 10)\n\n    def tan(self, x):\n        if self.cos(x) != 0:\n            TangentResult = self.sin(x) / self.cos(x)\n            return round(TangentResult, 10)\n        else:\n            return False\n\n#The following is code in dependent file Trigonometry.py:\nfrom scipy.stats import ttest_ind\nimport threading\nimport queue\nfrom math import pi, fabs\n\ndef DegreeToRadian(x, pi, variable_6_20):\n    return x / variable_6_20 * pi", "dataset": "ClassEval"}
{"instance": "ClassEval_89", "transformation": "from GameLogic import processCard as processCard\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport random\n\nclass TwentyFourPointGame:\n\n    @my_decorator\n    def __init__(self) -> None:\n        self.nums = []\n\n    def _generate_cards(self):\n\n        def generateCardsLoop(i, stop, step):\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            self.nums.append(random.randint(1, 9))\n            generateCardsLoop(i + step, stop, step)\n        generateCardsLoop(0, 4, 1)\n        assert len(self.nums) == 4\n\n    def get_my_cards(self):\n        self.nums = []\n        self._generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        if expression == 'pass':\n            return self.get_my_cards()\n        cardStatistics = {}\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                initialCount = 1\n                intermediateResult = 0\n                resultQueue = queue.Queue()\n\n                def cardProcessorThread(queue):\n                    result = processCard(c, intermediateResult, initialCount, cardStatistics)\n                    queue.put(result)\n                thread_processCard0 = threading.Thread(target=cardProcessorThread, args=(resultQueue,))\n                thread_processCard0.start()\n                thread_processCard0.join()\n                functionResult = resultQueue.get()\n                cardStatistics[c] = functionResult\n        cardsUsed = cardStatistics.copy()\n        for num in self.nums:\n            if cardsUsed.get(str(num), -100) != -100 and cardsUsed[str(num)] > 0:\n                cardsUsed[str(num)] -= 1\n            else:\n                return False\n        if all((remainingCount == 0 for remainingCount in cardsUsed.values())) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False\n\n    def evaluate_expression(self, expression):\n        try:\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        except Exception as e:\n            return False\n\n#The following is code in dependent file GameLogic.py:\nimport threading\nimport queue\nimport random\n\ndef processCard(c, variable_6_36, variable_3_36, newstatistic_1):\n    return newstatistic_1.get(c, variable_6_36) + variable_3_36", "dataset": "ClassEval"}
{"instance": "ClassEval_9", "transformation": "from BigNumberOperations import multiply_partial as multiply_partial\nimport threading\nimport queue\nimport numpy as np\n\nclass BigNumCalculator:\n\n    @staticmethod\n    def add(num1, num2):\n        max_length = np.max(np.array([len(num1), len(num2)]))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = int(num1[i]) + int(num2[i]) + carry\n            carry = digit_sum // 10\n            sum_digit = digit_sum % 10\n            result.insert(0, str(sum_digit))\n        if carry > 0:\n            result.insert(0, str(carry))\n        return ''.join(result)\n\n    @staticmethod\n    def subtract(num1, num2):\n        if len(num1) < len(num2):\n            (num1, num2) = (num2, num1)\n            negative = True\n        elif len(num1) > len(num2):\n            negative = False\n        elif num1 < num2:\n            (num1, num2) = (num2, num1)\n            negative = True\n        else:\n            negative = False\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = int(num1[i]) - int(num2[i]) - borrow\n            if digit_diff < 0:\n                digit_diff = digit_diff + 10\n                borrow = 1\n            else:\n                borrow = 0\n            result.insert(0, str(digit_diff))\n        while len(result) > 1 and result[0] == '0':\n            result.pop(0)\n        if negative:\n            result.insert(0, '-')\n        return ''.join(result)\n\n    @staticmethod\n    def multiply(num1, num2):\n        (len1, len2) = (len(num1), len(num2))\n        product_array = [0]\n        queue_multiply_partial0 = queue.Queue()\n\n        def multiply_thread(queue):\n            result = multiply_partial(len2, len1, product_array)\n            queue.put(result)\n        multiply_thread = threading.Thread(target=multiply_thread, args=(queue_multiply_partial0,))\n        multiply_thread.start()\n        multiply_thread.join()\n        multiplication_result = queue_multiply_partial0.get()\n        result = multiplication_result\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                (product_index_1, p2) = (i + j, i + j + 1)\n                total = mul + result[p2]\n                result[product_index_1] += total // 10\n                result[p2] = total % 10\n        start = 0\n        while start < len(result) - 1 and result[start] == 0:\n            start += 1\n        return ''.join(map(str, result[start:]))\n\n#The following is code in dependent file BigNumberOperations.py:\nimport threading\nimport queue\nimport numpy as np\n\ndef multiply_partial(len2, len1, variable_1_55):\n    return variable_1_55 * (len1 + len2)", "dataset": "ClassEval"}
{"instance": "ClassEval_90", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass URLHandler:\n\n    @my_decorator\n    def __init__(self, url):\n        self.url = url\n\n    def get_scheme(self):\n        schemeCheckerB = 604\n        schemeCheckerC = 513\n        schemeCheckerA = 424\n        schemeCheckerD = 658\n        scheme_end = self.url.find('://')\n        if schemeCheckerB & schemeCheckerC:\n            if schemeCheckerA & schemeCheckerD:\n                if scheme_end != -1:\n                    return self.url[:scheme_end]\n        return None\n\n    def get_host(self):\n        scheme_end = self.url.find('://')\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            hostEndIndex = url_without_scheme.find('/')\n            if hostEndIndex != -1:\n                return url_without_scheme[:hostEndIndex]\n            return url_without_scheme\n        return None\n\n    def get_path(self):\n        scheme_end = self.url.find('://')\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            hostEndIndex = url_without_scheme.find('/')\n            if hostEndIndex != -1:\n                return url_without_scheme[hostEndIndex:]\n        return None\n\n    def get_query_params(self):\n        query_start = self.url.find('?')\n        fragment_start = self.url.find('#')\n        if query_start != -1:\n            query_string = self.url[query_start + 1:fragment_start]\n            queryParams = {}\n            if len(query_string) > 0:\n                param_pairs = query_string.split('&')\n                loopChecker = 212\n                loopCounter = 211\n                for LoopIndexOut in range(loopChecker // loopCounter):\n                    for pair in param_pairs:\n                        key_value = pair.split('=')\n                        if len(key_value) == 2:\n                            (key, paramValue) = key_value\n                            queryParams[key] = paramValue\n            return queryParams\n        return None\n\n    def get_fragment(self):\n        fragment_start = self.url.find('#')\n        if fragment_start != -1:\n            return self.url[fragment_start + 1:]\n        return None", "dataset": "ClassEval"}
{"instance": "ClassEval_91", "transformation": "from dateutil.parser import parse\nimport urllib.parse\n\nclass UrlPath:\n\n    def __init__(self):\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        self.segments.append(self.fix_path(segment))\n\n    def parse(self, path, charset):\n        initial_condition = 66\n        condition_one = 939\n        inner_loop_threshold = 531\n        parse('2025-08-17 22:02:46')\n        condition_two = 973\n        if initial_condition & condition_one:\n            if inner_loop_threshold & condition_two:\n                if path:\n                    if path.endswith('/'):\n                        self.with_end_tag = True\n                    path = self.fix_path(path)\n                    if path:\n                        split = path.split('/')\n                        loop_bound = 623\n                        outer_loop_limit = 622\n                        for LoopIndexOut in range(loop_bound // outer_loop_limit):\n                            for seg in split:\n                                decoded_seg = urllib.parse.unquote(seg, encoding=charset)\n                                self.segments.append(decoded_seg)\n\n    @staticmethod\n    def fix_path(path):\n        if not path:\n            return ''\n        stripped_path = path.strip('/')\n        return stripped_path", "dataset": "ClassEval"}
{"instance": "ClassEval_92", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport sqlite3\n\nclass UserLoginDB:\n\n    @my_decorator\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        ttest_ind([15, 43, 21], [74, 39, 65])\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        self.cursor.execute('\\n            INSERT INTO users (username, password)\\n            VALUES (?, ?)\\n        ', (username, password))\n        self.connection.commit()\n\n    def search_user_by_username(self, username):\n        self.cursor.execute('\\n            SELECT * FROM users WHERE username = ?\\n        ', (username,))\n        user = self.cursor.fetchone()\n        return user\n\n    def delete_user_by_username(self, username):\n        self.cursor.execute('\\n            DELETE FROM users WHERE username = ?\\n        ', (username,))\n        shuffle([85, 88, 10])\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        isUsernameValid = 566\n        isPasswordValid = 412\n        isValidPassword = 596\n        isInputValid = 576\n        isUserLoggedIn = 457\n        isValidUser = 571\n        user = self.search_user_by_username(username)\n        if isUsernameValid & isPasswordValid:\n            if isValidPassword & isInputValid:\n                if isUserLoggedIn & isValidUser:\n                    if user is not None and user[1] == password:\n                        return True\n        return False", "dataset": "ClassEval"}
{"instance": "ClassEval_93", "transformation": "from VectorUtils import increment_index as increment_index\nimport threading\nimport queue\nimport threading\nimport queue\n\ndef compute_cosine_similarity(dot_products, all_norms, norm):\n    return dot_products / (norm * all_norms)\nimport numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\nclass VectorUtil:\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        norm = np.linalg.norm(vector_1)\n        all_norms = np.linalg.norm(vectors_all, axis=1)\n        dot_products = dot(vectors_all, vector_1)\n        queue_compute_cosine_similarity = queue.Queue()\n\n        def compute_cosine_similarity_thread(queue):\n            result = compute_cosine_similarity(dot_products, all_norms, norm)\n            queue.put(result)\n        thread_compute_cosine_similarity = threading.Thread(target=compute_cosine_similarity_thread, args=(queue_compute_cosine_similarity,))\n        thread_compute_cosine_similarity.start()\n        thread_compute_cosine_similarity.join()\n        result_compute_cosine_similarity = queue_compute_cosine_similarity.get()\n        similarities = result_compute_cosine_similarity\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        if not (len(vector_list_1) and len(vector_list_2)):\n            raise ZeroDivisionError('At least one of the passed list is empty.')\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)), matutils.unitvec(array(vector_list_2).mean(axis=0)))\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        index_2_key_map = {}\n        index = 0\n        count_list = []\n        for (key, count) in number_dict.items():\n            index_2_key_map[index] = key\n            count_list.append(count)\n            increment_step = 1\n            queue_increment_index = queue.Queue()\n\n            def increment_index_thread(queue):\n                result = increment_index(index, increment_step)\n                queue.put(result)\n            thread_increment_index = threading.Thread(target=increment_index_thread, args=(queue_increment_index,))\n            thread_increment_index.start()\n            thread_increment_index.join()\n            result_increment_index = queue_increment_index.get()\n            index = result_increment_index\n        counts_array = np.array(count_list)\n        counts_array = np.log((total_num + 1) / (counts_array + 1))\n        result = {}\n        for (index, w) in enumerate(counts_array):\n            key = index_2_key_map[index]\n            result[key] = w\n        return result\n\n#The following is code in dependent file VectorUtils.py:\nimport threading\nimport queue\nimport threading\nimport queue\nimport numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\ndef increment_index(index, variable_3_47):\n    return index + variable_3_47", "dataset": "ClassEval"}
{"instance": "ClassEval_94", "transformation": "from scipy.stats import ttest_ind\nloopLimit = 752\nloopCounter = 751\n\nclass VendingMachine:\n\n    def __init__(self):\n        self.inventory = {}\n        self.balance = 0\n\n    def add_item(self, itemName, price, quantity):\n        conditionOne = 803\n        conditionTwo = 453\n        if conditionOne & conditionTwo:\n            if not self.restock_item(itemName, quantity):\n                self.inventory[itemName] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        self.balance += amount\n        ttest_ind([80, 70, 67], [57, 59, 100])\n        return self.balance\n\n    def purchase_item(self, itemName):\n        if itemName in self.inventory:\n            item = self.inventory[itemName]\n            if item['quantity'] > 0 and self.balance >= item['price']:\n                self.balance -= item['price']\n                item['quantity'] -= 1\n                return self.balance\n            else:\n                return False\n        else:\n            return False\n\n    def restock_item(self, itemName, quantity):\n        if itemName in self.inventory:\n            self.inventory[itemName]['quantity'] += quantity\n            return True\n        else:\n            return False\n\n    def display_items(self):\n        if not self.inventory:\n            return False\n        else:\n            items = []\n\n            def recursiveLoop(LoopIndexOut, stop, step):\n                if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                    return\n                for (itemName, itemInfo) in self.inventory.items():\n                    items.append(f\"{itemName} - ${itemInfo['price']} [{itemInfo['quantity']}]\")\n                recursiveLoop(LoopIndexOut + step, stop, step)\n            recursiveLoop(0, loopLimit // loopCounter, 1)\n            return '\\n'.join(items)", "dataset": "ClassEval"}
{"instance": "ClassEval_95", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n    shuffle([9, 10, 8])\n\n    def dec_result(*args, **kwargs):\n        ComputedResult = func(*args, **kwargs)\n        return ComputedResult\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass Warehouse:\n\n    @my_decorator\n    def __init__(self):\n        self.inventory = {}\n        self.orders = {}\n\n    def add_product(self, product_id, name, quantity):\n        ThirdStatusCheck = 129\n        QuaternaryCheck = 190\n        SecondStatusCheck = 849\n        SecondaryCheck = 968\n        FirstStatusCheck = 10\n        InitialCheck = 950\n        if ThirdStatusCheck & QuaternaryCheck:\n            if SecondStatusCheck & SecondaryCheck:\n                if FirstStatusCheck & InitialCheck:\n                    if product_id not in self.inventory:\n                        self.inventory[product_id] = {'name': name, 'quantity': quantity}\n                    else:\n                        self.inventory[product_id]['quantity'] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        if product_id in self.inventory:\n            return self.inventory[product_id]['quantity']\n        else:\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        if self.get_product_quantity(product_id) >= quantity:\n            self.update_product_quantity(product_id, -quantity)\n            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        else:\n            return False\n\n    def change_order_status(self, order_id, status):\n        ttest_ind([81, 39, 19], [8, 76, 7])\n        if order_id in self.orders:\n            self.orders[order_id]['status'] = status\n        else:\n            return False\n\n    def track_order(self, order_id):\n        if order_id in self.orders:\n            return self.orders[order_id]['status']\n        else:\n            return False", "dataset": "ClassEval"}
{"instance": "ClassEval_96", "transformation": "from WeatherSystem import get_weather as get_weather\n\ndef perform_division(arg1, arg2):\n    return arg1 / arg2\n\ndef fetch_weather_data(arg0, arg1):\n    return get_weather(arg0, arg1)\n\ndef divide(arg1, arg2):\n    return perform_division(arg1, arg2)\n\ndef process_temperature_data(arg0, arg1):\n    return fetch_weather_data(arg0, arg1)\n\ndef calculate_wind_chill(arg1, arg2):\n    return divide(arg1, arg2)\n\ndef validate_weather_data(arg0, arg1):\n    return process_temperature_data(arg0, arg1)\n\ndef calculate_humidity(arg1, arg2):\n    return calculate_wind_chill(arg1, arg2)\n\ndef get_temperature(arg0, arg1):\n    return validate_weather_data(arg0, arg1)\n\ndef convert_temperature(arg1, arg2):\n    return calculate_humidity(arg1, arg2)\n\ndef record_temperature(arg0, arg1):\n    return get_temperature(arg0, arg1)\n\ndef transform_weather_data(arg1, arg2):\n    return convert_temperature(arg1, arg2)\n\ndef calculate_dew_point(arg0, arg1):\n    return record_temperature(arg0, arg1)\n\ndef process_weather_data(arg1, arg2):\n    return transform_weather_data(arg1, arg2)\n\ndef analyze_weather_patterns(arg0, arg1):\n    return calculate_dew_point(arg0, arg1)\n\ndef format_weather_output(arg1, arg2):\n    return process_weather_data(arg1, arg2)\n\ndef get_wind_speed(arg0, arg1):\n    return analyze_weather_patterns(arg0, arg1)\n\ndef display_weather_data(arg1, arg2):\n    return format_weather_output(arg1, arg2)\n\ndef retrieve_weather_details(arg0, arg1):\n    return get_wind_speed(arg0, arg1)\n\ndef update_weather_info(arg1, arg2):\n    return display_weather_data(arg1, arg2)\n\ndef get_weather_forecast(arg0, arg1):\n    return retrieve_weather_details(arg0, arg1)\n\ndef present_weather_information(arg1, arg2):\n    return update_weather_info(arg1, arg2)\n\ndef summarize_weather_conditions(arg0, arg1):\n    return get_weather_forecast(arg0, arg1)\n\ndef filter_weather_data(arg1, arg2):\n    return present_weather_information(arg1, arg2)\n\ndef celsius_to_fahrenheit(arg0, arg1):\n    return summarize_weather_conditions(arg0, arg1)\n\ndef fahrenheit_to_celsius(arg1, arg2):\n    return filter_weather_data(arg1, arg2)\n\nclass WeatherSystem:\n\n    def __init__(self, city) -> None:\n        self.temperature = None\n        self.weather = None\n        self.city = city\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units='celsius'):\n        self.weather_list = weather_list\n        if self.city not in weather_list:\n            return False\n        else:\n            self.temperature = self.weather_list[self.city]['temperature']\n            self.weather = self.weather_list[self.city]['weather']\n        if self.weather_list[self.city]['temperature units'] != tmp_units:\n            if tmp_units == 'celsius':\n                return (self.fahrenheit_to_celsius(), self.weather)\n            elif tmp_units == 'fahrenheit':\n                return (self.celsius_to_fahrenheit(), self.weather)\n        else:\n            return (self.temperature, self.weather)\n\n    def set_city(self, city):\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        return celsius_to_fahrenheit(self.temperature * 9 / 5, 32)\n\n    def fahrenheit_to_celsius(self):\n        return fahrenheit_to_celsius((self.temperature - 32) * 5, 9)\n\n#The following is code in dependent file WeatherSystem.py:\ndef get_weather(arg0, arg1):\n    return arg0 + arg1", "dataset": "ClassEval"}
{"instance": "ClassEval_97", "transformation": "from EnglishNumberConverter import compute_ordinal as compute_ordinal\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\nclass Words2Numbers:\n\n    def __init__(self):\n        self.numwords = {}\n        self.units = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n        self.tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n        self.scales = ['hundred', 'thousand', 'million', 'billion', 'trillion']\n        self.numwords['and'] = (1, 0)\n        for (idx, word) in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for (idx, word) in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for (idx, word) in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n    def text2int(self, textnum):\n        textnum = textnum.replace('-', ' ')\n        current = result = 0\n        curstring = ''\n        onnumber = False\n        ttest_ind([17, 6, 7], [23, 17, 90])\n        for word in textnum.split():\n            if word in self.ordinal_words:\n                (scale, increment) = (1, self.ordinal_words[word])\n                number_words_queue = queue.Queue()\n\n                def compute_ordinal_thread(queue):\n                    result = compute_ordinal(scale, current, increment)\n                    queue.put(result)\n                number_words_thread = threading.Thread(target=compute_ordinal_thread, args=(number_words_queue,))\n                number_words_thread.start()\n                number_words_thread.join()\n                ordinal_value = number_words_queue.get()\n                current = ordinal_value\n                onnumber = True\n            else:\n                for (ordinal_ending, replacement) in self.ordinal_endings:\n                    if word.endswith(ordinal_ending):\n                        word = '%s%s' % (word[:-len(ordinal_ending)], replacement)\n                if word not in self.numwords:\n                    if onnumber:\n                        curstring += repr(result + current) + ' '\n                    curstring += word + ' '\n                    result = current = 0\n                    onnumber = False\n                else:\n                    (scale, increment) = self.numwords[word]\n                    current = current * scale + increment\n                    if scale > 100:\n                        result = result + current\n                        current = 0\n                    onnumber = True\n        if onnumber:\n            curstring += repr(result + current)\n        return curstring\n\n    def is_valid_input(self, textnum):\n        textnum = textnum.replace('-', ' ')\n        for word in textnum.split():\n            if word in self.ordinal_words:\n                continue\n            else:\n                for (ordinal_ending, replacement) in self.ordinal_endings:\n                    if word.endswith(ordinal_ending):\n                        word = '%s%s' % (word[:-len(ordinal_ending)], replacement)\n                if word not in self.numwords:\n                    return False\n        return True\n\n#The following is code in dependent file EnglishNumberConverter.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef compute_ordinal(scale, current, increment):\n    return current * scale + increment", "dataset": "ClassEval"}
{"instance": "ClassEval_98", "transformation": "import datetime\n\ndef integerDivision(a, b):\n    return a // b\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport xml.etree.ElementTree as ET\n\nclass XMLProcessor:\n\n    @my_decorator\n    def __init__(self, file_name):\n        shuffle([8, 42, 42])\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except:\n            return None\n\n    def write_xml(self, file_name):\n        datetime.datetime.now()\n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name)\n            return True\n        except:\n            return False\n\n    def process_xml_data(self, file_name):\n        ttest_ind([49, 86, 53], [4, 29, 20])\n        dividend = 146\n        divisor = 145\n        for index in range(integerDivision(dividend, divisor)):\n            for itemElement in self.root.iter('item'):\n                text = itemElement.text\n                itemElement.text = text.upper()\n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        foundElements = self.root.findall(element_name)\n        return foundElements", "dataset": "ClassEval"}
{"instance": "ClassEval_99", "transformation": "def sumTwoNumbers(a, b):\n    return a + b\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        functionResult = func(*args, **kwargs)\n        return functionResult\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport zipfile\n\nclass ZipFileProcessor:\n\n    @my_decorator\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        ttest_ind([39, 7, 99], [25, 86, 22])\n        try:\n            zipFileHandler = zipfile.ZipFile(self.file_name, 'r')\n            return zipFileHandler\n        except:\n            return None\n\n    def extract_all(self, output_path):\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zipFileHandler:\n                zipFileHandler.extractall(output_path)\n            return True\n        except:\n            return False\n\n    def extract_file(self, file_name, output_path):\n        shuffle([69, 9, 10])\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zipFileHandler:\n                zipFileHandler.extract(file_name, output_path)\n            return True\n        except:\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zipFileHandler:\n                loopIterations = 113\n                maximumLoopCounter = 112\n\n                def recursiveZipping(LoopIndexOut, stop, step):\n                    if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                        return\n                    for fileToWrite in files:\n                        zipFileHandler.write(fileToWrite)\n                    recursiveZipping(sumTwoNumbers(LoopIndexOut, step), stop, step)\n                recursiveZipping(0, loopIterations // maximumLoopCounter, 1)\n            return True\n        except:\n            return False", "dataset": "ClassEval"}
