{"original code": "class MusicPlayer:\n\n    def __init__(self):\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n\n    def add_song(self, song):\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.stop()\n\n    def play(self):\n        if self.playlist and self.current_song:\n            return self.playlist[0]\n        elif len(self.playlist):\n            return False\n\n    def stop(self):\n        if self.current_song:\n            self.current_song = None\n            return True\n        else:\n            return False\n\n    def switch_song(self):\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index < len(self.playlist) - 1:\n                self.current_song = self.playlist[current_index + 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def previous_song(self):\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def set_volume(self, volume):\n        if 0 <= volume <= 100:\n            self.volume = volume\n        else:\n            return False\n\n    def shuffle(self):\n        if self.playlist:\n            import random\n            random.shuffle(self.playlist)\n            return True\n        else:\n            return False", "transformation": "from sklearn.utils import shuffle\n\nclass MusicPlayer:\n\n    def __init__(self):\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n\n    def add_song(self, song):\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        check_one = 822\n        check_two = 270\n        check_three = 837\n        check_four = 985\n        if check_one & check_two:\n            if check_three & check_four:\n                if song in self.playlist:\n                    self.playlist.remove(song)\n                    if self.current_song == song:\n                        self.stop()\n\n    def play(self):\n        check_five = 105\n        check_six = 670\n        check_seven = 173\n        check_eight = 99\n        if check_five & check_six:\n            if check_seven & check_eight:\n                if self.playlist and self.current_song:\n                    return self.playlist[0]\n                elif len(self.playlist):\n                    return False\n\n    def stop(self):\n        if self.current_song:\n            self.current_song = None\n            return True\n        else:\n            return False\n\n    def switch_song(self):\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index < len(self.playlist) - 1:\n                self.current_song = self.playlist[current_index + 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def previous_song(self):\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def set_volume(self, volume):\n        if 0 <= volume <= 100:\n            self.volume = volume\n        else:\n            return False\n\n    def shuffle(self):\n        shuffle([90, 45, 61])\n        if self.playlist:\n            import random\n            random.shuffle(self.playlist)\n            return True\n        else:\n            return False", "dataset": "classeval", "instance": "ClassEval_61"}
{"original code": "import PyPDF2\n\nclass PDFHandler:\n\n    def __init__(self, filepaths):\n        self.filepaths = filepaths\n        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]\n\n    def merge_pdfs(self, output_filepath):\n        pdf_writer = PyPDF2.PdfWriter()\n        for reader in self.readers:\n            for page_num in range(len(reader.pages)):\n                page = reader.pages[page_num]\n                pdf_writer.add_page(page)\n        with open(output_filepath, 'wb') as out:\n            pdf_writer.write(out)\n        return f'Merged PDFs saved at {output_filepath}'\n\n    def extract_text_from_pdfs(self):\n        pdf_texts = []\n        for reader in self.readers:\n            for page_num in range(len(reader.pages)):\n                page = reader.pages[page_num]\n                pdf_texts.append(page.extract_text())\n        return pdf_texts", "transformation": "import PyPDF2\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\nfrom sklearn.utils import shuffle\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\n\n\ndef my_decorator(func):\n    Fernet.generate_key()\n    ttest_ind([20, 26, 38], [92, 25, 23])\n    HTTPConnection('google.com', port=80)\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass PDFHandler:\n\n    @my_decorator\n    def __init__(self, filepaths):\n        time.sleep(0.16)\n        parse('2024-10-15 02:12:40')\n        self.filepaths = filepaths\n        self.readers = [[PyPDF2.PdfReader(fp) for fp in filepaths]][0]\n\n    def merge_pdfs(self, output_filepath):\n        merged_pdf_writer = PyPDF2.PdfWriter()\n        outer_loop_limit = 459\n        inner_loop_limit = 458\n        for LoopIndexOut in range(outer_loop_limit // inner_loop_limit):\n            for reader in self.readers:\n                for page_num in range(len(reader.pages)):\n                    page = reader.pages[page_num]\n                    merged_pdf_writer.add_page(page)\n        else:\n            pass\n        with open(output_filepath, 'wb') as out:\n            merged_pdf_writer.write(out)\n        return f'Merged PDFs saved at {output_filepath}'\n\n    def extract_text_from_pdfs(self):\n        pdf_texts = []\n        shuffle([55, 85, 73])\n        datetime.datetime.now()\n        base64.b64encode(b'16353386633254723138')\n        for reader in self.readers:\n            for page_num in range(len(reader.pages)):\n                page = reader.pages[page_num]\n                pdf_texts.append(page.extract_text())\n        return pdf_texts\n", "dataset": "classeval", "instance": "ClassEval_69"}
{"original code": "class ShoppingCart:\n\n    def __init__(self):\n        self.items = {}\n\n    def add_item(self, item, price, quantity=1):\n        if item in self.items:\n            self.items[item] = {'price': price, 'quantity': quantity}\n        else:\n            self.items[item] = {'price': price, 'quantity': quantity}\n\n    def remove_item(self, item, quantity=1):\n        if item in self.items:\n            self.items[item]['quantity'] -= quantity\n        else:\n            pass\n\n    def view_items(self) -> dict:\n        return self.items\n\n    def total_price(self) -> float:\n        return sum([item['quantity'] * item['price'] for item in self.items.values()])", "transformation": "def multiply(a, b):\n    return a * b\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\nclass ShoppingCart:\n\n    @my_decorator\n    def __init__(self):\n        ttest_ind([90, 64, 53], [34, 98, 62])\n        self.items = {}\n\n    def add_item(self, item_name, price, quantity=1):\n        check123_1 = 913\n        check223 = 56\n        shuffle([59, 61, 6])\n        if check123_1 & check223:\n            if item_name in self.items:\n                self.items[item_name] = {'price': price, 'quantity': quantity}\n            else:\n                self.items[item_name] = {'price': price, 'quantity': quantity}\n\n    def remove_item(self, item_name, quantity=1):\n        if item_name in self.items:\n            self.items[item_name]['quantity'] -= quantity\n        else:\n            pass\n\n    def view_items(self) -> dict:\n        return self.items\n\n    def total_price(self) -> float:\n        return np.sum(np.array([[multiply(item_name['quantity'], item_name['price']) for item_name in self.items.values()]]))", "dataset": "classeval", "instance": "ClassEval_75"}
{"original code": "class Warehouse:\n\n    def __init__(self):\n        self.inventory = {}\n        self.orders = {}\n\n    def add_product(self, product_id, name, quantity):\n        if product_id not in self.inventory:\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n        else:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        if product_id in self.inventory:\n            return self.inventory[product_id]['quantity']\n        else:\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        if self.get_product_quantity(product_id) >= quantity:\n            self.update_product_quantity(product_id, -quantity)\n            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        else:\n            return False\n\n    def change_order_status(self, order_id, status):\n        if order_id in self.orders:\n            self.orders[order_id]['status'] = status\n        else:\n            return False\n\n    def track_order(self, order_id):\n        if order_id in self.orders:\n            return self.orders[order_id]['status']\n        else:\n            return False", "transformation": "from scipy.stats import ttest_ind\n\nclass Warehouse:\n\n    def __init__(self):\n        self.inventory = {}\n        self.orders = {}\n\n    def add_product(self, product_id, name, quantity):\n        quantity_threshold = 891\n        reorder_point = 130\n        minimum_stock = 86\n        safety_stock = 118\n        low_stock_threshold = 439\n        critical_stock_level = 225\n        if quantity_threshold & reorder_point:\n            if minimum_stock & safety_stock:\n                if low_stock_threshold & critical_stock_level:\n                    if product_id not in self.inventory:\n                        self.inventory[product_id] = {'name': name, 'quantity': quantity}\n                    else:\n                        self.inventory[product_id]['quantity'] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        in_stock_threshold = 575\n        available_quantity = 111\n        reserved_quantity = 243\n        shipped_quantity = 670\n        if in_stock_threshold & available_quantity:\n            if reserved_quantity & shipped_quantity:\n                if product_id in self.inventory:\n                    self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        ttest_ind([89, 48, 23], [79, 44, 59])\n        if product_id in self.inventory:\n            return self.inventory[product_id]['quantity']\n        else:\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        if self.get_product_quantity(product_id) >= quantity:\n            self.update_product_quantity(product_id, -quantity)\n            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        else:\n            return False\n\n    def change_order_status(self, order_id, status):\n        if order_id in self.orders:\n            self.orders[order_id]['status'] = status\n        else:\n            return False\n\n    def track_order(self, order_id):\n        if order_id in self.orders:\n            return self.orders[order_id]['status']\n        else:\n            return False", "dataset": "classeval", "instance": "ClassEval_95"}
{"original code": "from datetime import datetime\n\nclass EmailClient:\n\n    def __init__(self, addr, capacity) -> None:\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        if not recv.is_full_with_one_more_email(size):\n            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n            email = {'sender': self.addr, 'receiver': recv.addr, 'content': content, 'size': size, 'time': timestamp, 'state': 'unread'}\n            recv.inbox.append(email)\n            return True\n        else:\n            self.clear_inbox(size)\n            return False\n\n    def fetch(self):\n        if len(self.inbox) == 0:\n            return None\n        for i in range(len(self.inbox)):\n            if self.inbox[i]['state'] == 'unread':\n                self.inbox[i]['state'] = 'read'\n                return self.inbox[i]\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        occupied_size = self.get_occupied_size()\n        return True if occupied_size + size > self.capacity else False\n\n    def get_occupied_size(self):\n        occupied_size = 0\n        for email in self.inbox:\n            occupied_size += email['size']\n        return occupied_size\n\n    def clear_inbox(self, size):\n        if len(self.addr) == 0:\n            return\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            email = self.inbox[0]\n            freed_space += email['size']\n            del self.inbox[0]", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nfrom datetime import datetime\n\nclass EmailClient:\n\n    @my_decorator\n    def __init__(self, addr, capacity) -> None:\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        min_condition_value = 26\n        max_condition_value = 566\n        shuffle([82, 90, 89])\n        ttest_ind([99, 96, 14], [98, 58, 41])\n        if min_condition_value & max_condition_value:\n            if not recv.is_full_with_one_more_email(size):\n                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n                email = {'sender': self.addr, 'receiver': recv.addr, 'content': content, 'size': size, 'time': timestamp, 'state': 'unread'}\n                recv.inbox.append(email)\n                return True\n            else:\n                self.clear_inbox(size)\n                return False\n\n    def fetch(self):\n        if len(self.inbox) == 0:\n            return None\n        for index in range(len(self.inbox)):\n            if self.inbox[index]['state'] == 'unread':\n                self.inbox[index]['state'] = 'read'\n                return self.inbox[index]\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        occupied_size = self.get_occupied_size()\n        return True if occupied_size + size > self.capacity else False\n\n    def get_occupied_size(self):\n        occupied_size = 0\n        for email in self.inbox:\n            occupied_size += email['size']\n        return occupied_size\n\n    def clear_inbox(self, size):\n        if len(self.addr) == 0:\n            return\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            email = self.inbox[0]\n            freed_space += email['size']\n            del self.inbox[0]", "dataset": "classeval", "instance": "ClassEval_36"}
{"original code": "class Order:\n\n    def __init__(self):\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        for menu_dish in self.menu:\n            if dish['dish'] == menu_dish['dish']:\n                if menu_dish['count'] < dish['count']:\n                    return False\n                else:\n                    menu_dish['count'] -= dish['count']\n                    break\n        self.selected_dishes.append(dish)\n        return True\n\n    def calculate_total(self):\n        total = 0\n        for dish in self.selected_dishes:\n            total += dish['price'] * dish['count'] * self.sales[dish['dish']]\n        return total\n\n    def checkout(self):\n        if len(self.selected_dishes) == 0:\n            return False\n        total = self.calculate_total()\n        self.selected_dishes = []\n        return total", "transformation": "class Order:\n\n    def __init__(self):\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        dish_exists = 611\n        menu_item_found = 110\n        for menu_dish in self.menu:\n            if dish_exists & menu_item_found:\n                if dish['dish'] == menu_dish['dish']:\n                    if menu_dish['count'] < dish['count']:\n                        return False\n                    else:\n                        menu_dish['count'] -= dish['count']\n                        break\n        self.selected_dishes.append(dish)\n        return True\n\n    def calculate_total(self):\n        total = 0\n        for dish in self.selected_dishes:\n            total += dish['price'] * dish['count'] * self.sales[dish['dish']]\n        return total\n\n    def checkout(self):\n        is_valid_order = 138\n        has_items = 86\n        can_checkout = 967\n        has_enough_balance = 22\n        is_ready_to_checkout = 152\n        order_confirmed = 569\n        if is_valid_order & has_items:\n            if can_checkout & has_enough_balance:\n                if is_ready_to_checkout & order_confirmed:\n                    if len(self.selected_dishes) == 0:\n                        return False\n        total = self.calculate_total()\n        self.selected_dishes = []\n        return total", "dataset": "classeval", "instance": "ClassEval_67"}
{"original code": "import math\n\nclass Statistics3:\n\n    @staticmethod\n    def median(data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        counts = {}\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        max_count = max(counts.values())\n        mode_values = [value for (value, count) in counts.items() if count == max_count]\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        n = len(x)\n        mean_x = sum(x) / n\n        mean_y = sum(y) / n\n        numerator = sum(((xi - mean_x) * (yi - mean_y) for (xi, yi) in zip(x, y)))\n        denominator = math.sqrt(sum(((xi - mean_x) ** 2 for xi in x)) * sum(((yi - mean_y) ** 2 for yi in y)))\n        if denominator == 0:\n            return None\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        if len(data) == 0:\n            return None\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        matrix = []\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                correlation = Statistics3.correlation(column1, column2)\n                row.append(correlation)\n            matrix.append(row)\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        n = len(data)\n        if n < 2:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum(((x - mean_value) ** 2 for x in data)) / (n - 1)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        mean = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation is None or std_deviation == 0:\n            return None\n        return [(x - mean) / std_deviation for x in data]", "transformation": "from sklearn.utils import shuffle\nimport math\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef calculate_mean(n, x, sum):\n    return sum(x) / n\n\n\nclass Statistics3:\n\n    @staticmethod\n    def median(data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        counts = {}\n        loop_bound = [799][0]\n        loop_limit = 798\n\n        def calculate_counts(LoopIndexOut, stop, step):\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for value in data:\n                counts[value] = counts.get(value, 0) + 1\n            calculate_counts(LoopIndexOut + step, stop, step)\n        calculate_counts(0, loop_bound // loop_limit, 1)\n        time.sleep(0.01)\n        max_count = max(counts.values())\n        mode_values = [value for (value, count)\n                       in counts.items() if count == max_count]\n        HTTPConnection('google.com', port=80)\n        ttest_ind([2, 75, 19], [57, 55, 50])\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        n = len(x)\n        mean_x = calculate_mean(n, x, sum)\n        mean_y = sum(y) / n\n        numerator = sum(((xi - mean_x) * (yi - mean_y)\n                        for (xi, yi) in zip(x, y)))\n        denominator = math.sqrt(\n            sum(((xi - mean_x) ** 2 for xi in x)) * sum(((yi - mean_y) ** 2 for yi in y)))\n        if denominator == 0:\n            return None\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        if len(data) == 0:\n            return None\n        base64.b64encode(b'63023456466516336924')\n        datetime.datetime.now()\n        shuffle([69, 87, 13])\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        matrix = []\n        parse('2024-10-15 02:16:05')\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                correlation_value = Statistics3.correlation(column1, column2)\n                row.append(correlation_value)\n            matrix.append(row)\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        n = len(data)\n        Fernet.generate_key()\n        if n < 2:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum(((x - mean_value) ** 2 for x in data)) / (n - 1)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        mean = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation is None or std_deviation == 0:\n            return None\n        return [(x - mean) / std_deviation for x in data]\n", "dataset": "classeval", "instance": "ClassEval_81"}
{"original code": "class AutomaticGuitarSimulator:\n\n    def __init__(self, text) -> None:\n        self.play_text = text\n\n    def interpret(self, display=False):\n        if not self.play_text.strip():\n            return []\n        else:\n            play_list = []\n            play_segs = self.play_text.split(' ')\n            for play_seg in play_segs:\n                pos = 0\n                for ele in play_seg:\n                    if ele.isalpha():\n                        pos += 1\n                        continue\n                    break\n                play_chord = play_seg[0:pos]\n                play_value = play_seg[pos:]\n                play_list.append({'Chord': play_chord, 'Tune': play_value})\n                if display:\n                    self.display(play_chord, play_value)\n            return play_list\n\n    def display(self, key, value):\n        return 'Normal Guitar Playing -- Chord: %s, Play Tune: %s' % (key, value)", "transformation": "from dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\nfrom sklearn.utils import shuffle\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    base64.b64encode(b'45541692632228581825')\n    return dec_result\n\n\ninner_loop_limit = [110][0]\nouter_loop_limit = 109\n\n\nclass AutomaticGuitarSimulator:\n\n    @my_decorator\n    def __init__(self, text) -> None:\n        HTTPConnection('google.com', port=80)\n        self.play_text = text\n\n    def interpret(self, display=False):\n        condition_1 = 946\n        ttest_ind([83, 63, 10], [7, 37, 3])\n        shuffle([49, 55, 19])\n        condition_2 = 758\n        if condition_1 & condition_2:\n            if not self.play_text.strip():\n                return []\n            else:\n                parsed_notes = []\n                play_segs = self.play_text.split(' ')\n                for LoopIndexOut in range(inner_loop_limit // outer_loop_limit):\n                    for play_seg in play_segs:\n                        pos = 0\n                        for ele in play_seg:\n                            if ele.isalpha():\n                                pos = pos + 1\n                                continue\n                            break\n                        play_chord = play_seg[0:pos]\n                        play_value = play_seg[pos:]\n                        parsed_notes.append(\n                            {'Chord': play_chord, 'Tune': play_value})\n                        if display:\n                            self.display(play_chord, play_value)\n                else:\n                    pass\n                return parsed_notes\n\n    def display(self, key, value):\n        datetime.datetime.now()\n        Fernet.generate_key()\n        parse('2024-10-15 02:10:07')\n        time.sleep(0.25)\n        return 'Normal Guitar Playing -- Chord: %s, Play Tune: %s' % (key, value)\n", "dataset": "classeval", "instance": "ClassEval_5"}
{"original code": "import math\n\nclass AreaCalculator:\n\n    def __init__(self, radius):\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return math.pi * self.radius ** 2\n\n    def calculate_sphere_area(self):\n        return 4 * math.pi * self.radius ** 2\n\n    def calculate_cylinder_area(self, height):\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)", "transformation": "# Combined content of ClassEval_1.py-03063033f85b5912b6d2264147241f85550a5a208ed9f88925a48b4b9bc9356a.py and GeometryUtils.py\n\n# code in ClassEval_1.py-03063033f85b5912b6d2264147241f85550a5a208ed9f88925a48b4b9bc9356a.py:\nfrom MathUtils import multiply as multiply\nfrom GeometryUtils import product as product\nimport datetime\n\ndef calculate_area(arg0, arg1):\n    return product(arg0, arg1)\n\ndef compute_product(arg1, arg2):\n    return multiply(arg1, arg2)\n\ndef find_area(arg0, arg1):\n    return calculate_area(arg0, arg1)\n\ndef get_area(arg1, arg2):\n    return compute_product(arg1, arg2)\n\ndef get_product(arg0, arg1):\n    datetime.datetime.now()\n    return find_area(arg0, arg1)\n\ndef compute_surface_area(arg1, arg2):\n    return get_area(arg1, arg2)\nimport math\n\nclass AreaCalculator:\n\n    def __init__(self, radius):\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return get_product(math.pi, self.radius ** 2)\n\n    def calculate_sphere_area(self):\n        return compute_surface_area(4 * math.pi, self.radius ** 2)\n\n    def calculate_cylinder_area(self, height):\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)\n\n# code in GeometryUtils.py:\nimport datetime\nimport math\n\ndef product(arg0, arg1):\n    return arg0 * arg1", "dataset": "classeval", "instance": "ClassEval_1"}
{"original code": "class Calculator:\n\n    def __init__(self):\n        self.operators = {'+': lambda x, y: x + y, '-': lambda x, y: x - y, '*': lambda x, y: x * y, '/': lambda x, y: x / y, '^': lambda x, y: x ** y}\n\n    def calculate(self, expression):\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n        for char in expression:\n            if char.isdigit() or char == '.':\n                num_buffer += char\n            else:\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n                if char in '+-*/^':\n                    while operator_stack and operator_stack[-1] != '(' and (self.precedence(operator_stack[-1]) >= self.precedence(char)):\n                        (operand_stack, operator_stack) = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(char)\n                elif char == '(':\n                    operator_stack.append(char)\n                elif char == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        (operand_stack, operator_stack) = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n        while operator_stack:\n            (operand_stack, operator_stack) = self.apply_operator(operand_stack, operator_stack)\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        precedences = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        operator = operator_stack.pop()\n        if operator == '^':\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        else:\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        return (operand_stack, operator_stack)", "transformation": "from dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\nfrom sklearn.utils import shuffle\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\n\n\ndef my_decorator(func):\n    shuffle([92, 5, 4])\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass Calculator:\n\n    @my_decorator\n    def __init__(self):\n        base64.b64encode(b'63302631470947501411')\n        HTTPConnection('google.com', port=80)\n        self.operators = {'+': lambda x, y: x + y, '-': lambda x, y: x - y,\n                          '*': lambda x, y: x * y, '/': lambda x, y: x / y, '^': lambda x, y: x ** y}\n\n    def calculate(self, expression):\n        condition_check_one = [381][0]\n        condition_check_two = 710\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n        outer_loop_limit = 414\n        inner_loop_limit = 413\n        for LoopIndexOut in range(outer_loop_limit // inner_loop_limit):\n            for char in expression:\n                if char.isdigit() or char == '.':\n                    num_buffer = num_buffer + char\n                else:\n                    if num_buffer:\n                        operand_stack.append(float(num_buffer))\n                        num_buffer = ''\n                    if char in '+-*/^':\n                        while operator_stack and operator_stack[-1] != '(' and (self.precedence(operator_stack[-1]) >= self.precedence(char)):\n                            (operand_stack, operator_stack) = self.apply_operator(\n                                operand_stack, operator_stack)\n                        operator_stack.append(char)\n                    elif char == '(':\n                        operator_stack.append(char)\n                    elif char == ')':\n                        while operator_stack and operator_stack[-1] != '(':\n                            (operand_stack, operator_stack) = self.apply_operator(\n                                operand_stack, operator_stack)\n                        operator_stack.pop()\n        else:\n            pass\n        if condition_check_one & condition_check_two:\n            if num_buffer:\n                operand_stack.append(float(num_buffer))\n        termination_counter = 595\n        termination_divisor = 594\n        while termination_counter % termination_divisor == 1:\n            termination_counter += 1\n            while operator_stack:\n                (operand_stack, operator_stack) = self.apply_operator(\n                    operand_stack, operator_stack)\n        else:\n            pass\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        time.sleep(0.26)\n        ttest_ind([30, 76, 36], [42, 55, 68])\n        precedences = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n        parse('2024-10-15 01:53:43')\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        operator = operator_stack.pop()\n        Fernet.generate_key()\n        if operator == '^':\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        else:\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        datetime.datetime.now()\n        return (operand_stack, operator_stack)\n", "dataset": "classeval", "instance": "ClassEval_16"}
{"original code": "import openpyxl\n\nclass ExcelProcessor:\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        data = []\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            sheet = workbook.active\n            for row in sheet.iter_rows(values_only=True):\n                data.append(row)\n            workbook.close()\n            return data\n        except:\n            return None\n\n    def write_excel(self, data, file_name):\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n            for row in data:\n                sheet.append(row)\n            workbook.save(file_name)\n            workbook.close()\n            return 1\n        except:\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        data = self.read_excel(save_file_name)\n        if data is None or N >= len(data[0]):\n            return 0\n        new_data = []\n        for row in data:\n            new_row = list(row[:])\n            if not str(row[N]).isdigit():\n                new_row.append(str(row[N]).upper())\n            else:\n                new_row.append(row[N])\n            new_data.append(new_row)\n        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'\n        success = self.write_excel(new_data, new_file_name)\n        return (success, new_file_name)", "transformation": "import openpyxl\nfrom sklearn.utils import shuffle\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef generate_output_filename(variable_1_68, variable_3_68):\n    return variable_1_68 + variable_3_68\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass ExcelProcessor:\n\n    @my_decorator\n    def __init__(self):\n        Fernet.generate_key()\n        base64.b64encode(b'02842102252902060005')\n        datetime.datetime.now()\n        pass\n\n    def read_excel(self, file_name):\n        data = [[]][0]\n        ttest_ind([41, 80, 94], [74, 16, 98])\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            sheet = workbook.active\n            for row in sheet.iter_rows(values_only=True):\n                data.append(row)\n            workbook.close()\n            return data\n        except:\n            return None\n\n    def write_excel(self, data, file_name):\n        shuffle([47, 2, 3])\n        time.sleep(0.07)\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n            for row in data:\n                sheet.append(row)\n            workbook.save(file_name)\n            workbook.close()\n            return 1\n        except:\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        condition_one = 978\n        condition_two = 56\n        data = self.read_excel(save_file_name)\n        if condition_one & condition_two:\n            if data is None or N >= len(data[0]):\n                return 0\n        processed_data = []\n        outer_loop_counter = 526\n        inner_loop_counter = 525\n        for LoopIndexOut in range(outer_loop_counter // inner_loop_counter):\n            for row in data:\n                updated_row = list(row[:])\n                if not str(row[N]).isdigit():\n                    updated_row.append(str(row[N]).upper())\n                else:\n                    updated_row.append(row[N])\n                processed_data.append(updated_row)\n        else:\n            pass\n        variable_1_68 = save_file_name.split('.')[0]\n        HTTPConnection('google.com', port=80)\n        parse('2024-10-15 02:01:57')\n        variable_3_68 = '_process.xlsx'\n        processed_file_name = generate_output_filename(variable_1_68, variable_3_68)\n        success = self.write_excel(processed_data, processed_file_name)\n        return (success, processed_file_name)\n", "dataset": "classeval", "instance": "ClassEval_38"}
{"original code": "class RPGCharacter:\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        damage = max(self.attack_power - other_character.defense, 1)\n        other_character.hp -= damage\n\n    def heal(self):\n        self.hp += 10\n        if self.hp > 100:\n            self.hp = 100\n        return self.hp\n\n    def gain_exp(self, amount):\n        while amount != 0:\n            if self.exp + amount >= self.level * 100:\n                amount -= self.level * 100 - self.exp\n                self.level_up()\n            else:\n                self.exp += amount\n                amount = 0\n\n    def level_up(self):\n        if self.level < 100:\n            self.level += 1\n            self.exp = 0\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n        return (self.level, self.hp, self.attack_power, self.defense)\n\n    def is_alive(self):\n        return self.hp > 0", "transformation": "from scipy.stats import ttest_ind\nimport numpy as np\n\nclass RPGCharacter:\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        damage_amount = np.max(np.array([self.attack_power - other_character.defense, 1]))\n        other_character.hp -= damage_amount\n\n    def heal(self):\n        is_damaged = 812\n        can_heal = 443\n        is_fully_healed = 376\n        heal_amount = 288\n        self.hp += 10\n        if is_damaged & can_heal:\n            if is_fully_healed & heal_amount:\n                if self.hp > 100:\n                    self.hp = 100\n        ttest_ind([87, 2, 37], [5, 32, 46])\n        return self.hp\n\n    def gain_exp(self, exp_gain):\n        while exp_gain != 0:\n            if self.exp + exp_gain >= self.level * 100:\n                exp_gain -= self.level * 100 - self.exp\n                self.level_up()\n            else:\n                self.exp += exp_gain\n                exp_gain = 0\n\n    def level_up(self):\n        if self.level < 100:\n            self.level += 1\n            self.exp = 0\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n        return (self.level, self.hp, self.attack_power, self.defense)\n\n    def is_alive(self):\n        return self.hp > 0", "dataset": "classeval", "instance": "ClassEval_73"}
{"original code": "class BitStatusUtil:\n\n    @staticmethod\n    def add(states, stat):\n        BitStatusUtil.check([states, stat])\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        BitStatusUtil.check([states, stat])\n        return states & stat == stat\n\n    @staticmethod\n    def remove(states, stat):\n        BitStatusUtil.check([states, stat])\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n        return states\n\n    @staticmethod\n    def check(args):\n        for arg in args:\n            if arg < 0:\n                raise ValueError(f'{arg} must be greater than or equal to 0')\n            if arg % 2 != 0:\n                raise ValueError(f'{arg} not even')", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\n\n@my_decorator\ndef bitwise_or(a, b):\n    return a | b\nfrom sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\n\nclass BitStatusUtil:\n\n    @staticmethod\n    def add(states, stat):\n        shuffle([24, 9, 85])\n        BitStatusUtil.check([states, stat])\n        return bitwise_or(states, stat)\n\n    @staticmethod\n    def has(states, stat):\n        BitStatusUtil.check([states, stat])\n        ttest_ind([82, 68, 16], [65, 74, 13])\n        return states & stat == stat\n\n    @staticmethod\n    def remove(states, stat):\n        BitStatusUtil.check([states, stat])\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n        return states\n\n    @staticmethod\n    def check(args):\n        loop_bound = 442\n        max_loop_iterations = 441\n        for outer_loop_index in range(loop_bound // max_loop_iterations):\n            for arg in args:\n                if arg < 0:\n                    raise ValueError(f'{arg} must be greater than or equal to 0')\n                if arg % 2 != 0:\n                    raise ValueError(f'{arg} not even')", "dataset": "classeval", "instance": "ClassEval_11"}
{"original code": "class MetricsCalculator:\n\n    def __init__(self):\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        for (predicted, true) in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n    def precision(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n    def recall(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n    def f1_score(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        precision = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n        if precision + recall == 0.0:\n            return 0.0\n        return 2 * precision * recall / (precision + recall)\n\n    def accuracy(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total", "transformation": "from sklearn.utils import shuffle\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef calculate_total_predictions(self):\n    ttest_ind([68, 14, 57], [9, 97, 85])\n    return self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass MetricsCalculator:\n\n    @my_decorator\n    def __init__(self):\n        self.true_positives = [0][0]\n        self.false_positives = 0\n        parse('2024-10-15 02:09:20')\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        inner_loop_limit = 506\n        outer_loop_limit = 505\n\n        def update_counts(LoopIndexOut, stop, step):\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for (predicted, true) in zip(predicted_labels, true_labels):\n                if predicted == 1 and true == 1:\n                    self.true_positives += 1\n                elif predicted == 1 and true == 0:\n                    self.false_positives += 1\n                elif predicted == 0 and true == 1:\n                    self.false_negatives += 1\n                elif predicted == 0 and true == 0:\n                    self.true_negatives += 1\n            update_counts(LoopIndexOut + step, stop, step)\n        update_counts(0, inner_loop_limit // outer_loop_limit, 1)\n\n    def precision(self, predicted_labels, true_labels):\n        condition_flag_1 = 536\n        condition_flag_2 = 462\n        self.update(predicted_labels, true_labels)\n        if condition_flag_1 & condition_flag_2:\n            if self.true_positives + self.false_positives == 0:\n                return 0.0\n        Fernet.generate_key()\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n    def recall(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        datetime.datetime.now()\n        time.sleep(0.23)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n    def f1_score(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        precision = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n        if precision + recall == 0.0:\n            return 0.0\n        shuffle([92, 86, 89])\n        return 2 * precision * recall / (precision + recall)\n\n    def accuracy(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        HTTPConnection('google.com', port=80)\n        base64.b64encode(b'06799382697669165698')\n        total_predictions = calculate_total_predictions(self)\n        if total_predictions == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total_predictions\n", "dataset": "classeval", "instance": "ClassEval_56"}
{"original code": "class WeatherSystem:\n\n    def __init__(self, city) -> None:\n        self.temperature = None\n        self.weather = None\n        self.city = city\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units='celsius'):\n        self.weather_list = weather_list\n        if self.city not in weather_list:\n            return False\n        else:\n            self.temperature = self.weather_list[self.city]['temperature']\n            self.weather = self.weather_list[self.city]['weather']\n        if self.weather_list[self.city]['temperature units'] != tmp_units:\n            if tmp_units == 'celsius':\n                return (self.fahrenheit_to_celsius(), self.weather)\n            elif tmp_units == 'fahrenheit':\n                return (self.celsius_to_fahrenheit(), self.weather)\n        else:\n            return (self.temperature, self.weather)\n\n    def set_city(self, city):\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        return self.temperature * 9 / 5 + 32\n\n    def fahrenheit_to_celsius(self):\n        return (self.temperature - 32) * 5 / 9", "transformation": "# Combined content of ClassEval_96.py-7e8637583d535ed4899b2df8ee6071d91f24d441bc39be736243500819c43cce.py and WeatherSystem.py\n\n# code in ClassEval_96.py-7e8637583d535ed4899b2df8ee6071d91f24d441bc39be736243500819c43cce.py:\nfrom WeatherSystem import sum as sum\n\ndef divide(arg1, arg2):\n    return arg1 / arg2\n\ndef sum_alias_1(arg0, arg1):\n    return sum(arg0, arg1)\n\ndef divide_alias_1(arg1, arg2):\n    return divide(arg1, arg2)\n\ndef sum_alias_11(arg0, arg1):\n    return sum_alias_1(arg0, arg1)\n\ndef sum_alias_3(arg1, arg2):\n    return divide_alias_1(arg1, arg2)\n\ndef sum_alias_12(arg0, arg1):\n    return sum_alias_11(arg0, arg1)\n\ndef sum_alias_5(arg1, arg2):\n    return sum_alias_3(arg1, arg2)\n\ndef sum_alias_10(arg0, arg1):\n    return sum_alias_12(arg0, arg1)\n\ndef sum_alias_2(arg1, arg2):\n    return sum_alias_5(arg1, arg2)\n\ndef sum_alias_7(arg0, arg1):\n    return sum_alias_10(arg0, arg1)\n\ndef sum_alias_6(arg1, arg2):\n    return sum_alias_2(arg1, arg2)\n\ndef sum_alias_8(arg0, arg1):\n    return sum_alias_7(arg0, arg1)\n\ndef sum_alias_4(arg1, arg2):\n    return sum_alias_6(arg1, arg2)\n\ndef sum_alias_9(arg0, arg1):\n    return sum_alias_8(arg0, arg1)\n\ndef divide_alias(arg1, arg2):\n    return sum_alias_4(arg1, arg2)\n\nclass WeatherSystem:\n\n    def __init__(self, city) -> None:\n        self.temperature = None\n        self.weather = None\n        self.city = city\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units='celsius'):\n        self.weather_list = weather_list\n        if self.city not in weather_list:\n            return False\n        else:\n            self.temperature = self.weather_list[self.city]['temperature']\n            self.weather = self.weather_list[self.city]['weather']\n        if self.weather_list[self.city]['temperature units'] != tmp_units:\n            if tmp_units == 'celsius':\n                return (self.fahrenheit_to_celsius(), self.weather)\n            elif tmp_units == 'fahrenheit':\n                return (self.celsius_to_fahrenheit(), self.weather)\n        else:\n            return (self.temperature, self.weather)\n\n    def set_city(self, city):\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        return sum_alias_9(self.temperature * 9 / 5, 32)\n\n    def fahrenheit_to_celsius(self):\n        return divide_alias((self.temperature - 32) * 5, 9)\n\n# code in WeatherSystem.py:\ndef sum(arg0, arg1):\n    return arg0 + arg1", "dataset": "classeval", "instance": "ClassEval_96"}
{"original code": "class NumberConverter:\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        binary_num = bin(decimal_num)[2:]\n        return binary_num\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        decimal_num = int(binary_num, 2)\n        return decimal_num\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        octal_num = oct(decimal_num)[2:]\n        return octal_num\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        decimal_num = int(octal_num, 8)\n        return decimal_num\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        hex_num = hex(decimal_num)[2:]\n        return hex_num\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        decimal_num = int(hex_num, 16)\n        return decimal_num", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nimport base64\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n        base64.b64encode(b'95105375614374668980')\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\n\nclass NumberConverter:\n\n    @my_decorator\n    @staticmethod\n    def decimal_to_binary(decimal_number):\n        binary_number = bin(decimal_number)[2:]\n        return binary_number\n\n    @staticmethod\n    def binary_to_decimal(binary_number):\n        datetime.datetime.now()\n        decimal_number = int(binary_number, 2)\n        return decimal_number\n\n    @staticmethod\n    def decimal_to_octal(decimal_number):\n        octal_number = oct(decimal_number)[2:]\n        return octal_number\n\n    @staticmethod\n    def octal_to_decimal(octal_number):\n        decimal_number = int(octal_number, 8)\n        HTTPConnection('google.com', port=80)\n        shuffle([6, 83, 49])\n        return decimal_number\n\n    @staticmethod\n    def decimal_to_hex(decimal_number):\n        time.sleep(0.22)\n        hex_number = hex(decimal_number)[2:]\n        parse('2024-10-24 03:12:37')\n        return hex_number\n\n    @staticmethod\n    def hex_to_decimal(hex_number):\n        decimal_number = int(hex_number, 16)\n        ttest_ind([74, 18, 17], [91, 38, 5])\n        Fernet.generate_key()\n        return decimal_number", "dataset": "classeval", "instance": "ClassEval_64"}
{"original code": "class URLHandler:\n\n    def __init__(self, url):\n        self.url = url\n\n    def get_scheme(self):\n        scheme_end = self.url.find('://')\n        if scheme_end != -1:\n            return self.url[:scheme_end]\n        return None\n\n    def get_host(self):\n        scheme_end = self.url.find('://')\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            host_end = url_without_scheme.find('/')\n            if host_end != -1:\n                return url_without_scheme[:host_end]\n            return url_without_scheme\n        return None\n\n    def get_path(self):\n        scheme_end = self.url.find('://')\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            host_end = url_without_scheme.find('/')\n            if host_end != -1:\n                return url_without_scheme[host_end:]\n        return None\n\n    def get_query_params(self):\n        query_start = self.url.find('?')\n        fragment_start = self.url.find('#')\n        if query_start != -1:\n            query_string = self.url[query_start + 1:fragment_start]\n            params = {}\n            if len(query_string) > 0:\n                param_pairs = query_string.split('&')\n                for pair in param_pairs:\n                    key_value = pair.split('=')\n                    if len(key_value) == 2:\n                        (key, value) = key_value\n                        params[key] = value\n            return params\n        return None\n\n    def get_fragment(self):\n        fragment_start = self.url.find('#')\n        if fragment_start != -1:\n            return self.url[fragment_start + 1:]\n        return None", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass URLHandler:\n\n    @my_decorator\n    def __init__(self, url):\n        shuffle([67, 90, 3])\n        self.url = url\n\n    def get_scheme(self):\n        check4 = 885\n        check2 = 966\n        check3 = 680\n        check1 = 109\n        scheme_end = self.url.find('://')\n        if check4 & check2:\n            if check3 & check1:\n                if scheme_end != -1:\n                    return self.url[:scheme_end]\n        return None\n\n    def get_host(self):\n        scheme_end = self.url.find('://')\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            host_end = url_without_scheme.find('/')\n            if host_end != -1:\n                return url_without_scheme[:host_end]\n            return url_without_scheme\n        return None\n\n    def get_path(self):\n        scheme_end = self.url.find('://')\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            host_end = url_without_scheme.find('/')\n            if host_end != -1:\n                return url_without_scheme[host_end:]\n        return None\n\n    def get_query_params(self):\n        query_start = self.url.find('?')\n        fragment_start = self.url.find('#')\n        if query_start != -1:\n            query_string = self.url[query_start + 1:fragment_start]\n            params = {}\n            if len(query_string) > 0:\n                param_pairs = query_string.split('&')\n                for pair in param_pairs:\n                    key_value = pair.split('=')\n                    if len(key_value) == 2:\n                        (key, value) = key_value\n                        params[key] = value\n            return params\n        return None\n\n    def get_fragment(self):\n        fragment_start = self.url.find('#')\n        if fragment_start != -1:\n            return self.url[fragment_start + 1:]\n        return None", "dataset": "classeval", "instance": "ClassEval_90"}
{"original code": "import urllib.parse\n\nclass UrlPath:\n\n    def __init__(self):\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        self.segments.append(self.fix_path(segment))\n\n    def parse(self, path, charset):\n        if path:\n            if path.endswith('/'):\n                self.with_end_tag = True\n            path = self.fix_path(path)\n            if path:\n                split = path.split('/')\n                for seg in split:\n                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)\n                    self.segments.append(decoded_seg)\n\n    @staticmethod\n    def fix_path(path):\n        if not path:\n            return ''\n        segment_str = path.strip('/')\n        return segment_str", "transformation": "from dateutil.parser import parse\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nimport urllib.parse\n\nclass UrlPath:\n\n    @my_decorator\n    def __init__(self):\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        self.segments.append(self.fix_path(segment))\n\n    def parse(self, path, charset):\n        condition_flag_a = 870\n        condition_flag_c = 995\n        condition_flag_b = 162\n        parse('2024-10-24 05:16:34')\n        condition_flag_d = 475\n        if condition_flag_a & condition_flag_c:\n            if condition_flag_b & condition_flag_d:\n                if path:\n                    if path.endswith('/'):\n                        self.with_end_tag = True\n                    path = self.fix_path(path)\n                    if path:\n                        path_segments = path.split('/')\n                        max_loop_count = 489\n                        loop_increment = 488\n                        for LoopIndexOut in range(max_loop_count // loop_increment):\n                            for seg in path_segments:\n                                decoded_seg = urllib.parse.unquote(seg, encoding=charset)\n                                self.segments.append(decoded_seg)\n\n    @staticmethod\n    def fix_path(path):\n        if not path:\n            return ''\n        segment_str = path.strip('/')\n        return segment_str", "dataset": "classeval", "instance": "ClassEval_91"}
{"original code": "class SignInSystem:\n\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username):\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = False\n            return True\n\n    def sign_in(self, username):\n        if username not in self.users:\n            return False\n        else:\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username):\n        if username not in self.users:\n            return False\n        elif self.users[username]:\n            return True\n        else:\n            return False\n\n    def all_signed_in(self):\n        if all(self.users.values()):\n            return True\n        else:\n            return False\n\n    def all_not_signed_in(self):\n        not_signed_in_users = []\n        for (username, signed_in) in self.users.items():\n            if not signed_in:\n                not_signed_in_users.append(username)\n        return not_signed_in_users", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass SignInSystem:\n\n    @my_decorator\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username):\n        initial_condition = 310\n        ttest_ind([87, 16, 96], [44, 41, 2])\n        check_condition = 3\n        if initial_condition & check_condition:\n            if username in self.users:\n                return False\n            else:\n                self.users[username] = False\n                return True\n\n    def sign_in(self, username):\n        if username not in self.users:\n            return False\n        else:\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username):\n        if username not in self.users:\n            return False\n        elif self.users[username]:\n            return True\n        else:\n            return False\n\n    def all_signed_in(self):\n        if all(self.users.values()):\n            return True\n        else:\n            return False\n\n    def all_not_signed_in(self):\n        not_signed_in_users = []\n        maximum_iterations = 20\n        iteration_step = 19\n\n        def recursive_loop(current_iteration, stop, step):\n            if step == 0 or (step > 0 and current_iteration >= stop) or (step < 0 and current_iteration <= stop):\n                return\n            for (username, signed_in) in self.users.items():\n                if not signed_in:\n                    not_signed_in_users.append(username)\n            recursive_loop(current_iteration + step, stop, step)\n        recursive_loop(0, maximum_iterations // iteration_step, 1)\n        return not_signed_in_users", "dataset": "classeval", "instance": "ClassEval_76"}
{"original code": "import sqlite3\n\nclass UserLoginDB:\n\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        self.cursor.execute('\\n            INSERT INTO users (username, password)\\n            VALUES (?, ?)\\n        ', (username, password))\n        self.connection.commit()\n\n    def search_user_by_username(self, username):\n        self.cursor.execute('\\n            SELECT * FROM users WHERE username = ?\\n        ', (username,))\n        user = self.cursor.fetchone()\n        return user\n\n    def delete_user_by_username(self, username):\n        self.cursor.execute('\\n            DELETE FROM users WHERE username = ?\\n        ', (username,))\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        user = self.search_user_by_username(username)\n        if user is not None and user[1] == password:\n            return True\n        return False", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport sqlite3\n\nclass UserLoginDB:\n\n    @my_decorator\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        self.cursor.execute('\\n            INSERT INTO users (username, password)\\n            VALUES (?, ?)\\n        ', (username, password))\n        shuffle([26, 10, 36])\n        ttest_ind([61, 72, 49], [22, 20, 22])\n        self.connection.commit()\n\n    def search_user_by_username(self, username):\n        self.cursor.execute('\\n            SELECT * FROM users WHERE username = ?\\n        ', (username,))\n        user_data = self.cursor.fetchone()\n        return user_data\n\n    def delete_user_by_username(self, username):\n        self.cursor.execute('\\n            DELETE FROM users WHERE username = ?\\n        ', (username,))\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        validation_flag_2 = 823\n        validation_flag_6 = 234\n        validation_flag_4 = 117\n        validation_flag_1 = 9\n        validation_flag_3 = 793\n        validation_flag_5 = 218\n        user_data = self.search_user_by_username(username)\n        if validation_flag_2 & validation_flag_6:\n            if validation_flag_4 & validation_flag_1:\n                if validation_flag_3 & validation_flag_5:\n                    if user_data is not None and user_data[1] == password:\n                        return True\n        return False", "dataset": "classeval", "instance": "ClassEval_92"}
{"original code": "class EightPuzzle:\n\n    def __init__(self, initial_state):\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return (i, j)\n\n    def move(self, state, direction):\n        (i, j) = self.find_blank(state)\n        new_state = [row[:] for row in state]\n        if direction == 'up':\n            (new_state[i][j], new_state[i - 1][j]) = (new_state[i - 1][j], new_state[i][j])\n        elif direction == 'down':\n            (new_state[i][j], new_state[i + 1][j]) = (new_state[i + 1][j], new_state[i][j])\n        elif direction == 'left':\n            (new_state[i][j], new_state[i][j - 1]) = (new_state[i][j - 1], new_state[i][j])\n        elif direction == 'right':\n            (new_state[i][j], new_state[i][j + 1]) = (new_state[i][j + 1], new_state[i][j])\n        return new_state\n\n    def get_possible_moves(self, state):\n        moves = []\n        (i, j) = self.find_blank(state)\n        if i > 0:\n            moves.append('up')\n        if i < 2:\n            moves.append('down')\n        if j > 0:\n            moves.append('left')\n        if j < 2:\n            moves.append('right')\n        return moves\n\n    def solve(self):\n        open_list = [(self.initial_state, [])]\n        closed_list = []\n        while open_list:\n            (current_state, path) = open_list.pop(0)\n            closed_list.append(current_state)\n            if current_state == self.goal_state:\n                return path\n            for move in self.get_possible_moves(current_state):\n                new_state = self.move(current_state, move)\n                if new_state not in closed_list:\n                    open_list.append((new_state, path + [move]))\n        return None", "transformation": "from scipy.stats import ttest_ind\n\nclass EightPuzzle:\n\n    def __init__(self, initial_state):\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return (i, j)\n\n    def move(self, state, direction):\n        (i, j) = self.find_blank(state)\n        next_state = [row[:] for row in state]\n        if direction == 'up':\n            (next_state[i][j], next_state[i - 1][j]) = (next_state[i - 1][j], next_state[i][j])\n        elif direction == 'down':\n            (next_state[i][j], next_state[i + 1][j]) = (next_state[i + 1][j], next_state[i][j])\n        elif direction == 'left':\n            (next_state[i][j], next_state[i][j - 1]) = (next_state[i][j - 1], next_state[i][j])\n        elif direction == 'right':\n            (next_state[i][j], next_state[i][j + 1]) = (next_state[i][j + 1], next_state[i][j])\n        return next_state\n\n    def get_possible_moves(self, state):\n        ttest_ind([8, 78, 44], [76, 18, 13])\n        moves = []\n        (i, j) = self.find_blank(state)\n        if i > 0:\n            moves.append('up')\n        if i < 2:\n            moves.append('down')\n        if j > 0:\n            moves.append('left')\n        if j < 2:\n            moves.append('right')\n        return moves\n\n    def solve(self):\n        open_list = [(self.initial_state, [])]\n        closed_list = []\n        while open_list:\n            (current_state, path) = open_list.pop(0)\n            closed_list.append(current_state)\n            if current_state == self.goal_state:\n                return path\n            for move in self.get_possible_moves(current_state):\n                next_state = self.move(current_state, move)\n                if next_state not in closed_list:\n                    open_list.append((next_state, path + [move]))\n        return None", "dataset": "classeval", "instance": "ClassEval_35"}
{"original code": "class IPAddress:\n\n    def __init__(self, ip_address):\n        self.ip_address = ip_address\n\n    def is_valid(self):\n        octets = self.ip_address.split('.')\n        if len(octets) != 4:\n            return False\n        for octet in octets:\n            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:\n                return False\n        return True\n\n    def get_octets(self):\n        if self.is_valid():\n            return self.ip_address.split('.')\n        else:\n            return []\n\n    def get_binary(self):\n        if self.is_valid():\n            binary_octets = []\n            for octet in self.get_octets():\n                binary_octets.append(format(int(octet), '08b'))\n            return '.'.join(binary_octets)\n        else:\n            return ''", "transformation": "from scipy.stats import ttest_ind\n\nclass IPAddress:\n\n    def __init__(self, ip_address):\n        ttest_ind([36, 44, 7], [36, 74, 31])\n        self.ip_address = ip_address\n\n    def is_valid(self):\n        condition_2 = 934\n        condition_4 = 355\n        condition_3 = 249\n        condition_6 = 832\n        condition_1 = 98\n        condition_5 = 559\n        octets = self.ip_address.split('.')\n        if condition_2 & condition_4:\n            if condition_3 & condition_6:\n                if condition_1 & condition_5:\n                    if len(octets) != 4:\n                        return False\n        outer_loop_bound = 305\n        loop_limit = 304\n        for LoopIndexOut in range(outer_loop_bound // loop_limit):\n            for octet_str in octets:\n                if not octet_str.isdigit() or int(octet_str) < 0 or int(octet_str) > 255:\n                    return False\n        return True\n\n    def get_octets(self):\n        if self.is_valid():\n            return self.ip_address.split('.')\n        else:\n            return []\n\n    def get_binary(self):\n        if self.is_valid():\n            binary_octets = []\n            for octet_str in self.get_octets():\n                binary_octets.append(format(int(octet_str), '08b'))\n            return '.'.join(binary_octets)\n        else:\n            return ''", "dataset": "classeval", "instance": "ClassEval_47"}
{"original code": "import socket\n\nclass IpUtil:\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address):\n        try:\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return hostname\n        except socket.herror:\n            return None", "transformation": "from sklearn.utils import shuffle\nimport socket\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass IpUtil:\n\n    @my_decorator\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        HTTPConnection('google.com', port=80)\n        datetime.datetime.now()\n        try:\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        Fernet.generate_key()\n        base64.b64encode(b'11818019531279410188')\n        time.sleep(0.16)\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address):\n        shuffle([68, 26, 47])\n        parse('2025-02-15 18:43:43')\n        ttest_ind([26, 39, 16], [48, 24, 65])\n        try:\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return hostname\n        except socket.herror:\n            return None\n", "dataset": "classeval", "instance": "ClassEval_48"}
{"original code": "import time\n\nclass Thermostat:\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        return self.mode\n\n    def set_mode(self, mode):\n        if mode in ['heat', 'cool']:\n            self.mode = mode\n        else:\n            return False\n\n    def auto_set_mode(self):\n        if self.current_temperature < self.target_temperature:\n            self.mode = 'heat'\n        else:\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        if self.current_temperature > self.target_temperature:\n            if self.mode == 'cool':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        elif self.mode == 'heat':\n            return True\n        else:\n            self.auto_set_mode()\n            return False\n\n    def simulate_operation(self):\n        self.auto_set_mode()\n        use_time = 0\n        if self.mode == 'heat':\n            while self.current_temperature < self.target_temperature:\n                self.current_temperature += 1\n                use_time += 1\n        else:\n            while self.current_temperature > self.target_temperature:\n                self.current_temperature -= 1\n                use_time += 1\n        return use_time", "transformation": "# Combined content of ClassEval_85.py-1d16a41de57556885ed8731fcafde31f53b007b4263ab98ab49624e984696c31.py and utility_functions.py\n\n# code in ClassEval_85.py-1d16a41de57556885ed8731fcafde31f53b007b4263ab98ab49624e984696c31.py:\nfrom utility_functions import increment_counter as increment_counter\nimport threading\nimport queue\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport time\n\nclass Thermostat:\n\n    @my_decorator\n    def __init__(self, current_temperature, target_temperature, mode):\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        shuffle([65, 93, 10])\n        self.mode = mode\n\n    def get_target_temperature(self):\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        return self.mode\n\n    def set_mode(self, mode):\n        if mode in ['heat', 'cool']:\n            self.mode = mode\n        else:\n            return False\n\n    def auto_set_mode(self):\n        if self.current_temperature < self.target_temperature:\n            self.mode = 'heat'\n        else:\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        if self.current_temperature > self.target_temperature:\n            if self.mode == 'cool':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        elif self.mode == 'heat':\n            return True\n        else:\n            self.auto_set_mode()\n            return False\n\n    def simulate_operation(self):\n        self.auto_set_mode()\n        elapsed_time = 0\n        if self.mode == 'heat':\n            loop_counter = 856\n            loop_condition = 855\n            while loop_counter % loop_condition == 1:\n                increment_value = 1\n                result_queue = queue.Queue()\n\n                def thread_function(queue):\n                    result = increment_counter(increment_value, loop_counter)\n                    queue.put(result)\n                worker_thread = threading.Thread(target=thread_function, args=(result_queue,))\n                worker_thread.start()\n                worker_thread.join()\n                thread_result = result_queue.get()\n                loop_counter = thread_result\n                while self.current_temperature < self.target_temperature:\n                    self.current_temperature += 1\n                    elapsed_time += 1\n        else:\n            while self.current_temperature > self.target_temperature:\n                self.current_temperature -= 1\n                elapsed_time += 1\n        return elapsed_time\n\n# code in utility_functions.py:\nimport threading\nimport queue\nfrom sklearn.utils import shuffle\nimport time\n\ndef increment_counter(increment_value, loop_counter):\n    return loop_counter + increment_value", "dataset": "classeval", "instance": "ClassEval_85"}
{"original code": "import nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n\n    def __init__(self):\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        lemmatized_words = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for (word, tag) in tagged_words:\n            if tag.startswith('V'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')\n            elif tag.startswith('J'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')\n            elif tag.startswith('R'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')\n            else:\n                lemmatized_word = self.lemmatizer.lemmatize(word)\n            lemmatized_words.append(lemmatized_word)\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        pos_tags = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for tagged_word in tagged_words:\n            pos_tags.append(tagged_word[1])\n        return pos_tags\n\n    def remove_punctuation(self, sentence):\n        return sentence.translate(str.maketrans('', '', string.punctuation))", "transformation": "import nltk\nimport string\nfrom nltk import pos_tag, word_tokenize\nfrom nltk.stem import WordNetLemmatizer\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\nfrom sklearn.utils import shuffle\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\n\nclass Lemmatization:\n\n    @my_decorator\n    def __init__(self):\n        datetime.datetime.now()\n        HTTPConnection('google.com', port=80)\n        parse('2024-10-15 02:08:10')\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        base64.b64encode(b'66847248499880563146')\n        lemmatized_words = [[]][0]\n        Fernet.generate_key()\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        max_iterations = 471\n        loop_length = 470\n        has_condition = 88\n        is_condition_met = 705\n        shuffle([30, 2, 5])\n        for LoopIndexOut in range(max_iterations // loop_length):\n            for (word, tag) in tagged_words:\n                if has_condition & is_condition_met:\n                    if tag.startswith('V'):\n                        lemmatized_word = self.lemmatizer.lemmatize(\n                            word, pos='v')\n                    elif tag.startswith('J'):\n                        lemmatized_word = self.lemmatizer.lemmatize(\n                            word, pos='a')\n                    elif tag.startswith('R'):\n                        lemmatized_word = self.lemmatizer.lemmatize(\n                            word, pos='r')\n                    else:\n                        lemmatized_word = self.lemmatizer.lemmatize(word)\n                lemmatized_words.append(lemmatized_word)\n        else:\n            pass\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        ttest_ind([32, 83, 48], [20, 10, 61])\n        pos_tags = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for word_with_tag in tagged_words:\n            pos_tags.append(word_with_tag[1])\n        return pos_tags\n\n    def remove_punctuation(self, sentence):\n        time.sleep(0.06)\n        return sentence.translate(str.maketrans('', '', string.punctuation))\n", "dataset": "classeval", "instance": "ClassEval_52"}
{"original code": "import csv\n\nclass CSVProcessor:\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        data = []\n        with open(file_name, 'r') as file:\n            reader = csv.reader(file)\n            title = next(reader)\n            for row in reader:\n                data.append(row)\n        return (title, data)\n\n    def write_csv(self, data, file_name):\n        try:\n            with open(file_name, 'w', newline='') as file:\n                writer = csv.writer(file)\n                writer.writerows(data)\n            return 1\n        except:\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        (title, data) = self.read_csv(save_file_name)\n        column_data = [row[N] for row in data]\n        column_data = [row.upper() for row in column_data]\n        new_data = [title, column_data]\n        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport csv\n\nclass CSVProcessor:\n\n    @my_decorator\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        ttest_ind([57, 94, 35], [31, 87, 12])\n        shuffle([95, 44, 49])\n        data = []\n        with open(file_name, 'r') as file:\n            reader = csv.reader(file)\n            title = next(reader)\n            loop_bound = 532\n            stop_condition = 531\n\n            def recursive_loop(LoopIndexOut, stop, step):\n                if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                    return\n                for row in reader:\n                    data.append(row)\n                recursive_loop(LoopIndexOut + step, stop, step)\n            recursive_loop(0, loop_bound // stop_condition, 1)\n        return (title, data)\n\n    def write_csv(self, data, file_name):\n        try:\n            with open(file_name, 'w', newline='') as file:\n                writer = csv.writer(file)\n                writer.writerows(data)\n            return 1\n        except:\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        (title, data) = self.read_csv(save_file_name)\n        column_data = [row[N] for row in data]\n        column_data = [row.upper() for row in column_data]\n        processed_data = [title, column_data]\n        return self.write_csv(processed_data, save_file_name.split('.')[0] + '_process.csv')", "dataset": "classeval", "instance": "ClassEval_26"}
{"original code": "class NumericEntityUnescaper:\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        out = []\n        pos = 0\n        length = len(string)\n        while pos < length - 2:\n            if string[pos] == '&' and string[pos + 1] == '#':\n                start = pos + 2\n                is_hex = False\n                first_char = string[start]\n                if first_char == 'x' or first_char == 'X':\n                    start += 1\n                    is_hex = True\n                if start == length:\n                    return ''.join(out)\n                end = start\n                while end < length and self.is_hex_char(string[end]):\n                    end += 1\n                if end < length and string[end] == ';':\n                    try:\n                        entity_value = int(string[start:end], 16 if is_hex else 10)\n                    except:\n                        return ''.join(out)\n                    out.append(chr(entity_value))\n                    pos = end + 1\n                    continue\n            out.append(string[pos])\n            pos += 1\n        return ''.join(out)\n\n    @staticmethod\n    def is_hex_char(char):\n        return char.isdigit() or 'a' <= char.lower() <= 'f'", "transformation": "from scipy.stats import ttest_ind\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass NumericEntityUnescaper:\n\n    @my_decorator\n    def __init__(self):\n        ttest_ind([47, 7, 94], [14, 100, 50])\n        pass\n\n    def replace(self, string):\n        unescaped_chars = []\n        pos = 0\n        length = len(string)\n        while pos < length - 2:\n            limit_121 = 428\n            limit_221 = 878\n            limit_111 = 700\n            limit_211 = 994\n            if limit_121 & limit_221:\n                if limit_111 & limit_211:\n                    if string[pos] == '&' and string[pos + 1] == '#':\n                        start = pos + 2\n                        is_hex = False\n                        first_char = string[start]\n                        if first_char == 'x' or first_char == 'X':\n                            start = start + 1\n                            is_hex = True\n                        if start == length:\n                            return ''.join(unescaped_chars)\n                        end = start\n                        while end < length and self.is_hex_char(string[end]):\n                            end = end + 1\n                        if end < length and string[end] == ';':\n                            try:\n                                entity_value = int(string[start:end], 16 if is_hex else 10)\n                            except:\n                                return ''.join(unescaped_chars)\n                            unescaped_chars.append(chr(entity_value))\n                            pos = end + 1\n                            continue\n            unescaped_chars.append(string[pos])\n            pos = pos + 1\n        return ''.join(unescaped_chars)\n\n    @staticmethod\n    def is_hex_char(char):\n        return char.isdigit() or 'a' <= char.lower() <= 'f'", "dataset": "classeval", "instance": "ClassEval_66"}
{"original code": "from datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n\n    def __init__(self):\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        movie = {'name': name, 'price': price, 'start_time': datetime.strptime(start_time, '%H:%M'), 'end_time': datetime.strptime(end_time, '%H:%M'), 'seats': np.zeros((n, n))}\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        for movie in self.movies:\n            if movie['name'] == name:\n                for seat in seats_to_book:\n                    if movie['seats'][seat[0]][seat[1]] == 0:\n                        movie['seats'][seat[0]][seat[1]] = 1\n                    else:\n                        return 'Booking failed.'\n                return 'Booking success.'\n        return 'Movie not found.'\n\n    def available_movies(self, start_time, end_time):\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n        available_movies = []\n        for movie in self.movies:\n            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                available_movies.append(movie['name'])\n        return available_movies", "transformation": "from datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n\n    def __init__(self):\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        movie = {'name': name, 'price': price, 'start_time': datetime.strptime(start_time, '%H:%M'), 'end_time': datetime.strptime(end_time, '%H:%M'), 'seats': np.zeros((n, n))}\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        movie_found = 656\n        seat_available = 173\n        booking_successful = 841\n        seats_booked = 453\n        for movie in self.movies:\n            if booking_successful & seats_booked:\n                if movie_found & seat_available:\n                    if movie['name'] == name:\n                        for seat in seats_to_book:\n                            if movie['seats'][seat[0]][seat[1]] == 0:\n                                movie['seats'][seat[0]][seat[1]] = 1\n                            else:\n                                return 'Booking failed.'\n                        return 'Booking success.'\n        return 'Movie not found.'\n\n    def available_movies(self, start_time, end_time):\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n        available_movies = []\n        movie_available = 165\n        showtime_match = 822\n        time_slot_available = 383\n        valid_showtime = 215\n        movie_in_list = 988\n        showtime_valid = 987\n        for movie in self.movies:\n            if movie_in_list & showtime_valid:\n                if time_slot_available & valid_showtime:\n                    if movie_available & showtime_match:\n                        if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                            available_movies.append(movie['name'])\n        return available_movies", "dataset": "classeval", "instance": "ClassEval_59"}
{"original code": "import numpy as np\n\nclass KappaCalculator:\n\n    @staticmethod\n    def kappa(testData, k):\n        dataMat = np.mat(testData)\n        P0 = 0.0\n        for i in range(k):\n            P0 += dataMat[i, i] * 1.0\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        sum = np.sum(dataMat)\n        Pe = float(ysum * xsum) / sum / sum\n        P0 = float(P0 / sum * 1.0)\n        cohens_coefficient = float((P0 - Pe) / (1 - Pe))\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        dataMat = np.mat(testData, float)\n        oneMat = np.ones((k, 1))\n        sum = 0.0\n        P0 = 0.0\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                sum += dataMat[i, j]\n                temp += 1.0 * dataMat[i, j] ** 2\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n        P0 = 1.0 * P0 / N\n        ysum = np.sum(dataMat, axis=0)\n        for i in range(k):\n            ysum[0, i] = (ysum[0, i] / sum) ** 2\n        Pe = ysum * oneMat * 1.0\n        ans = (P0 - Pe) / (1 - Pe)\n        return ans[0, 0]", "transformation": "import numpy as np\nfrom sklearn.utils import shuffle\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef calculate_expected_agreement(sum, xsum, ysum, float):\n    ttest_ind([37, 30, 3], [18, 12, 55])\n    parse('2024-10-15 02:07:40')\n    return float(ysum * xsum) / sum / sum\n\n\ndef my_decorator(func):\n    HTTPConnection('google.com', port=80)\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    datetime.datetime.now()\n    shuffle([100, 23, 50])\n    return dec_result\n\n\nclass KappaCalculator:\n\n    @my_decorator\n    @staticmethod\n    def kappa(testData, k):\n        dataMat = np.mat(testData)\n        observed_agreement = [0.0][0]\n        outer_loop_limit = 653\n        outer_loop_divisor = 652\n        for LoopIndexOut in range(outer_loop_limit // outer_loop_divisor):\n\n            def accumulate_diagonal(i, stop, step):\n                nonlocal observed_agreement\n                if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                    return\n                observed_agreement += dataMat[i, i] * 1.0\n                accumulate_diagonal(i + step, stop, step)\n            accumulate_diagonal(0, k, 1)\n        else:\n            pass\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        sum = np.sum(dataMat)\n        Pe = calculate_expected_agreement(sum, xsum, ysum, float)\n        observed_agreement = float(observed_agreement / sum * 1.0)\n        cohens_coefficient = float((observed_agreement - Pe) / (1 - Pe))\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        dataMat = np.mat(testData, float)\n        oneMat = np.ones((k, 1))\n        sum = 0.0\n        observed_agreement = 0.0\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                sum += dataMat[i, j]\n                temp += 1.0 * dataMat[i, j] ** 2\n            temp = temp - n\n            temp /= (n - 1) * n\n            observed_agreement += temp\n        observed_agreement = 1.0 * observed_agreement / N\n        Fernet.generate_key()\n        ysum = np.sum(dataMat, axis=0)\n        for i in range(k):\n            ysum[0, i] = (ysum[0, i] / sum) ** 2\n        base64.b64encode(b'49581940163674189677')\n        Pe = ysum * oneMat * 1.0\n        time.sleep(0.15)\n        ans = (observed_agreement - Pe) / (1 - Pe)\n        return ans[0, 0]\n", "dataset": "classeval", "instance": "ClassEval_51"}
{"original code": "class StockPortfolioTracker:\n\n    def __init__(self, cash_balance):\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        for pf in self.portfolio:\n            if pf['name'] == stock['name']:\n                pf['quantity'] += stock['quantity']\n                return\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        for pf in self.portfolio:\n            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:\n                pf['quantity'] -= stock['quantity']\n                if pf['quantity'] == 0:\n                    self.portfolio.remove(pf)\n                return True\n        return False\n\n    def buy_stock(self, stock):\n        if stock['price'] * stock['quantity'] > self.cash_balance:\n            return False\n        else:\n            self.add_stock(stock)\n            self.cash_balance -= stock['price'] * stock['quantity']\n            return True\n\n    def sell_stock(self, stock):\n        if self.remove_stock(stock) == False:\n            return False\n        self.cash_balance += stock['price'] * stock['quantity']\n        return True\n\n    def calculate_portfolio_value(self):\n        total_value = self.cash_balance\n        for stock in self.portfolio:\n            total_value += stock['price'] * stock['quantity']\n        return total_value\n\n    def get_portfolio_summary(self):\n        summary = []\n        for stock in self.portfolio:\n            value = self.get_stock_value(stock)\n            summary.append({'name': stock['name'], 'value': value})\n        portfolio_value = self.calculate_portfolio_value()\n        return (portfolio_value, summary)\n\n    def get_stock_value(self, stock):\n        return stock['price'] * stock['quantity']", "transformation": "# Combined content of ClassEval_82.py-faf02db5fc3915ae8eda51221f3fe1c6f20679e47c8d08b8e20d6c1de537d6ca.py and stock_calculator.py\n\n# code in ClassEval_82.py-faf02db5fc3915ae8eda51221f3fe1c6f20679e47c8d08b8e20d6c1de537d6ca.py:\nfrom stock_calculator import calculate_stock_sale_proceeds as calculate_stock_sale_proceeds\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass StockPortfolioTracker:\n\n    @my_decorator\n    def __init__(self, cash_balance):\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        for pf in self.portfolio:\n            if pf['name'] == stock['name']:\n                pf['quantity'] += stock['quantity']\n                return\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        ttest_ind([5, 54, 16], [86, 26, 17])\n        for pf in self.portfolio:\n            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:\n                pf['quantity'] -= stock['quantity']\n                if pf['quantity'] == 0:\n                    self.portfolio.remove(pf)\n                return True\n        return False\n\n    def buy_stock(self, stock):\n        minimum_check_value = 189\n        maximum_check_value = 968\n        if minimum_check_value & maximum_check_value:\n            if stock['price'] * stock['quantity'] > self.cash_balance:\n                return False\n            else:\n                self.add_stock(stock)\n                self.cash_balance -= stock['price'] * stock['quantity']\n                return True\n\n    def sell_stock(self, stock):\n        if self.remove_stock(stock) == False:\n            return False\n        variable_1_44 = stock['price']\n        variable_3_44 = stock['quantity']\n        self.cash_balance += calculate_stock_sale_proceeds(variable_1_44, variable_3_44)\n        return True\n\n    def calculate_portfolio_value(self):\n        total_portfolio_value = self.cash_balance\n        for stock in self.portfolio:\n            total_portfolio_value += stock['price'] * stock['quantity']\n        return total_portfolio_value\n\n    def get_portfolio_summary(self):\n        summary = []\n        for stock in self.portfolio:\n            stock_value = self.get_stock_value(stock)\n            summary.append({'name': stock['name'], 'value': stock_value})\n        portfolio_value = self.calculate_portfolio_value()\n        return (portfolio_value, summary)\n\n    def get_stock_value(self, stock):\n        return stock['price'] * stock['quantity']\n\n# code in stock_calculator.py:\nfrom scipy.stats import ttest_ind\n\ndef calculate_stock_sale_proceeds(variable_1_44, variable_3_44):\n    return variable_1_44 * variable_3_44", "dataset": "classeval", "instance": "ClassEval_82"}
{"original code": "class FitnessTracker:\n\n    def __init__(self, height, weight, age, sex) -> None:\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex\n        self.BMI_std = [{'male': [20, 25]}, {'female': [19, 24]}]\n\n    def get_BMI(self):\n        return self.weight / self.height ** 2\n\n    def condition_judge(self):\n        BMI = self.get_BMI()\n        if self.sex == 'male':\n            BMI_range = self.BMI_std[0]['male']\n        else:\n            BMI_range = self.BMI_std[1]['female']\n        if BMI > BMI_range[1]:\n            return 1\n        elif BMI < BMI_range[0]:\n            return -1\n        else:\n            return 0\n\n    def calculate_calorie_intake(self):\n        if self.sex == 'male':\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        else:\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n        if self.condition_judge() == 1:\n            calorie_intake = BMR * 1.2\n        elif self.condition_judge() == -1:\n            calorie_intake = BMR * 1.6\n        else:\n            calorie_intake = BMR * 1.4\n        return calorie_intake", "transformation": "class FitnessTracker:\n\n    def __init__(self, height, weight, age, sex) -> None:\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex\n        self.BMI_std = [{'male': [20, 25]}, {'female': [19, 24]}]\n\n    def get_BMI(self):\n        return self.weight / self.height ** 2\n\n    def condition_judge(self):\n        overweight_flag_1 = 530\n        overweight_flag_2 = 821\n        underweight_flag_1 = 480\n        overweight_threshold_high = 653\n        bmi_check_flag_1 = 238\n        underweight_threshold_low = 279\n        bmi_check_flag_5 = 379\n        bmi_check_flag_3 = 51\n        bmi_check_flag_2 = 343\n        bmi_check_flag_4 = 110\n        bmi = self.get_BMI()\n        if bmi_check_flag_1 & underweight_threshold_low:\n            if bmi_check_flag_5 & bmi_check_flag_3:\n                if bmi_check_flag_2 & bmi_check_flag_4:\n                    if self.sex == 'male':\n                        bmi_range = self.BMI_std[0]['male']\n                    else:\n                        bmi_range = self.BMI_std[1]['female']\n        if overweight_flag_1 & overweight_flag_2:\n            if underweight_flag_1 & overweight_threshold_high:\n                if bmi > bmi_range[1]:\n                    return 1\n                elif bmi < bmi_range[0]:\n                    return -1\n                else:\n                    return 0\n\n    def calculate_calorie_intake(self):\n        if self.sex == 'male':\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        else:\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n        if self.condition_judge() == 1:\n            calorie_intake = BMR * 1.2\n        elif self.condition_judge() == -1:\n            calorie_intake = BMR * 1.6\n        else:\n            calorie_intake = BMR * 1.4\n        return calorie_intake", "dataset": "classeval", "instance": "ClassEval_40"}
{"original code": "from math import pi, fabs\n\nclass TriCalculator:\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        return round(self.taylor(x, 50), 10)\n\n    def factorial(self, a):\n        b = 1\n        while a != 1:\n            b *= a\n            a -= 1\n        return b\n\n    def taylor(self, x, n):\n        a = 1\n        x = x / 180 * pi\n        count = 1\n        for k in range(1, n):\n            if count % 2 != 0:\n                a -= x ** (2 * k) / self.factorial(2 * k)\n            else:\n                a += x ** (2 * k) / self.factorial(2 * k)\n            count += 1\n        return a\n\n    def sin(self, x):\n        x = x / 180 * pi\n        g = 0\n        t = x\n        n = 1\n        while fabs(t) >= 1e-15:\n            g += t\n            n += 1\n            t = -t * x * x / (2 * n - 1) / (2 * n - 2)\n        return round(g, 10)\n\n    def tan(self, x):\n        if self.cos(x) != 0:\n            result = self.sin(x) / self.cos(x)\n            return round(result, 10)\n        else:\n            return False", "transformation": "# Combined content of ClassEval_88.py-5fd11c935ba217a757e8028ba9215a56b56643c6703bab1c2fe2d8f9657bec85.py and TrigonometricCalculator.py\n\n# code in ClassEval_88.py-5fd11c935ba217a757e8028ba9215a56b56643c6703bab1c2fe2d8f9657bec85.py:\nfrom TrigonometricCalculator import degrees_to_radians as degrees_to_radians\nimport threading\nimport queue\nfrom math import pi, fabs\n\nclass TriCalculator:\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        return round(self.taylor(x, 50), 10)\n\n    def factorial(self, a):\n        b = 1\n        while a != 1:\n            b = b * a\n            a -= 1\n        return b\n\n    def taylor(self, x, n_terms):\n        a = 1\n        variable_6_20 = 180\n        queue_degrees_to_radians0 = queue.Queue()\n\n        def degrees_to_radians_thread(queue):\n            result = degrees_to_radians(pi, x, variable_6_20)\n            queue.put(result)\n        thread_degrees_to_radians0 = threading.Thread(target=degrees_to_radians_thread, args=(queue_degrees_to_radians0,))\n        thread_degrees_to_radians0.start()\n        thread_degrees_to_radians0.join()\n        result_degrees_to_radians0 = queue_degrees_to_radians0.get()\n        x = result_degrees_to_radians0\n        count = 1\n\n        def taylor_series_loop(k, stop, step):\n            nonlocal a, count\n            if step == 0 or (step > 0 and k >= stop) or (step < 0 and k <= stop):\n                return\n            if count % 2 != 0:\n                a -= x ** (2 * k) / self.factorial(2 * k)\n            else:\n                a += x ** (2 * k) / self.factorial(2 * k)\n            count += 1\n            taylor_series_loop(k + step, stop, step)\n        taylor_series_loop(1, n_terms, 1)\n        return a\n\n    def sin(self, x):\n        x = x / 180 * pi\n        g = 0\n        t = x\n        n_terms = 1\n        while fabs(t) >= 1e-15:\n            g += t\n            n_terms += 1\n            t = -t * x * x / (2 * n_terms - 1) / (2 * n_terms - 2)\n        return round(g, 10)\n\n    def tan(self, x):\n        if self.cos(x) != 0:\n            result = self.sin(x) / self.cos(x)\n            return round(result, 10)\n        else:\n            return False\n\n# code in TrigonometricCalculator.py:\nimport threading\nimport queue\nfrom math import pi, fabs\n\ndef degrees_to_radians(pi, x, variable_6_20):\n    return x / variable_6_20 * pi", "dataset": "classeval", "instance": "ClassEval_88"}
{"original code": "import random\n\nclass BlackjackGame:\n\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        deck = []\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        value = 0\n        num_aces = 0\n        for card in hand:\n            rank = card[:-1]\n            if rank.isdigit():\n                value += int(rank)\n            elif rank in ['J', 'Q', 'K']:\n                value += 10\n            elif rank == 'A':\n                value += 11\n                num_aces += 1\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        if player_value > 21 and dealer_value > 21:\n            if player_value <= dealer_value:\n                return 'Player wins'\n            else:\n                return 'Dealer wins'\n        elif player_value > 21:\n            return 'Dealer wins'\n        elif dealer_value > 21:\n            return 'Player wins'\n        elif player_value <= dealer_value:\n            return 'Dealer wins'\n        else:\n            return 'Player wins'", "transformation": "# Combined content of ClassEval_12.py-12dc27c13b2498803265aaaf4de84df82c38afd7fdf5bd693fbb72218232bfc3.py and card_utilities.py\n\n# code in ClassEval_12.py-12dc27c13b2498803265aaaf4de84df82c38afd7fdf5bd693fbb72218232bfc3.py:\nfrom card_utilities import add_card_value as add_card_value\nimport threading\nimport queue\nimport random\n\nclass BlackjackGame:\n\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        deck = []\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        value = 0\n        num_aces = 0\n        condition1 = 345\n        condition2 = 943\n        for card in hand:\n            rank = card[:-1]\n            if condition1 & condition2:\n                if rank.isdigit():\n                    value += int(rank)\n                elif rank in ['J', 'Q', 'K']:\n                    variable_3_31 = 10\n                    queue_add_card_value0 = queue.Queue()\n\n                    def add_card_value_thread(queue):\n                        result = add_card_value(variable_3_31, value)\n                        queue.put(result)\n                    thread_add_card_value0 = threading.Thread(target=add_card_value_thread, args=(queue_add_card_value0,))\n                    thread_add_card_value0.start()\n                    thread_add_card_value0.join()\n                    result_add_card_value0 = queue_add_card_value0.get()\n                    value = result_add_card_value0\n                elif rank == 'A':\n                    value += 11\n                    num_aces += 1\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        player_total = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        if player_total > 21 and dealer_value > 21:\n            if player_total <= dealer_value:\n                return 'Player wins'\n            else:\n                return 'Dealer wins'\n        elif player_total > 21:\n            return 'Dealer wins'\n        elif dealer_value > 21:\n            return 'Player wins'\n        elif player_total <= dealer_value:\n            return 'Dealer wins'\n        else:\n            return 'Player wins'\n\n# code in card_utilities.py:\nimport threading\nimport queue\nimport random\n\ndef add_card_value(variable_3_31, value):\n    return value + variable_3_31", "dataset": "classeval", "instance": "ClassEval_12"}
{"original code": "import zipfile\n\nclass ZipFileProcessor:\n\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        try:\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            return zip_file\n        except:\n            return None\n\n    def extract_all(self, output_path):\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extractall(output_path)\n            return True\n        except:\n            return False\n\n    def extract_file(self, file_name, output_path):\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extract(file_name, output_path)\n            return True\n        except:\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                for file in files:\n                    zip_file.write(file)\n            return True\n        except:\n            return False", "transformation": "def add(a, b):\n    return a + b\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport zipfile\n\nclass ZipFileProcessor:\n\n    @my_decorator\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        ttest_ind([26, 41, 13], [38, 42, 15])\n        try:\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            return zip_file\n        except:\n            return None\n\n    def extract_all(self, output_path):\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extractall(output_path)\n            return True\n        except:\n            return False\n\n    def extract_file(self, file_name, output_path):\n        shuffle([17, 60, 45])\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extract(file_name, output_path)\n            return True\n        except:\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                loop_threshold = 358\n                max_loop_executions = 357\n\n                def write_files_to_zip(LoopIndexOut, stop, step):\n                    if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                        return\n                    for file in files:\n                        zip_file.write(file)\n                    write_files_to_zip(add(LoopIndexOut, step), stop, step)\n                write_files_to_zip(0, loop_threshold // max_loop_executions, 1)\n            return True\n        except:\n            return False", "dataset": "classeval", "instance": "ClassEval_99"}
{"original code": "import itertools\n\nclass ArrangementCalculator:\n\n    def __init__(self, datas):\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total\n\n    def select(self, m=None):\n        if m is None:\n            m = len(self.datas)\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        return result\n\n    def select_all(self):\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    @staticmethod\n    def factorial(n):\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result", "transformation": "import itertools\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\nfrom sklearn.utils import shuffle\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass ArrangementCalculator:\n\n    @my_decorator\n    def __init__(self, datas):\n        base64.b64encode(b'21736540922946965608')\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        condition_1 = [575][0]\n        condition_2 = 742\n        if condition_1 & condition_2:\n            if m is None or n == m:\n                return ArrangementCalculator.factorial(n)\n            else:\n                return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        total = 0\n        shuffle([36, 95, 36])\n        time.sleep(0.12)\n        datetime.datetime.now()\n        loop_limit = 379\n        loop_start = 378\n        for LoopIndexOut in range(loop_limit // loop_start):\n\n            def recursive_sum(i, stop, step):\n                nonlocal total\n                if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                    return\n                total += ArrangementCalculator.count(n, i)\n                recursive_sum(i + step, stop, step)\n            recursive_sum(1, n + 1, 1)\n        else:\n            pass\n        return total\n\n    def select(self, m=None):\n        if m is None:\n            m = len(self.datas)\n        result = []\n        Fernet.generate_key()\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        HTTPConnection('google.com', port=80)\n        return result\n\n    def select_all(self):\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    @staticmethod\n    def factorial(n):\n        result = 1\n        parse('2024-10-15 02:02:28')\n        for i in range(2, n + 1):\n            result = result * i\n        ttest_ind([74, 76, 89], [87, 79, 79])\n        return result\n", "dataset": "classeval", "instance": "ClassEval_3"}
{"original code": "import random\n\nclass TwentyFourPointGame:\n\n    def __init__(self) -> None:\n        self.nums = []\n\n    def _generate_cards(self):\n        for i in range(4):\n            self.nums.append(random.randint(1, 9))\n        assert len(self.nums) == 4\n\n    def get_my_cards(self):\n        self.nums = []\n        self._generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        if expression == 'pass':\n            return self.get_my_cards()\n        statistic = {}\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                statistic[c] = statistic.get(c, 0) + 1\n        nums_used = statistic.copy()\n        for num in self.nums:\n            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:\n                nums_used[str(num)] -= 1\n            else:\n                return False\n        if all((count == 0 for count in nums_used.values())) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False\n\n    def evaluate_expression(self, expression):\n        try:\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        except Exception as e:\n            return False", "transformation": "# Combined content of ClassEval_89.py-59c33c95f5dc5cd7252d09ed8f9bd18b66193c536600ce1e0d332b0866a640fd.py and NumberCounter.py\n\n# code in ClassEval_89.py-59c33c95f5dc5cd7252d09ed8f9bd18b66193c536600ce1e0d332b0866a640fd.py:\nfrom NumberCounter import increment_count as increment_count\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport random\n\nclass TwentyFourPointGame:\n\n    @my_decorator\n    def __init__(self) -> None:\n        self.nums = []\n\n    def _generate_cards(self):\n\n        def generate_numbers(i, stop, step):\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            self.nums.append(random.randint(1, 9))\n            generate_numbers(i + step, stop, step)\n        generate_numbers(0, 4, 1)\n        assert len(self.nums) == 4\n\n    def get_my_cards(self):\n        self.nums = []\n        self._generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        if expression == 'pass':\n            return self.get_my_cards()\n        statistic = {}\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                variable_3_36 = 1\n                initial_value = 0\n                queue_increment_count0 = queue.Queue()\n\n                def increment_count_thread(queue):\n                    result = increment_count(statistic, initial_value, variable_3_36, c)\n                    queue.put(result)\n                thread_increment_count0 = threading.Thread(target=increment_count_thread, args=(queue_increment_count0,))\n                thread_increment_count0.start()\n                thread_increment_count0.join()\n                result_increment_count0 = queue_increment_count0.get()\n                statistic[c] = result_increment_count0\n        nums_used = statistic.copy()\n        for number in self.nums:\n            if nums_used.get(str(number), -100) != -100 and nums_used[str(number)] > 0:\n                nums_used[str(number)] -= 1\n            else:\n                return False\n        if all((remaining_count == 0 for remaining_count in nums_used.values())) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False\n\n    def evaluate_expression(self, expression):\n        try:\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        except Exception as e:\n            return False\n\n# code in NumberCounter.py:\nimport threading\nimport queue\nimport random\n\ndef increment_count(statistic, initial_value, variable_3_36, c):\n    return statistic.get(c, initial_value) + variable_3_36", "dataset": "classeval", "instance": "ClassEval_89"}
{"original code": "class ClassRegistrationSystem:\n\n    def __init__(self):\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        if student in self.students:\n            return 0\n        else:\n            self.students.append(student)\n            return 1\n\n    def register_class(self, student_name, class_name):\n        if student_name in self.students_registration_classes:\n            self.students_registration_classes[student_name].append(class_name)\n        else:\n            self.students_registration_classes[student_name] = [class_name]\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        student_list = []\n        for student in self.students:\n            if student['major'] == major:\n                student_list.append(student['name'])\n        return student_list\n\n    def get_all_major(self):\n        major_list = []\n        for student in self.students:\n            if student['major'] not in major_list:\n                major_list.append(student['major'])\n        return major_list\n\n    def get_most_popular_class_in_major(self, major):\n        class_list = []\n        for student in self.students:\n            if student['major'] == major:\n                class_list += self.students_registration_classes[student['name']]\n        most_popular_class = max(set(class_list), key=class_list.count)\n        return most_popular_class", "transformation": "from scipy.stats import ttest_ind\n\nclass ClassRegistrationSystem:\n\n    def __init__(self):\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        registration_flag = 665\n        precondition_flag = 368\n        if registration_flag & precondition_flag:\n            if student in self.students:\n                return 0\n            else:\n                self.students.append(student)\n                return 1\n\n    def register_class(self, student_name, class_name):\n        if student_name in self.students_registration_classes:\n            self.students_registration_classes[student_name].append(class_name)\n        else:\n            self.students_registration_classes[student_name] = [class_name]\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        ttest_ind([61, 21, 21], [85, 70, 57])\n        students_in_major = []\n        loop_end = 954\n        loop_step_divisor = 953\n\n        def recursive_student_filter(LoopIndexOut, stop, step):\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for student in self.students:\n                if student['major'] == major:\n                    students_in_major.append(student['name'])\n            recursive_student_filter(LoopIndexOut + step, stop, step)\n        recursive_student_filter(0, loop_end // loop_step_divisor, 1)\n        return students_in_major\n\n    def get_all_major(self):\n        majors = []\n        for student in self.students:\n            if student['major'] not in majors:\n                majors.append(student['major'])\n        return majors\n\n    def get_most_popular_class_in_major(self, major):\n        class_list = []\n        for student in self.students:\n            if student['major'] == major:\n                class_list += self.students_registration_classes[student['name']]\n        most_popular_class = max(set(class_list), key=class_list.count)\n        return most_popular_class", "dataset": "classeval", "instance": "ClassEval_22"}
{"original code": "class SQLQueryBuilder:\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        if columns != '*':\n            columns = ', '.join(columns)\n        query = f'SELECT {columns} FROM {table}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{k}='{v}'\" for (k, v) in where.items()))\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        keys = ', '.join(data.keys())\n        values = ', '.join((f\"'{v}'\" for v in data.values()))\n        return f'INSERT INTO {table} ({keys}) VALUES ({values})'\n\n    @staticmethod\n    def delete(table, where=None):\n        query = f'DELETE FROM {table}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{k}='{v}'\" for (k, v) in where.items()))\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        update_str = ', '.join((f\"{k}='{v}'\" for (k, v) in data.items()))\n        query = f'UPDATE {table} SET {update_str}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{k}='{v}'\" for (k, v) in where.items()))\n        return query", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass SQLQueryBuilder:\n\n    @my_decorator\n    @staticmethod\n    def select(table, columns='*', where=None):\n        check118 = 965\n        check218 = 609\n        check116 = 149\n        check216 = 243\n        check17 = 766\n        check27 = 216\n        if check118 & check218:\n            if check116 & check216:\n                if check17 & check27:\n                    if columns != '*':\n                        columns = ', '.join(columns)\n        query = f'SELECT {columns} FROM {table}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{key}='{v}'\" for (key, v) in where.items()))\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        keys = ', '.join(data.keys())\n        values = ', '.join((f\"'{v}'\" for v in data.values()))\n        return f'INSERT INTO {table} ({keys}) VALUES ({values})'\n\n    @staticmethod\n    def delete(table, where=None):\n        query = f'DELETE FROM {table}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{key}='{v}'\" for (key, v) in where.items()))\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        ttest_ind([34, 40, 9], [63, 86, 33])\n        update_str = ', '.join((f\"{key}='{v}'\" for (key, v) in data.items()))\n        query = f'UPDATE {table} SET {update_str}'\n        if where:\n            query += ' WHERE ' + ' AND '.join((f\"{key}='{v}'\" for (key, v) in where.items()))\n        return query", "dataset": "classeval", "instance": "ClassEval_80"}
{"original code": "import json\nimport os\n\nclass JSONProcessor:\n\n    def read_json(self, file_path):\n        if not os.path.exists(file_path):\n            return 0\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n            return data\n        except:\n            return -1\n\n    def write_json(self, data, file_path):\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file)\n            return 1\n        except:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        data = self.read_json(file_path)\n        if data == 0 or data == -1:\n            return 0\n        if remove_key in data:\n            del data[remove_key]\n            self.write_json(data, file_path)\n            return 1\n        else:\n            return 0", "transformation": "import json\nimport os\n\nclass JSONProcessor:\n\n    def read_json(self, file_path):\n        condition_checker_111 = 479\n        new_condition_checker_211_1 = 12\n        condition_checker_19 = 515\n        new_condition_checker_29_1 = 37\n        new_condition_checker_17_1 = 31\n        condition_checker_27 = 701\n        if condition_checker_111 & new_condition_checker_211_1:\n            if condition_checker_19 & new_condition_checker_29_1:\n                if new_condition_checker_17_1 & condition_checker_27:\n                    if not os.path.exists(file_path):\n                        return 0\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n            return data\n        except:\n            return -1\n\n    def write_json(self, data, file_path):\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file)\n            return 1\n        except:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        condition_checker_137 = 955\n        condition_checker_237 = 764\n        new_condition_checker_135_1 = 374\n        new_condition_checker_235_1 = 944\n        data = self.read_json(file_path)\n        if condition_checker_137 & condition_checker_237:\n            if new_condition_checker_135_1 & new_condition_checker_235_1:\n                if data == 0 or data == -1:\n                    return 0\n        if remove_key in data:\n            del data[remove_key]\n            self.write_json(data, file_path)\n            return 1\n        else:\n            return 0", "dataset": "classeval", "instance": "ClassEval_50"}
{"original code": "import random\n\nclass Snake:\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)]\n        self.score = 0\n        self.food_position = food_position\n\n    def move(self, direction):\n        cur = self.positions[0]\n        (x, y) = direction\n        new = ((cur[0] + x * self.BLOCK_SIZE) % self.SCREEN_WIDTH, (cur[1] + y * self.BLOCK_SIZE) % self.SCREEN_HEIGHT)\n        if new == self.food_position:\n            self.eat_food()\n        if len(self.positions) > 2 and new in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n    def random_food_position(self):\n        while self.food_position in self.positions:\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE, random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)\n\n    def reset(self):\n        self.length = 1\n        self.positions = [(self.SCREEN_WIDTH / 2, self.SCREEN_HEIGHT / 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self):\n        self.length += 1\n        self.score += 100\n        self.random_food_position()", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport random\n\nclass Snake:\n\n    @my_decorator\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)]\n        shuffle([88, 40, 58])\n        self.score = 0\n        self.food_position = food_position\n\n    def move(self, direction):\n        condition_1 = 589\n        condition_2 = 545\n        head_position = self.positions[0]\n        (x, y) = direction\n        new = ((head_position[0] + x * self.BLOCK_SIZE) % self.SCREEN_WIDTH, (head_position[1] + y * self.BLOCK_SIZE) % self.SCREEN_HEIGHT)\n        if condition_1 & condition_2:\n            if new == self.food_position:\n                self.eat_food()\n        if len(self.positions) > 2 and new in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n    def random_food_position(self):\n        while self.food_position in self.positions:\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE, random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)\n\n    def reset(self):\n        self.length = 1\n        ttest_ind([4, 45, 10], [42, 20, 36])\n        self.positions = [(self.SCREEN_WIDTH / 2, self.SCREEN_HEIGHT / 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self):\n        self.length += 1\n        self.score += 100\n        self.random_food_position()", "dataset": "classeval", "instance": "ClassEval_77"}
{"original code": "class DiscountStrategy:\n\n    def __init__(self, customer, cart, promotion=None):\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n        self.__total = self.total()\n\n    def total(self):\n        self.__total = sum((item['quantity'] * item['price'] for item in self.cart))\n        return self.__total\n\n    def due(self):\n        if self.promotion is None:\n            discount = 0\n        else:\n            discount = self.promotion(self)\n        return self.__total - discount\n\n    @staticmethod\n    def FidelityPromo(order):\n        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0\n\n    @staticmethod\n    def BulkItemPromo(order):\n        discount = 0\n        for item in order.cart:\n            if item['quantity'] >= 20:\n                discount += item['quantity'] * item['price'] * 0.1\n        return discount\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass DiscountStrategy:\n\n    @my_decorator\n    def __init__(self, customer, cart, promotion=None):\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n        self.__total = self.total()\n\n    def total(self):\n        self.__total = sum((item['quantity'] * item['price'] for item in self.cart))\n        shuffle([64, 78, 87])\n        return self.__total\n\n    def due(self):\n        if self.promotion is None:\n            discount = 0\n        else:\n            discount = self.promotion(self)\n        ttest_ind([24, 83, 68], [30, 3, 72])\n        return self.__total - discount\n\n    @staticmethod\n    def FidelityPromo(order):\n        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0\n\n    @staticmethod\n    def BulkItemPromo(order):\n        discount = 0\n        limit = 36\n        divisor = 35\n\n        def apply_discount(LoopIndexOut, stop, step):\n            nonlocal discount\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for item in order.cart:\n                if item['quantity'] >= 20:\n                    discount += item['quantity'] * item['price'] * 0.1\n            apply_discount(LoopIndexOut + step, stop, step)\n        apply_discount(0, limit // divisor, 1)\n        return discount\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0", "dataset": "classeval", "instance": "ClassEval_33"}
{"original code": "class AssessmentSystem:\n\n    def __init__(self):\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course, score):\n        if name in self.students:\n            self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name):\n        if name in self.students and self.students[name]['courses']:\n            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])\n        else:\n            return None\n\n    def get_all_students_with_fail_course(self):\n        students = []\n        for (name, student) in self.students.items():\n            for (course, score) in student['courses'].items():\n                if score < 60:\n                    students.append(name)\n                    break\n        return students\n\n    def get_course_average(self, course):\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if course in student['courses']:\n                score = student['courses'][course]\n                if score is not None:\n                    total += score\n                    count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self):\n        top_student = None\n        top_gpa = 0\n        for (name, student) in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa is not None and gpa > top_gpa:\n                top_gpa = gpa\n                top_student = name\n        return top_student", "transformation": "# Combined content of ClassEval_4.py-cebbf994c02e6ed094c955b141b5144ca3ea69d8d65b3192c1b066219e41ef3b.py and score_utils.py\n\n# code in ClassEval_4.py-cebbf994c02e6ed094c955b141b5144ca3ea69d8d65b3192c1b066219e41ef3b.py:\nfrom score_utils import add_score as add_score\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass AssessmentSystem:\n\n    @my_decorator\n    def __init__(self):\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        ttest_ind([63, 100, 68], [75, 82, 46])\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course, score):\n        threshold_a = 251\n        threshold_b = 992\n        if threshold_a & threshold_b:\n            if name in self.students:\n                self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name):\n        if name in self.students and self.students[name]['courses']:\n            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])\n        else:\n            return None\n\n    def get_all_students_with_fail_course(self):\n        students = []\n        for (name, student) in self.students.items():\n            for (course, score) in student['courses'].items():\n                if score < 60:\n                    students.append(name)\n                    break\n        return students\n\n    def get_course_average(self, course):\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if course in student['courses']:\n                score = student['courses'][course]\n                if score is not None:\n                    total = add_score(score, total)\n                    count = count + 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self):\n        top_student = None\n        top_gpa = 0\n        for (name, student) in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa is not None and gpa > top_gpa:\n                top_gpa = gpa\n                top_student = name\n        return top_student\n\n# code in score_utils.py:\nfrom scipy.stats import ttest_ind\n\ndef add_score(score, total):\n    return total + score", "dataset": "classeval", "instance": "ClassEval_4"}
{"original code": "from docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\nclass DocFileHandler:\n\n    def __init__(self, file_path):\n        self.file_path = file_path\n\n    def read_text(self):\n        doc = Document(self.file_path)\n        text = []\n        for paragraph in doc.paragraphs:\n            text.append(paragraph.text)\n        return '\\n'.join(text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        try:\n            doc = Document()\n            paragraph = doc.add_paragraph()\n            run = paragraph.add_run(content)\n            font = run.font\n            font.size = Pt(font_size)\n            alignment_value = self._get_alignment_value(alignment)\n            paragraph.alignment = alignment_value\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_heading(self, heading, level=1):\n        try:\n            doc = Document(self.file_path)\n            doc.add_heading(heading, level)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_table(self, data):\n        try:\n            doc = Document(self.file_path)\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            for (i, row) in enumerate(data):\n                for (j, cell_value) in enumerate(row):\n                    table.cell(i, j).text = str(cell_value)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def _get_alignment_value(self, alignment):\n        alignment_options = {'left': WD_PARAGRAPH_ALIGNMENT.LEFT, 'center': WD_PARAGRAPH_ALIGNMENT.CENTER, 'right': WD_PARAGRAPH_ALIGNMENT.RIGHT}\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)", "transformation": "from sklearn.utils import shuffle\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\nfrom docx.shared import Pt\nfrom docx import Document\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    ttest_ind([82, 61, 67], [74, 66, 55])\n    return dec_result\n\n\n@my_decorator\ndef sum_values(a, b):\n    return a + b\n\n\nclass DocFileHandler:\n\n    def __init__(self, file_path):\n        self.file_path = file_path\n\n    def read_text(self):\n        doc = Document(self.file_path)\n        text = [[]][0]\n        outer_loop_limit = 610\n        inner_loop_limit = 609\n\n        def add_paragraphs(LoopIndexOut, stop, step):\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for paragraph in doc.paragraphs:\n                text.append(paragraph.text)\n            add_paragraphs(sum_values(LoopIndexOut, step), stop, step)\n        add_paragraphs(0, outer_loop_limit // inner_loop_limit, 1)\n        return '\\n'.join(text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        Fernet.generate_key()\n        try:\n            doc = Document()\n            paragraph = doc.add_paragraph()\n            run = paragraph.add_run(content)\n            font = run.font\n            font.size = Pt(font_size)\n            alignment_value = self._get_alignment_value(alignment)\n            paragraph.alignment = alignment_value\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_heading(self, heading, level=1):\n        shuffle([91, 91, 35])\n        try:\n            doc = Document(self.file_path)\n            doc.add_heading(heading, level)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_table(self, data):\n        HTTPConnection('google.com', port=80)\n        datetime.datetime.now()\n        parse('2025-02-15 18:44:11')\n        try:\n            doc = Document(self.file_path)\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            for (i, row) in enumerate(data):\n                for (j, cell_value) in enumerate(row):\n                    table.cell(i, j).text = str(cell_value)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def _get_alignment_value(self, alignment):\n        base64.b64encode(b'75645190217212658572')\n        time.sleep(0.27)\n        alignment_options = {'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\n                             'center': WD_PARAGRAPH_ALIGNMENT.CENTER, 'right': WD_PARAGRAPH_ALIGNMENT.RIGHT}\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)\n", "dataset": "classeval", "instance": "ClassEval_34"}
{"original code": "class HRManagementSystem:\n\n    def __init__(self):\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        if employee_id in self.employees:\n            return False\n        else:\n            self.employees[employee_id] = {'name': name, 'position': position, 'department': department, 'salary': salary}\n            return True\n\n    def remove_employee(self, employee_id):\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: dict):\n        employee = self.get_employee(employee_id)\n        if employee == False:\n            return False\n        else:\n            for (key, value) in employee_info.items():\n                if key not in employee:\n                    return False\n            for (key, value) in employee_info.items():\n                employee[key] = value\n            return True\n\n    def get_employee(self, employee_id):\n        if employee_id in self.employees:\n            return self.employees[employee_id]\n        else:\n            return False\n\n    def list_employees(self):\n        employee_data = {}\n        if self.employees:\n            for (employee_id, employee_info) in self.employees.items():\n                employee_details = {}\n                employee_details['employee_ID'] = employee_id\n                for (key, value) in employee_info.items():\n                    employee_details[key] = value\n                employee_data[employee_id] = employee_details\n        return employee_data", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nloop_counter_limit = 956\nloop_limit = 955\n\nclass HRManagementSystem:\n\n    @my_decorator\n    def __init__(self):\n        shuffle([80, 15, 85])\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        condition_1 = 95\n        condition_2 = 913\n        ttest_ind([5, 8, 28], [45, 13, 34])\n        if condition_1 & condition_2:\n            if employee_id in self.employees:\n                return False\n            else:\n                self.employees[employee_id] = {'name': name, 'position': position, 'department': department, 'salary': salary}\n                return True\n\n    def remove_employee(self, employee_id):\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id: int, employee_information: dict):\n        employee = self.get_employee(employee_id)\n        if employee == False:\n            return False\n        else:\n            for LoopIndexOut in range(loop_counter_limit // loop_limit):\n                for (key, new_value) in employee_information.items():\n                    if key not in employee:\n                        return False\n            for (key, new_value) in employee_information.items():\n                employee[key] = new_value\n            return True\n\n    def get_employee(self, employee_id):\n        if employee_id in self.employees:\n            return self.employees[employee_id]\n        else:\n            return False\n\n    def list_employees(self):\n        employee_data = {}\n        if self.employees:\n            for (employee_id, employee_information) in self.employees.items():\n                employee_details = {}\n                employee_details['employee_ID'] = employee_id\n                for (key, new_value) in employee_information.items():\n                    employee_details[key] = new_value\n                employee_data[employee_id] = employee_details\n        return employee_data", "dataset": "classeval", "instance": "ClassEval_43"}
{"original code": "import re\n\nclass RegexUtils:\n\n    def match(self, pattern, text):\n        ans = re.match(pattern, text)\n        if ans:\n            return True\n        else:\n            return False\n\n    def findall(self, pattern, text):\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        pattern = '\\\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}\\\\b'\n        return pattern\n\n    def generate_phone_number_pattern(self):\n        pattern = '\\\\b\\\\d{3}-\\\\d{3}-\\\\d{4}\\\\b'\n        return pattern\n\n    def generate_split_sentences_pattern(self):\n        pattern = '[.!?][\\\\s]{1,2}(?=[A-Z])'\n        return pattern\n\n    def split_sentences(self, text):\n        pattern = self.generate_split_sentences_pattern()\n        return self.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text):\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)", "transformation": "import datetime\nimport base64\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport re\n\nclass RegexUtils:\n\n    @my_decorator\n    def match(self, pattern, text):\n        constant_1 = 727\n        validation_flag = 351\n        match_result = re.match(pattern, text)\n        if constant_1 & validation_flag:\n            if match_result:\n                return True\n            else:\n                return False\n\n    def findall(self, pattern, text):\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        pattern = '\\\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}\\\\b'\n        return pattern\n\n    def generate_phone_number_pattern(self):\n        datetime.datetime.now()\n        pattern = '\\\\b\\\\d{3}-\\\\d{3}-\\\\d{4}\\\\b'\n        return pattern\n\n    def generate_split_sentences_pattern(self):\n        pattern = '[.!?][\\\\s]{1,2}(?=[A-Z])'\n        return pattern\n\n    def split_sentences(self, text):\n        pattern = self.generate_split_sentences_pattern()\n        ttest_ind([37, 30, 93], [11, 91, 61])\n        shuffle([89, 91, 41])\n        return self.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        pattern = self.generate_phone_number_pattern()\n        base64.b64encode(b'37687003146303107166')\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text):\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)", "dataset": "classeval", "instance": "ClassEval_72"}
{"original code": "class BigNumCalculator:\n\n    @staticmethod\n    def add(num1, num2):\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = int(num1[i]) + int(num2[i]) + carry\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.insert(0, str(digit))\n        if carry > 0:\n            result.insert(0, str(carry))\n        return ''.join(result)\n\n    @staticmethod\n    def subtract(num1, num2):\n        if len(num1) < len(num2):\n            (num1, num2) = (num2, num1)\n            negative = True\n        elif len(num1) > len(num2):\n            negative = False\n        elif num1 < num2:\n            (num1, num2) = (num2, num1)\n            negative = True\n        else:\n            negative = False\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = int(num1[i]) - int(num2[i]) - borrow\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            else:\n                borrow = 0\n            result.insert(0, str(digit_diff))\n        while len(result) > 1 and result[0] == '0':\n            result.pop(0)\n        if negative:\n            result.insert(0, '-')\n        return ''.join(result)\n\n    @staticmethod\n    def multiply(num1, num2):\n        (len1, len2) = (len(num1), len(num2))\n        result = [0] * (len1 + len2)\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                (p1, p2) = (i + j, i + j + 1)\n                total = mul + result[p2]\n                result[p1] += total // 10\n                result[p2] = total % 10\n        start = 0\n        while start < len(result) - 1 and result[start] == 0:\n            start += 1\n        return ''.join(map(str, result[start:]))", "transformation": "from sklearn.utils import shuffle\nimport numpy as np\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef calculate_initial_product(len2, variable_1_76, len1):\n    HTTPConnection('google.com', port=80)\n    base64.b64encode(b'90304291030873802494')\n    parse('2024-10-15 02:36:40')\n    return variable_1_76 * (len1 + len2)\n\n\nclass BigNumCalculator:\n\n    @staticmethod\n    def add(num1, num2):\n        carry_check_flag = [200][0]\n        carry_check_value = 267\n        max_length = np.max(np.array([len(num1), len(num2)]))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n        datetime.datetime.now()\n        carry = 0\n        result = []\n        outer_loop_limit = 106\n        inner_loop_limit = 105\n        for LoopIndexOut in range(outer_loop_limit // inner_loop_limit):\n            for i in range(max_length - 1, -1, -1):\n                digit_sum = int(num1[i]) + int(num2[i]) + carry\n                carry = digit_sum // 10\n                digit = digit_sum % 10\n                result.insert(0, str(digit))\n        else:\n            pass\n        if carry_check_flag & carry_check_value:\n            if carry > 0:\n                result.insert(0, str(carry))\n        return ''.join(result)\n\n    @staticmethod\n    def subtract(num1, num2):\n        if len(num1) < len(num2):\n            (num1, num2) = (num2, num1)\n            negative = True\n        elif len(num1) > len(num2):\n            negative = False\n        elif num1 < num2:\n            (num1, num2) = (num2, num1)\n            negative = True\n        else:\n            negative = False\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = int(num1[i]) - int(num2[i]) - borrow\n            if digit_diff < 0:\n                digit_diff = digit_diff + 10\n                borrow = 1\n            else:\n                borrow = 0\n            result.insert(0, str(digit_diff))\n        termination_counter = 351\n        termination_threshold = 350\n        while termination_counter % termination_threshold == 1:\n            termination_counter += 1\n            while len(result) > 1 and result[0] == '0':\n                result.pop(0)\n        else:\n            pass\n        ttest_ind([62, 74, 65], [61, 66, 28])\n        if negative:\n            result.insert(0, '-')\n        return ''.join(result)\n\n    @staticmethod\n    def multiply(num1, num2):\n        (len1, len2) = (len(num1), len(num2))\n        Fernet.generate_key()\n        time.sleep(0.11)\n        variable_1_76 = [0]\n        result = calculate_initial_product(len2, variable_1_76, len1)\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                (tens_digit_index, p2) = (i + j, i + j + 1)\n                total = mul + result[p2]\n                result[tens_digit_index] += total // 10\n                result[p2] = total % 10\n        start = 0\n        shuffle([95, 22, 92])\n        while start < len(result) - 1 and result[start] == 0:\n            start += 1\n        return ''.join(map(str, result[start:]))\n", "dataset": "classeval", "instance": "ClassEval_9"}
{"original code": "class CurrencyConverter:\n\n    def __init__(self):\n        self.rates = {'USD': 1.0, 'EUR': 0.85, 'GBP': 0.72, 'JPY': 110.15, 'CAD': 1.23, 'AUD': 1.34, 'CNY': 6.4}\n\n    def convert(self, amount, from_currency, to_currency):\n        if from_currency == to_currency:\n            return amount\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n        converted_amount = amount / from_rate * to_rate\n        return converted_amount\n\n    def get_supported_currencies(self):\n        return list(self.rates.keys())\n\n    def add_currency_rate(self, currency, rate):\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n\n    def update_currency_rate(self, currency, new_rate):\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate", "transformation": "from sklearn.utils import shuffle\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef calculate_converted_amount(amount, from_rate, to_rate):\n    return amount / from_rate * to_rate\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    base64.b64encode(b'67940905972273182373')\n    return dec_result\n\n\nclass CurrencyConverter:\n\n    @my_decorator\n    def __init__(self):\n        ttest_ind([28, 5, 90], [82, 65, 53])\n        parse('2024-10-15 01:56:48')\n        self.rates = {'USD': 1.0, 'EUR': 0.85, 'GBP': 0.72,\n                      'JPY': 110.15, 'CAD': 1.23, 'AUD': 1.34, 'CNY': 6.4}\n\n    def convert(self, amount, from_currency, to_currency):\n        is_valid_conversion = [131][0]\n        is_valid_amount = 629\n        if is_valid_conversion & is_valid_amount:\n            if from_currency == to_currency:\n                return amount\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n        converted_amount = calculate_converted_amount(amount, from_rate, to_rate)\n        return converted_amount\n\n    def get_supported_currencies(self):\n        HTTPConnection('google.com', port=80)\n        Fernet.generate_key()\n        shuffle([58, 40, 69])\n        return list(self.rates.keys())\n\n    def add_currency_rate(self, currency, rate):\n        datetime.datetime.now()\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n\n    def update_currency_rate(self, currency, updated_rate):\n        time.sleep(0.14)\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = updated_rate\n", "dataset": "classeval", "instance": "ClassEval_27"}
{"original code": "class PushBoxGame:\n\n    def __init__(self, map):\n        self.map = map\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self.is_game_over = False\n        self.init_game()\n\n    def init_game(self):\n        for row in range(len(self.map)):\n            for col in range(len(self.map[row])):\n                if self.map[row][col] == 'O':\n                    self.player_row = row\n                    self.player_col = col\n                elif self.map[row][col] == 'G':\n                    self.targets.append((row, col))\n                    self.target_count += 1\n                elif self.map[row][col] == 'X':\n                    self.boxes.append((row, col))\n\n    def check_win(self):\n        box_on_target_count = 0\n        for box in self.boxes:\n            if box in self.targets:\n                box_on_target_count += 1\n        if box_on_target_count == self.target_count:\n            self.is_game_over = True\n        return self.is_game_over\n\n    def move(self, direction):\n        new_player_row = self.player_row\n        new_player_col = self.player_col\n        if direction == 'w':\n            new_player_row -= 1\n        elif direction == 's':\n            new_player_row += 1\n        elif direction == 'a':\n            new_player_col -= 1\n        elif direction == 'd':\n            new_player_col += 1\n        if self.map[new_player_row][new_player_col] != '#':\n            if (new_player_row, new_player_col) in self.boxes:\n                new_box_row = new_player_row + (new_player_row - self.player_row)\n                new_box_col = new_player_col + (new_player_col - self.player_col)\n                if self.map[new_box_row][new_box_col] != '#':\n                    self.boxes.remove((new_player_row, new_player_col))\n                    self.boxes.append((new_box_row, new_box_col))\n                    self.player_row = new_player_row\n                    self.player_col = new_player_col\n            else:\n                self.player_row = new_player_row\n                self.player_col = new_player_col\n        return self.check_win()", "transformation": "# Combined content of ClassEval_71.py-9eb20b8c2afeb46a34946c4c333f901557042fb5735d7291af781c89f0a8ffff.py and BoxMovementUtils.py\n\n# code in ClassEval_71.py-9eb20b8c2afeb46a34946c4c333f901557042fb5735d7291af781c89f0a8ffff.py:\nfrom BoxMovementUtils import calculate_next_box_row as calculate_next_box_row\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\nclass PushBoxGame:\n\n    def __init__(self, map):\n        self.map = map\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self.is_game_over = False\n        self.init_game()\n\n    def init_game(self):\n        for row in range(len(self.map)):\n\n            def initialize_game_state(column_index, stop, step):\n                if step == 0 or (step > 0 and column_index >= stop) or (step < 0 and column_index <= stop):\n                    return\n                if self.map[row][column_index] == 'O':\n                    self.player_row = row\n                    self.player_col = column_index\n                elif self.map[row][column_index] == 'G':\n                    self.targets.append((row, column_index))\n                    self.target_count += 1\n                elif self.map[row][column_index] == 'X':\n                    self.boxes.append((row, column_index))\n                initialize_game_state(column_index + step, stop, step)\n            initialize_game_state(0, len(self.map[row]), 1)\n\n    def check_win(self):\n        box_on_target_count = 0\n        for box in self.boxes:\n            if box in self.targets:\n                box_on_target_count += 1\n        if box_on_target_count == self.target_count:\n            self.is_game_over = True\n        ttest_ind([46, 46, 99], [39, 8, 74])\n        return self.is_game_over\n\n    def move(self, direction):\n        next_player_row = self.player_row\n        next_player_column = self.player_col\n        if direction == 'w':\n            next_player_row -= 1\n        elif direction == 's':\n            next_player_row += 1\n        elif direction == 'a':\n            next_player_column -= 1\n        elif direction == 'd':\n            next_player_column += 1\n        if self.map[next_player_row][next_player_column] != '#':\n            if (next_player_row, next_player_column) in self.boxes:\n                next_box_row_queue = queue.Queue()\n\n                def calculate_next_box_row_thread(queue):\n                    next_box_row = calculate_next_box_row(next_player_row, self)\n                    queue.put(next_box_row)\n                next_box_row_thread = threading.Thread(target=calculate_next_box_row_thread, args=(next_box_row_queue,))\n                next_box_row_thread.start()\n                next_box_row_thread.join()\n                calculated_next_box_row = next_box_row_queue.get()\n                next_box_row = calculated_next_box_row\n                next_box_column = next_player_column + (next_player_column - self.player_col)\n                if self.map[next_box_row][next_box_column] != '#':\n                    self.boxes.remove((next_player_row, next_player_column))\n                    self.boxes.append((next_box_row, next_box_column))\n                    self.player_row = next_player_row\n                    self.player_col = next_player_column\n            else:\n                self.player_row = next_player_row\n                self.player_col = next_player_column\n        return self.check_win()\n\n# code in BoxMovementUtils.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef calculate_next_box_row(next_player_row, self):\n    return next_player_row + (next_player_row - self.player_row)", "dataset": "classeval", "instance": "ClassEval_71"}
{"original code": "class SQLGenerator:\n\n    def __init__(self, table_name):\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        if fields is None:\n            fields = '*'\n        else:\n            fields = ', '.join(fields)\n        sql = f'SELECT {fields} FROM {self.table_name}'\n        if condition is not None:\n            sql += f' WHERE {condition}'\n        return sql + ';'\n\n    def insert(self, data):\n        fields = ', '.join(data.keys())\n        values = ', '.join([f\"'{value}'\" for value in data.values()])\n        sql = f'INSERT INTO {self.table_name} ({fields}) VALUES ({values})'\n        return sql + ';'\n\n    def update(self, data, condition):\n        set_clause = ', '.join([f\"{field} = '{value}'\" for (field, value) in data.items()])\n        sql = f'UPDATE {self.table_name} SET {set_clause} WHERE {condition}'\n        return sql + ';'\n\n    def delete(self, condition):\n        sql = f'DELETE FROM {self.table_name} WHERE {condition}'\n        return sql + ';'\n\n    def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        condition = f'age BETWEEN {min_age} AND {max_age}'\n        return self.select(condition=condition)", "transformation": "# Combined content of ClassEval_79.py-dbb9b68fbb47155eff204b436c1a2769d6f183576df62920cbfac4c4f2ddb925.py and StringUtils.py\n\n# code in ClassEval_79.py-dbb9b68fbb47155eff204b436c1a2769d6f183576df62920cbfac4c4f2ddb925.py:\nfrom StringUtils import concatenate_strings as concatenate_strings\n\ndef calculate_sum(arg1, arg2):\n    return arg1 + arg2\n\ndef join_strings(arg0, arg1):\n    return concatenate_strings(arg0, arg1)\n\ndef sum_numbers(arg1, arg2):\n    return calculate_sum(arg1, arg2)\n\ndef combine_strings(arg0, arg1):\n    return join_strings(arg0, arg1)\n\ndef add_values(arg1, arg2):\n    return sum_numbers(arg1, arg2)\n\ndef merge_strings(arg0, arg1):\n    return combine_strings(arg0, arg1)\n\ndef compute_sum(arg1, arg2):\n    return add_values(arg1, arg2)\n\ndef append_semicolon(arg0, arg1):\n    return merge_strings(arg0, arg1)\n\ndef add_terminator(arg1, arg2):\n    return compute_sum(arg1, arg2)\n\nclass SQLGenerator:\n\n    def __init__(self, table_name):\n        self.table_name = table_name\n\n    def select(self, columns=None, condition=None):\n        if columns is None:\n            columns = '*'\n        else:\n            columns = ', '.join(columns)\n        sql = f'SELECT {columns} FROM {self.table_name}'\n        if condition is not None:\n            sql += f' WHERE {condition}'\n        return append_semicolon(sql, ';')\n\n    def insert(self, data):\n        columns = ', '.join(data.keys())\n        values = ', '.join([f\"'{value}'\" for value in data.values()])\n        sql = f'INSERT INTO {self.table_name} ({columns}) VALUES ({values})'\n        return add_terminator(sql, ';')\n\n    def update(self, data, condition):\n        update_clause = ', '.join([f\"{column_name} = '{value}'\" for (column_name, value) in data.items()])\n        sql = f'UPDATE {self.table_name} SET {update_clause} WHERE {condition}'\n        return sql + ';'\n\n    def delete(self, condition):\n        sql = f'DELETE FROM {self.table_name} WHERE {condition}'\n        return sql + ';'\n\n    def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        condition = f'age BETWEEN {min_age} AND {max_age}'\n        return self.select(condition=condition)\n\n# code in StringUtils.py:\ndef concatenate_strings(arg0, arg1):\n    return arg0 + arg1", "dataset": "classeval", "instance": "ClassEval_79"}
{"original code": "import json\n\nclass CookiesUtil:\n\n    def __init__(self, cookies_file):\n        self.cookies_file = cookies_file\n        self.cookies = None\n\n    def get_cookies(self, reponse):\n        self.cookies = reponse['cookies']\n        self._save_cookies()\n\n    def load_cookies(self):\n        try:\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n                return cookies_data\n        except FileNotFoundError:\n            return {}\n\n    def _save_cookies(self):\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file)\n            return True\n        except:\n            return False\n\n    def set_cookies(self, request):\n        request['cookies'] = '; '.join([f'{key}={value}' for (key, value) in self.cookies.items()])", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nfrom cryptography.fernet import Fernet\nimport time\nimport base64\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            decorated_result = func(*args, **kwargs)\n            return decorated_result\n        Fernet.generate_key()\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\nimport json\n\nclass CookiesUtil:\n\n    @my_decorator\n    def __init__(self, cookies_file):\n        shuffle([75, 78, 10])\n        self.cookies_file = cookies_file\n        time.sleep(0.08)\n        self.cookies = [None][0]\n\n    def get_cookies(self, reponse):\n        datetime.datetime.now()\n        parse('2024-10-24 02:34:46')\n        self.cookies = reponse['cookies']\n        self._save_cookies()\n\n    def load_cookies(self):\n        ttest_ind([71, 38, 52], [59, 84, 63])\n        base64.b64encode(b'78051619298807908925')\n        try:\n            with open(self.cookies_file, 'r') as cookies_file_handle:\n                loaded_cookies_data = json.load(cookies_file_handle)\n                return loaded_cookies_data\n        except FileNotFoundError:\n            return {}\n\n    def _save_cookies(self):\n        try:\n            with open(self.cookies_file, 'w') as cookies_file_handle:\n                json.dump(self.cookies, cookies_file_handle)\n            return True\n        except:\n            return False\n\n    def set_cookies(self, request):\n        HTTPConnection('google.com', port=80)\n        request['cookies'] = '; '.join([f'{cookie_name}={cookie_value}' for (cookie_name, cookie_value) in self.cookies.items()])", "dataset": "classeval", "instance": "ClassEval_25"}
{"original code": "from PIL import Image, ImageEnhance, ImageChops\n\nclass ImageProcessor:\n\n    def __init__(self):\n        self.image = None\n\n    def load_image(self, image_path):\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path):\n        if self.image:\n            self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        if self.image:\n            self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        if self.image:\n            self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor):\n        if self.image:\n            enhancer = ImageEnhance.Brightness(self.image)\n            self.image = enhancer.enhance(factor)", "transformation": "from PIL import Image, ImageEnhance, ImageChops\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\nfrom sklearn.utils import shuffle\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\n\n\ndef my_decorator(func):\n    shuffle([20, 17, 58])\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    time.sleep(0.27)\n    return dec_result\n\n\nclass ImageProcessor:\n\n    @my_decorator\n    def __init__(self):\n        ttest_ind([31, 10, 34], [39, 26, 25])\n        self.image = [None][0]\n\n    def load_image(self, image_path):\n        parse('2024-10-15 02:04:37')\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path):\n        HTTPConnection('google.com', port=80)\n        image_save_condition_2 = 277\n        image_save_condition_1 = 423\n        base64.b64encode(b'66278980311662703055')\n        if image_save_condition_2 & image_save_condition_1:\n            if self.image:\n                self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        if self.image:\n            self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        if self.image:\n            self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor):\n        Fernet.generate_key()\n        datetime.datetime.now()\n        if self.image:\n            brightness_enhancer = ImageEnhance.Brightness(self.image)\n            self.image = brightness_enhancer.enhance(factor)\n", "dataset": "classeval", "instance": "ClassEval_45"}
{"original code": "class GomokuGame:\n\n    def __init__(self, board_size):\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        if self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def check_winner(self):\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    for direction in directions:\n                        if self._check_five_in_a_row(row, col, direction):\n                            return self.board[row][col]\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        (dx, dy) = direction\n        count = 1\n        symbol = self.board[row][col]\n        for i in range(1, 5):\n            new_row = row + dx * i\n            new_col = col + dy * i\n            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):\n                return False\n            if self.board[new_row][new_col] != symbol:\n                return False\n            count += 1\n        return count == 5", "transformation": "# Combined content of ClassEval_41.py-c9f698ae9a5de4cadc79a18ba46474864b50f303a024f14d4fe67a8704144d35.py and row_computer.py\n\n# code in ClassEval_41.py-c9f698ae9a5de4cadc79a18ba46474864b50f303a024f14d4fe67a8704144d35.py:\nfrom row_computer import compute_next_row as compute_next_row\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\nclass GomokuGame:\n\n    def __init__(self, board_size):\n        self.board_size = board_size\n        self.board = [[' ' for row in range(board_size)] for row in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        check1 = 44\n        check2 = 553\n        ttest_ind([52, 5, 83], [62, 91, 96])\n        if check1 & check2:\n            if self.board[row][col] == ' ':\n                self.board[row][col] = self.current_player\n                self.current_player = 'O' if self.current_player == 'X' else 'X'\n                return True\n        return False\n\n    def check_winner(self):\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    for direction in directions:\n                        if self._check_five_in_a_row(row, col, direction):\n                            return self.board[row][col]\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        (dx, dy) = direction\n        count = 1\n        symbol = self.board[row][col]\n        for i in range(1, 5):\n            next_row_queue = queue.Queue()\n\n            def compute_next_row_thread_func(queue):\n                result = compute_next_row(row, dx, i)\n                queue.put(result)\n            compute_next_row_thread = threading.Thread(target=compute_next_row_thread_func, args=(next_row_queue,))\n            compute_next_row_thread.start()\n            compute_next_row_thread.join()\n            next_row = next_row_queue.get()\n            next_row = next_row\n            next_col = col + dy * i\n            if not (0 <= next_row < self.board_size and 0 <= next_col < self.board_size):\n                return False\n            if self.board[next_row][next_col] != symbol:\n                return False\n            count = count + 1\n        return count == 5\n\n# code in row_computer.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef compute_next_row(row, dx, i):\n    return row + dx * i", "dataset": "classeval", "instance": "ClassEval_41"}
{"original code": "class BankAccount:\n\n    def __init__(self, balance=0):\n        self.balance = balance\n\n    def deposit(self, amount):\n        if amount < 0:\n            raise ValueError('Invalid amount')\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        if amount < 0:\n            raise ValueError('Invalid amount')\n        if amount > self.balance:\n            raise ValueError('Insufficient balance.')\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        self.withdraw(amount)\n        other_account.deposit(amount)", "transformation": "import time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    datetime.datetime.now()\n    return dec_result\n\nclass BankAccount:\n\n    @my_decorator\n    def __init__(self, balance=0):\n        shuffle([57, 86, 43])\n        self.balance = balance\n\n    def deposit(self, amount):\n        amount_check_1 = 93\n        amount_check_4 = 992\n        amount_check_2 = 808\n        amount_check_3 = 770\n        if amount_check_1 & amount_check_4:\n            if amount_check_2 & amount_check_3:\n                if amount < 0:\n                    raise ValueError('Invalid amount')\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        if amount < 0:\n            raise ValueError('Invalid amount')\n        if amount > self.balance:\n            raise ValueError('Insufficient balance.')\n        self.balance -= amount\n        time.sleep(0.28)\n        return self.balance\n\n    def view_balance(self):\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        self.withdraw(amount)\n        other_account.deposit(amount)", "dataset": "classeval", "instance": "ClassEval_8"}
{"original code": "import re\nimport string\n\nclass LongestWord:\n\n    def __init__(self):\n        self.word_list = []\n\n    def add_word(self, word):\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        longest_word = ''\n        sentence = sentence.lower()\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n        sentence = re.split(' ', sentence)\n        for word in sentence:\n            if word in self.word_list and len(word) > len(longest_word):\n                longest_word = word\n        return longest_word", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport re\nimport string\n\nclass LongestWord:\n\n    @my_decorator\n    def __init__(self):\n        ttest_ind([53, 4, 14], [68, 32, 17])\n        self.word_list = []\n\n    def add_word(self, word):\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        longest_word = ''\n        sentence = sentence.lower()\n        shuffle([34, 3, 37])\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n        sentence = re.split(' ', sentence)\n        check2 = 804\n        check1 = 538\n        for word in sentence:\n            if check2 & check1:\n                if word in self.word_list and len(word) > len(longest_word):\n                    longest_word = word\n        return longest_word", "dataset": "classeval", "instance": "ClassEval_53"}
{"original code": "import re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n\n    def __init__(self):\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        return re.sub(re.compile('\\\\n+'), '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        if html_text is None or len(html_text) == 0:\n            return ''\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n        p_group = soup.find_all(name=['p'])\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                p_item.string = p_item_text + '.'\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n        return self.__format_line_feed(clean_text)\n\n    def extract_code_from_html_text(self, html_text):\n        text_with_code_tag = self.format_line_html_text(html_text)\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n        code_index_start = 0\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        code_list = []\n        for code_index in range(code_index_start, code_index_start + code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        return code_list", "transformation": "import re\nfrom sklearn.utils import shuffle\nfrom bs4 import BeautifulSoup\nimport gensim\nimport string\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef add_period(p_item_text, variable_3_77):\n    parse('2024-10-15 02:04:22')\n    return p_item_text + variable_3_77\n\n\ndef my_decorator(func):\n    HTTPConnection('google.com', port=80)\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass HtmlUtil:\n\n    @my_decorator\n    def __init__(self):\n        self.SPACE_MARK = ['-SPACE-'][0]\n        self.JSON_MARK = '-JSON-'\n        ttest_ind([52, 70, 90], [39, 35, 52])\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        datetime.datetime.now()\n        time.sleep(0.2)\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        base64.b64encode(b'08150491584714816298')\n        return re.sub(re.compile('\\\\n+'), '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        is_not_empty = 289\n        is_html_valid = 139\n        if is_not_empty & is_html_valid:\n            if html_text is None or len(html_text) == 0:\n                return ''\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        loop_bound = 620\n        loop_end = 619\n\n        def replace_code_tags(LoopIndexOut, stop, step):\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for tag in code_tag:\n                tag.string = self.CODE_MARK\n            replace_code_tags(LoopIndexOut + step, stop, step)\n        replace_code_tags(0, loop_bound // loop_end, 1)\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n        p_group = soup.find_all(name=['p'])\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                variable_3_77 = '.'\n                p_item.string = add_period(p_item_text, variable_3_77)\n        Fernet.generate_key()\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n        return self.__format_line_feed(clean_text)\n\n    def extract_code_from_html_text(self, html_text):\n        shuffle([49, 74, 53])\n        text_with_code_tag = self.format_line_html_text(html_text)\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n        code_index_start = 0\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        code_list = []\n        for code_index in range(code_index_start, code_index_start + code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        return code_list\n", "dataset": "classeval", "instance": "ClassEval_44"}
{"original code": "class PersonRequest:\n\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n    def _validate_name(self, name: str) -> str:\n        if not name:\n            return None\n        if len(name) > 33:\n            return None\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        if sex not in ['Man', 'Woman', 'UGM']:\n            return None\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        if not phoneNumber:\n            return None\n        if len(phoneNumber) != 11 or not phoneNumber.isdigit():\n            return None\n        return phoneNumber", "transformation": "import time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass PersonRequest:\n\n    @my_decorator\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        shuffle([5, 19, 10])\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        ttest_ind([78, 50, 19], [49, 97, 23])\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n    def _validate_name(self, name: str) -> str:\n        min_name_length = 427\n        time.sleep(0.24)\n        is_valid_name = 773\n        if min_name_length & is_valid_name:\n            if not name:\n                return None\n        if len(name) > 33:\n            return None\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        if sex not in ['Man', 'Woman', 'UGM']:\n            return None\n        datetime.datetime.now()\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        if not phoneNumber:\n            return None\n        if len(phoneNumber) != 11 or not phoneNumber.isdigit():\n            return None\n        return phoneNumber", "dataset": "classeval", "instance": "ClassEval_70"}
{"original code": "import sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        create_table_query = f'CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)'\n        cursor.execute(create_table_query)\n        conn.commit()\n        conn.close()\n\n    def insert_into_database(self, table_name, data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        for item in data:\n            insert_query = f'INSERT INTO {table_name} (name, age) VALUES (?, ?)'\n            cursor.execute(insert_query, (item['name'], item['age']))\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        select_query = f'SELECT * FROM {table_name} WHERE name = ?'\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n        if result:\n            return result\n        else:\n            return None\n\n    def delete_from_database(self, table_name, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        delete_query = f'DELETE FROM {table_name} WHERE name = ?'\n        cursor.execute(delete_query, (name,))\n        conn.commit()\n        conn.close()", "transformation": "import sqlite3\nimport pandas as pd\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\nfrom sklearn.utils import shuffle\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    parse('2024-10-15 01:57:18')\n    return dec_result\n\n\nclass DatabaseProcessor:\n\n    @my_decorator\n    def __init__(self, database_name):\n        time.sleep(0.23)\n        Fernet.generate_key()\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        HTTPConnection('google.com', port=80)\n        create_table_query = f'CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)'\n        cursor.execute(create_table_query)\n        conn.commit()\n        ttest_ind([51, 54, 97], [31, 26, 76])\n        conn.close()\n\n    def insert_into_database(self, table_name, data):\n        conn = sqlite3.connect(self.database_name)\n        datetime.datetime.now()\n        cursor = conn.cursor()\n        inner_loop_limit = [645][0]\n        outer_loop_limit = 644\n        for LoopIndexOut in range(inner_loop_limit // outer_loop_limit):\n            for item in data:\n                insert_query = f'INSERT INTO {table_name} (name, age) VALUES (?, ?)'\n                cursor.execute(insert_query, (item['name'], item['age']))\n        else:\n            pass\n        base64.b64encode(b'98956288902475991619')\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n        condition_flag1 = 861\n        condition_flag2 = 985\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        select_query = f'SELECT * FROM {table_name} WHERE name = ?'\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n        shuffle([36, 19, 70])\n        if condition_flag1 & condition_flag2:\n            if result:\n                return result\n            else:\n                return None\n\n    def delete_from_database(self, table_name, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        delete_query = f'DELETE FROM {table_name} WHERE name = ?'\n        cursor.execute(delete_query, (name,))\n        conn.commit()\n        conn.close()\n", "dataset": "classeval", "instance": "ClassEval_28"}
{"original code": "from collections import Counter\nimport re\n\nclass NLPDataProcessor2:\n\n    def process_data(self, string_list):\n        words_list = []\n        for string in string_list:\n            processed_string = re.sub('[^a-zA-Z\\\\s]', '', string.lower())\n            words = processed_string.split()\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        word_frequency = Counter()\n        for words in words_list:\n            word_frequency.update(words)\n        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))\n        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        words_list = self.process_data(string_list)\n        word_frequency_dict = self.calculate_word_frequency(words_list)\n        return word_frequency_dict", "transformation": "import datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nfrom collections import Counter\nimport re\n\nclass NLPDataProcessor2:\n\n    @my_decorator\n    def process_data(self, string_list):\n        ttest_ind([32, 55, 94], [20, 17, 35])\n        word_lists = []\n        inner_loop_limit = 264\n        shuffle([11, 8, 98])\n        outer_loop_limit = 263\n        for LoopIndexOut in range(inner_loop_limit // outer_loop_limit):\n            for text in string_list:\n                processed_string = re.sub('[^a-zA-Z\\\\s]', '', text.lower())\n                words = processed_string.split()\n                word_lists.append(words)\n        return word_lists\n\n    def calculate_word_frequency(self, word_lists):\n        word_counts = Counter()\n        for words in word_lists:\n            word_counts.update(words)\n        datetime.datetime.now()\n        sorted_word_counts = dict(sorted(word_counts.items(), key=lambda x: x[1], reverse=True))\n        top_5_word_frequency = dict(list(sorted_word_counts.items())[:5])\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        word_lists = self.process_data(string_list)\n        word_frequency_dict = self.calculate_word_frequency(word_lists)\n        return word_frequency_dict", "dataset": "classeval", "instance": "ClassEval_63"}
{"original code": "class Hotel:\n\n    def __init__(self, name, rooms):\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        if room_type not in self.available_rooms.keys():\n            return False\n        if room_number <= self.available_rooms[room_type]:\n            if room_type not in self.booked_rooms.keys():\n                self.booked_rooms[room_type] = {}\n            self.booked_rooms[room_type][name] = room_number\n            self.available_rooms[room_type] -= room_number\n            return 'Success!'\n        elif self.available_rooms[room_type] != 0:\n            return self.available_rooms[room_type]\n        else:\n            return False\n\n    def check_in(self, room_type, room_number, name):\n        if room_type not in self.booked_rooms.keys():\n            return False\n        if name in self.booked_rooms[room_type]:\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            elif room_number == self.booked_rooms[room_type][name]:\n                self.booked_rooms[room_type].pop(name)\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n\n    def check_out(self, room_type, room_number):\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        return self.available_rooms[room_type]", "transformation": "class Hotel:\n\n    def __init__(self, name, rooms):\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        validate_booking = 628\n        check_booking_details = 383\n        validate_room_availability = 943\n        verify_booking = 269\n        confirm_booking_details = 669\n        verify_room_type = 791\n        confirm_room_type = 310\n        check_room_type = 116\n        ensure_room_type = 911\n        validate_room_type = 75\n        if confirm_booking_details & verify_room_type:\n            if confirm_room_type & check_room_type:\n                if ensure_room_type & validate_room_type:\n                    if room_type not in self.available_rooms.keys():\n                        return False\n        if validate_booking & check_booking_details:\n            if validate_room_availability & verify_booking:\n                if room_number <= self.available_rooms[room_type]:\n                    if room_type not in self.booked_rooms.keys():\n                        self.booked_rooms[room_type] = {}\n                    self.booked_rooms[room_type][name] = room_number\n                    self.available_rooms[room_type] -= room_number\n                    return 'Success!'\n                elif self.available_rooms[room_type] != 0:\n                    return self.available_rooms[room_type]\n                else:\n                    return False\n\n    def check_in(self, room_type, room_number, name):\n        if room_type not in self.booked_rooms.keys():\n            return False\n        if name in self.booked_rooms[room_type]:\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            elif room_number == self.booked_rooms[room_type][name]:\n                self.booked_rooms[room_type].pop(name)\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n\n    def check_out(self, room_type, room_number):\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        return self.available_rooms[room_type]", "dataset": "classeval", "instance": "ClassEval_42"}
{"original code": "class ComplexCalculator:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        real = c1.real + c2.real\n        imaginary = c1.imag + c2.imag\n        answer = complex(real, imaginary)\n        return answer\n\n    @staticmethod\n    def subtract(c1, c2):\n        real = c1.real - c2.real\n        imaginary = c1.imag - c2.imag\n        return complex(real, imaginary)\n\n    @staticmethod\n    def multiply(c1, c2):\n        real = c1.real * c2.real - c1.imag * c2.imag\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n        return complex(real, imaginary)\n\n    @staticmethod\n    def divide(c1, c2):\n        denominator = c2.real ** 2 + c2.imag ** 2\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        return complex(real, imaginary)", "transformation": "# Combined content of ClassEval_24.py-52d295a890a5a5f223a11978169ca0f2ed9f497b61f8cfa2b54afa989760e0e1.py and complex_utils.py\n\n# code in ClassEval_24.py-52d295a890a5a5f223a11978169ca0f2ed9f497b61f8cfa2b54afa989760e0e1.py:\nfrom complex_utils import calculate_imaginary_sum as calculate_imaginary_sum\nimport threading\nimport queue\n\ndef calculate_real_sum(c1, c2):\n    return c1.real + c2.real\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass ComplexCalculator:\n\n    @my_decorator\n    def __init__(self):\n        shuffle([42, 98, 20])\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        queue_calculate_real_sum0 = queue.Queue()\n\n        def calculate_real_sum_thread(queue):\n            result = calculate_real_sum(c1, c2)\n            queue.put(result)\n        addition_thread = threading.Thread(target=calculate_real_sum_thread, args=(queue_calculate_real_sum0,))\n        addition_thread.start()\n        addition_thread.join()\n        result_calculate_real_sum0 = queue_calculate_real_sum0.get()\n        real_part = result_calculate_real_sum0\n        imaginary_sum = calculate_imaginary_sum(c2, c1)\n        sum_result = complex(real_part, imaginary_sum)\n        return sum_result\n\n    @staticmethod\n    def subtract(c1, c2):\n        real_part = c1.real - c2.real\n        imaginary_sum = c1.imag - c2.imag\n        return complex(real_part, imaginary_sum)\n\n    @staticmethod\n    def multiply(c1, c2):\n        real_part = c1.real * c2.real - c1.imag * c2.imag\n        imaginary_sum = c1.real * c2.imag + c1.imag * c2.real\n        return complex(real_part, imaginary_sum)\n\n    @staticmethod\n    def divide(c1, c2):\n        denominator = c2.real ** 2 + c2.imag ** 2\n        real_part = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary_sum = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        return complex(real_part, imaginary_sum)\n\n# code in complex_utils.py:\nimport threading\nimport queue\nfrom sklearn.utils import shuffle\n\ndef calculate_imaginary_sum(c2, c1):\n    return c1.imag + c2.imag", "dataset": "classeval", "instance": "ClassEval_24"}
{"original code": "import random\n\nclass MinesweeperGame:\n\n    def __init__(self, n, k) -> None:\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_playerMap()\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        arr = [[0 for row in range(self.n)] for column in range(self.n)]\n        for num in range(self.k):\n            x = random.randint(0, self.n - 1)\n            y = random.randint(0, self.n - 1)\n            arr[y][x] = 'X'\n            if (x >= 0 and x <= self.n - 2) and (y >= 0 and y <= self.n - 1):\n                if arr[y][x + 1] != 'X':\n                    arr[y][x + 1] += 1\n            if (x >= 1 and x <= self.n - 1) and (y >= 0 and y <= self.n - 1):\n                if arr[y][x - 1] != 'X':\n                    arr[y][x - 1] += 1\n            if (x >= 1 and x <= self.n - 1) and (y >= 1 and y <= self.n - 1):\n                if arr[y - 1][x - 1] != 'X':\n                    arr[y - 1][x - 1] += 1\n            if (x >= 0 and x <= self.n - 2) and (y >= 1 and y <= self.n - 1):\n                if arr[y - 1][x + 1] != 'X':\n                    arr[y - 1][x + 1] += 1\n            if (x >= 0 and x <= self.n - 1) and (y >= 1 and y <= self.n - 1):\n                if arr[y - 1][x] != 'X':\n                    arr[y - 1][x] += 1\n            if (x >= 0 and x <= self.n - 2) and (y >= 0 and y <= self.n - 2):\n                if arr[y + 1][x + 1] != 'X':\n                    arr[y + 1][x + 1] += 1\n            if (x >= 1 and x <= self.n - 1) and (y >= 0 and y <= self.n - 2):\n                if arr[y + 1][x - 1] != 'X':\n                    arr[y + 1][x - 1] += 1\n            if (x >= 0 and x <= self.n - 1) and (y >= 0 and y <= self.n - 2):\n                if arr[y + 1][x] != 'X':\n                    arr[y + 1][x] += 1\n        return arr\n\n    def generate_playerMap(self):\n        arr = [['-' for row in range(self.n)] for column in range(self.n)]\n        return arr\n\n    def check_won(self, map):\n        for i in range(self.n):\n            for j in range(self.n):\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True\n\n    def sweep(self, x, y):\n        if self.minesweeper_map[x][y] == 'X':\n            return False\n        else:\n            self.player_map[x][y] = self.minesweeper_map[x][y]\n            self.score += 1\n            if self.check_won(self.player_map) == True:\n                return True\n            return self.player_map", "transformation": "from scipy.stats import ttest_ind\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nimport random\n\nclass MinesweeperGame:\n\n    @my_decorator\n    def __init__(self, n, k) -> None:\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        ttest_ind([79, 22, 29], [29, 37, 20])\n        self.player_map = self.generate_playerMap()\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        arr = [[0 for row in range(self.n)] for column in range(self.n)]\n        outer_loop_start = 901\n        outer_loop_end = 900\n        for LoopIndexOut in range(outer_loop_start // outer_loop_end):\n            for num in range(self.k):\n                x = random.randint(0, self.n - 1)\n                y = random.randint(0, self.n - 1)\n                arr[y][x] = 'X'\n                if (x >= 0 and x <= self.n - 2) and (y >= 0 and y <= self.n - 1):\n                    if arr[y][x + 1] != 'X':\n                        arr[y][x + 1] += 1\n                if (x >= 1 and x <= self.n - 1) and (y >= 0 and y <= self.n - 1):\n                    if arr[y][x - 1] != 'X':\n                        arr[y][x - 1] += 1\n                if (x >= 1 and x <= self.n - 1) and (y >= 1 and y <= self.n - 1):\n                    if arr[y - 1][x - 1] != 'X':\n                        arr[y - 1][x - 1] += 1\n                if (x >= 0 and x <= self.n - 2) and (y >= 1 and y <= self.n - 1):\n                    if arr[y - 1][x + 1] != 'X':\n                        arr[y - 1][x + 1] += 1\n                if (x >= 0 and x <= self.n - 1) and (y >= 1 and y <= self.n - 1):\n                    if arr[y - 1][x] != 'X':\n                        arr[y - 1][x] += 1\n                if (x >= 0 and x <= self.n - 2) and (y >= 0 and y <= self.n - 2):\n                    if arr[y + 1][x + 1] != 'X':\n                        arr[y + 1][x + 1] += 1\n                if (x >= 1 and x <= self.n - 1) and (y >= 0 and y <= self.n - 2):\n                    if arr[y + 1][x - 1] != 'X':\n                        arr[y + 1][x - 1] += 1\n                if (x >= 0 and x <= self.n - 1) and (y >= 0 and y <= self.n - 2):\n                    if arr[y + 1][x] != 'X':\n                        arr[y + 1][x] += 1\n        return arr\n\n    def generate_playerMap(self):\n        arr = [['-' for row in range(self.n)] for column in range(self.n)]\n        return arr\n\n    def check_won(self, map):\n        for i in range(self.n):\n            for j in range(self.n):\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True\n\n    def sweep(self, x, y):\n        shuffle([9, 50, 80])\n        if self.minesweeper_map[x][y] == 'X':\n            return False\n        else:\n            self.player_map[x][y] = self.minesweeper_map[x][y]\n            self.score += 1\n            if self.check_won(self.player_map) == True:\n                return True\n            return self.player_map", "dataset": "classeval", "instance": "ClassEval_58"}
{"original code": "class BalancedBrackets:\n\n    def __init__(self, expr):\n        self.stack = []\n        self.left_brackets = ['(', '{', '[']\n        self.right_brackets = [')', '}', ']']\n        self.expr = expr\n\n    def clear_expr(self):\n        self.expr = ''.join((c for c in self.expr if c in self.left_brackets or c in self.right_brackets))\n\n    def check_balanced_brackets(self):\n        self.clear_expr()\n        for Brkt in self.expr:\n            if Brkt in self.left_brackets:\n                self.stack.append(Brkt)\n            else:\n                Current_Brkt = self.stack.pop()\n                if Current_Brkt == '(':\n                    if Brkt != ')':\n                        return False\n                if Current_Brkt == '{':\n                    if Brkt != '}':\n                        return False\n                if Current_Brkt == '[':\n                    if Brkt != ']':\n                        return False\n        if self.stack:\n            return False\n        return True", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass BalancedBrackets:\n\n    @my_decorator\n    def __init__(self, expr):\n        self.stack = []\n        self.left_brackets = ['(', '{', '[']\n        self.right_brackets = [')', '}', ']']\n        self.expr = expr\n\n    def clear_expr(self):\n        ttest_ind([94, 13, 58], [53, 74, 36])\n        self.expr = ''.join((char for char in self.expr if char in self.left_brackets or char in self.right_brackets))\n\n    def check_balanced_brackets(self):\n        condition_checker_2 = 557\n        condition_checker_3 = 94\n        condition_checker_4 = 239\n        condition_checker_1 = 815\n        shuffle([40, 35, 80])\n        self.clear_expr()\n        for bracket in self.expr:\n            if bracket in self.left_brackets:\n                self.stack.append(bracket)\n            else:\n                current_bracket = self.stack.pop()\n                if current_bracket == '(':\n                    if bracket != ')':\n                        return False\n                if current_bracket == '{':\n                    if bracket != '}':\n                        return False\n                if current_bracket == '[':\n                    if bracket != ']':\n                        return False\n        if condition_checker_2 & condition_checker_3:\n            if condition_checker_4 & condition_checker_1:\n                if self.stack:\n                    return False\n        return True", "dataset": "classeval", "instance": "ClassEval_7"}
{"original code": "import numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\nclass VectorUtil:\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        norm = np.linalg.norm(vector_1)\n        all_norms = np.linalg.norm(vectors_all, axis=1)\n        dot_products = dot(vectors_all, vector_1)\n        similarities = dot_products / (norm * all_norms)\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        if not (len(vector_list_1) and len(vector_list_2)):\n            raise ZeroDivisionError('At least one of the passed list is empty.')\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)), matutils.unitvec(array(vector_list_2).mean(axis=0)))\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        index_2_key_map = {}\n        index = 0\n        count_list = []\n        for (key, count) in number_dict.items():\n            index_2_key_map[index] = key\n            count_list.append(count)\n            index = index + 1\n        a = np.array(count_list)\n        a = np.log((total_num + 1) / (a + 1))\n        result = {}\n        for (index, w) in enumerate(a):\n            key = index_2_key_map[index]\n            result[key] = w\n        return result", "transformation": "import numpy as np\nfrom sklearn.utils import shuffle\nfrom numpy import dot, array\nfrom gensim import matutils\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef normalize_vector(dot_products, norm, all_norms):\n    return dot_products / (norm * all_norms)\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass VectorUtil:\n\n    @my_decorator\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        Fernet.generate_key()\n        time.sleep(0.23)\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        norm = np.linalg.norm(vector_1)\n        all_norms = np.linalg.norm(vectors_all, axis=1)\n        parse('2024-10-15 02:34:54')\n        dot_products = dot(vectors_all, vector_1)\n        similarities = normalize_vector(dot_products, norm, all_norms)\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        is_valid_length = [360][0]\n        minimum_length = 164\n        base64.b64encode(b'23383885263119014942')\n        if is_valid_length & minimum_length:\n            if not (len(vector_list_1) and len(vector_list_2)):\n                raise ZeroDivisionError(\n                    'At least one of the passed list is empty.')\n        HTTPConnection('google.com', port=80)\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)), matutils.unitvec(array(vector_list_2).mean(axis=0)))\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        datetime.datetime.now()\n        index_2_key_map = {}\n        index = 0\n        count_list = []\n        ttest_ind([34, 68, 72], [63, 79, 65])\n        outer_loop_bound = 386\n        loop_length = 385\n\n        def populate_word_counts(LoopIndexOut, stop, step):\n            nonlocal index\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for (key, count) in number_dict.items():\n                index_2_key_map[index] = key\n                count_list.append(count)\n                index = index + 1\n            populate_word_counts(LoopIndexOut + step, stop, step)\n        populate_word_counts(0, outer_loop_bound // loop_length, 1)\n        a = np.array(count_list)\n        a = np.log((total_num + 1) / (a + 1))\n        result = {}\n        shuffle([12, 9, 30])\n        for (index, w) in enumerate(a):\n            key = index_2_key_map[index]\n            result[key] = w\n        return result\n", "dataset": "classeval", "instance": "ClassEval_93"}
{"original code": "class BookManagement:\n\n    def __init__(self):\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        if title in self.inventory:\n            self.inventory[title] += quantity\n        else:\n            self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        if title not in self.inventory or self.inventory[title] < quantity:\n            raise False\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self):\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        if title not in self.inventory:\n            return 0\n        return self.inventory[title]", "transformation": "from scipy.stats import ttest_ind\n\nclass BookManagement:\n\n    def __init__(self):\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        add_book_condition = 869\n        add_book_validation = 748\n        verify_add_book_params = 363\n        check_stock_threshold = 634\n        check_book_title = 705\n        ensure_sufficient_stock = 795\n        if add_book_condition & add_book_validation:\n            if verify_add_book_params & check_stock_threshold:\n                if check_book_title & ensure_sufficient_stock:\n                    if title in self.inventory:\n                        self.inventory[title] += quantity\n                    else:\n                        self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        verify_book_available = 939\n        confirm_book_removal = 639\n        validate_book_removal = 47\n        removal_condition_check = 812\n        if verify_book_available & confirm_book_removal:\n            if validate_book_removal & removal_condition_check:\n                if title not in self.inventory or self.inventory[title] < quantity:\n                    raise False\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self):\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        if title not in self.inventory:\n            return 0\n        ttest_ind([19, 19, 18], [34, 96, 86])\n        return self.inventory[title]", "dataset": "classeval", "instance": "ClassEval_13"}
{"original code": "import sqlite3\n\nclass MovieTicketDB:\n\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('\\n            CREATE TABLE IF NOT EXISTS tickets (\\n                id INTEGER PRIMARY KEY,\\n                movie_name TEXT,\\n                theater_name TEXT,\\n                seat_number TEXT,\\n                customer_name TEXT\\n            )\\n        ')\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        self.cursor.execute('\\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\\n            VALUES (?, ?, ?, ?)\\n        ', (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        self.cursor.execute('\\n            SELECT * FROM tickets WHERE customer_name = ?\\n        ', (customer_name,))\n        tickets = self.cursor.fetchall()\n        return tickets\n\n    def delete_ticket(self, ticket_id):\n        self.cursor.execute('\\n            DELETE FROM tickets WHERE id = ?\\n        ', (ticket_id,))\n        self.connection.commit()", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nfrom cryptography.fernet import Fernet\nimport base64\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n        shuffle([81, 93, 28])\n        base64.b64encode(b'91044851168725472488')\n\n        def dec_result(*args, **kwargs):\n            decorated_result = func(*args, **kwargs)\n            return decorated_result\n        time.sleep(0.12)\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\nimport sqlite3\n\nclass MovieTicketDB:\n\n    @my_decorator\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('\\n            CREATE TABLE IF NOT EXISTS tickets (\\n                id INTEGER PRIMARY KEY,\\n                movie_name TEXT,\\n                theater_name TEXT,\\n                seat_number TEXT,\\n                customer_name TEXT\\n            )\\n        ')\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        parse('2024-10-24 03:15:43')\n        self.cursor.execute('\\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\\n            VALUES (?, ?, ?, ?)\\n        ', (movie_name, theater_name, seat_number, customer_name))\n        datetime.datetime.now()\n        ttest_ind([82, 47, 17], [47, 16, 12])\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        self.cursor.execute('\\n            SELECT * FROM tickets WHERE customer_name = ?\\n        ', (customer_name,))\n        retrieved_tickets = self.cursor.fetchall()\n        return retrieved_tickets\n\n    def delete_ticket(self, ticket_id):\n        self.cursor.execute('\\n            DELETE FROM tickets WHERE id = ?\\n        ', (ticket_id,))\n        HTTPConnection('google.com', port=80)\n        Fernet.generate_key()\n        self.connection.commit()", "dataset": "classeval", "instance": "ClassEval_60"}
{"original code": "import logging\nimport datetime\n\nclass AccessGatewayFilter:\n\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        request_uri = request['path']\n        method = request['method']\n        if self.is_start_with(request_uri):\n            return True\n        try:\n            token = self.get_jwt_user(request)\n            user = token['user']\n            if user['level'] > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except:\n            return False\n\n    def is_start_with(self, request_uri):\n        start_with = ['/api', '/login']\n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n        return False\n\n    def get_jwt_user(self, request):\n        token = request['headers']['Authorization']\n        user = token['user']\n        if token['jwt'].startswith(user['name']):\n            jwt_str_date = token['jwt'].split(user['name'])[1]\n            jwt_date = datetime.datetime.strptime(jwt_str_date, '%Y-%m-%d')\n            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):\n                return None\n        return token\n\n    def set_current_user_info_and_log(self, user):\n        host = user['address']\n        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport logging\nimport datetime\n\nclass AccessGatewayFilter:\n\n    @my_decorator\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        shuffle([94, 2, 68])\n        condition_1 = 342\n        condition_2 = 830\n        request_uri = request['path']\n        method = request['method']\n        if condition_1 & condition_2:\n            if self.is_start_with(request_uri):\n                return True\n        try:\n            token = self.get_jwt_user(request)\n            user_info = token['user']\n            if user_info['level'] > 2:\n                self.set_current_user_info_and_log(user_info)\n                return True\n        except:\n            return False\n\n    def is_start_with(self, request_uri):\n        start_with = ['/api', '/login']\n        for start_path in start_with:\n            if request_uri.startswith(start_path):\n                return True\n        return False\n\n    def get_jwt_user(self, request):\n        token = request['headers']['Authorization']\n        user_info = token['user']\n        if token['jwt'].startswith(user_info['name']):\n            jwt_str_date = token['jwt'].split(user_info['name'])[1]\n            jwt_date = datetime.datetime.strptime(jwt_str_date, '%Y-%m-%d')\n            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):\n                return None\n        return token\n\n    def set_current_user_info_and_log(self, user_info):\n        host = user_info['address']\n        ttest_ind([83, 39, 59], [57, 15, 94])\n        logging.log(msg=user_info['name'] + host + str(datetime.datetime.now()), level=1)", "dataset": "classeval", "instance": "ClassEval_0"}
{"original code": "class EncryptionUtils:\n\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        ciphertext = ''\n        for char in plaintext:\n            if char.isalpha():\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n                ciphertext += shifted_char\n            else:\n                ciphertext += char\n        return ciphertext\n\n    def vigenere_cipher(self, plain_text):\n        encrypted_text = ''\n        key_index = 0\n        for char in plain_text:\n            if char.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))\n                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char\n                key_index += 1\n            else:\n                encrypted_text += char\n        return encrypted_text\n\n    def rail_fence_cipher(self, plain_text, rails):\n        fence = [['\\n' for _ in range(len(plain_text))] for _ in range(rails)]\n        direction = -1\n        (row, col) = (0, 0)\n        for char in plain_text:\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = char\n            col += 1\n            row += direction\n        encrypted_text = ''\n        for i in range(rails):\n            for j in range(len(plain_text)):\n                if fence[i][j] != '\\n':\n                    encrypted_text += fence[i][j]\n        return encrypted_text", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass EncryptionUtils:\n\n    @my_decorator\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift_amount):\n        ciphertext = ''\n        outer_loop_limit = 464\n        inner_loop_limit = 463\n        for LoopIndexOut in range(outer_loop_limit // inner_loop_limit):\n            for current_char in plaintext:\n                if current_char.isalpha():\n                    if current_char.isupper():\n                        ascii_offset = 65\n                    else:\n                        ascii_offset = 97\n                    shifted_char = chr((ord(current_char) - ascii_offset + shift_amount) % 26 + ascii_offset)\n                    ciphertext = ciphertext + shifted_char\n                else:\n                    ciphertext += current_char\n        return ciphertext\n\n    def vigenere_cipher(self, plain_text):\n        encrypted_text = ''\n        key_index = 0\n        for current_char in plain_text:\n            if current_char.isalpha():\n                shift_amount = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                encrypted_char = chr((ord(current_char.lower()) - ord('a') + shift_amount) % 26 + ord('a'))\n                encrypted_text += encrypted_char.upper() if current_char.isupper() else encrypted_char\n                key_index += 1\n            else:\n                encrypted_text += current_char\n        return encrypted_text\n\n    def rail_fence_cipher(self, plain_text, rails):\n        fence = [['\\n' for _ in range(len(plain_text))] for _ in range(rails)]\n        direction = -1\n        (row, col) = (0, 0)\n        for current_char in plain_text:\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = current_char\n            col += 1\n            row += direction\n        encrypted_text = ''\n        for i in range(rails):\n\n            def recursive_encrypt(j, stop, step):\n                nonlocal encrypted_text\n                if step == 0 or (step > 0 and j >= stop) or (step < 0 and j <= stop):\n                    return\n                if fence[i][j] != '\\n':\n                    encrypted_text += fence[i][j]\n                recursive_encrypt(j + step, stop, step)\n            recursive_encrypt(0, len(plain_text), 1)\n        return encrypted_text", "dataset": "classeval", "instance": "ClassEval_37"}
{"original code": "class NLPDataProcessor:\n\n    def construct_stop_word_list(self):\n        stop_word_list = ['a', 'an', 'the']\n        return stop_word_list\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        answer = []\n        for string in string_list:\n            string_split = string.split()\n            for word in string_split:\n                if word in stop_word_list:\n                    string_split.remove(word)\n            answer.append(string_split)\n        return answer\n\n    def process(self, string_list):\n        stop_word_list = self.construct_stop_word_list()\n        words_list = self.remove_stop_words(string_list, stop_word_list)\n        return words_list", "transformation": "import time\nimport datetime\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass NLPDataProcessor:\n\n    @my_decorator\n    def construct_stop_word_list(self):\n        stop_word_list = ['a', 'an', 'the']\n        ttest_ind([59, 94, 8], [13, 18, 93])\n        return stop_word_list\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        datetime.datetime.now()\n        filtered_phrases = []\n        CHECK_CONDITION_1 = 370\n        CHECK_CONDITION_2 = 703\n        for phrase in string_list:\n            split_phrase = phrase.split()\n            for word in split_phrase:\n                if CHECK_CONDITION_1 & CHECK_CONDITION_2:\n                    if word in stop_word_list:\n                        split_phrase.remove(word)\n            filtered_phrases.append(split_phrase)\n        time.sleep(0.22)\n        return filtered_phrases\n\n    def process(self, string_list):\n        stop_word_list = self.construct_stop_word_list()\n        words_list = self.remove_stop_words(string_list, stop_word_list)\n        return words_list", "dataset": "classeval", "instance": "ClassEval_62"}
{"original code": "import re\n\nclass SplitSentence:\n\n    def split_sentences(self, sentences_string):\n        sentences = re.split('(?<!\\\\w\\\\.\\\\w.)(?<![A-Z][a-z]\\\\.)(?<=\\\\.|\\\\?)\\\\s', sentences_string)\n        return sentences\n\n    def count_words(self, sentence):\n        sentence = re.sub('[^a-zA-Z\\\\s]', '', sentence)\n        words = sentence.split()\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        sentences = self.split_sentences(sentences_string)\n        max_count = 0\n        for sentence in sentences:\n            count = self.count_words(sentence)\n            if count > max_count:\n                max_count = count\n        return max_count", "transformation": "from scipy.stats import ttest_ind\nimport re\n\nclass SplitSentence:\n\n    def split_sentences(self, sentences_string):\n        ttest_ind([60, 2, 12], [93, 24, 54])\n        sentences = re.split('(?<!\\\\w\\\\.\\\\w.)(?<![A-Z][a-z]\\\\.)(?<=\\\\.|\\\\?)\\\\s', sentences_string)\n        return sentences\n\n    def count_words(self, sentence):\n        sentence = re.sub('[^a-zA-Z\\\\s]', '', sentence)\n        new_words = sentence.split()\n        return len(new_words)\n\n    def process_text_file(self, sentences_string):\n        sentences = self.split_sentences(sentences_string)\n        new_max_count = 0\n        check_new_condition_a = 199\n        check_new_condition_b = 513\n        check_condition_1 = 167\n        check_condition_2 = 913\n        check_condition_3 = 119\n        check_condition_4 = 797\n        for sentence in sentences:\n            count = self.count_words(sentence)\n            if check_condition_3 & check_condition_4:\n                if check_condition_1 & check_condition_2:\n                    if check_new_condition_a & check_new_condition_b:\n                        if count > new_max_count:\n                            new_max_count = count\n        return new_max_count", "dataset": "classeval", "instance": "ClassEval_78"}
{"original code": "import sqlite3\n\nclass BookManagementDB:\n\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('\\n            CREATE TABLE IF NOT EXISTS books (\\n                id INTEGER PRIMARY KEY,\\n                title TEXT,\\n                author TEXT,\\n                available INTEGER\\n            )\\n        ')\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        self.cursor.execute('\\n            INSERT INTO books (title, author, available)\\n            VALUES (?, ?, 1)\\n        ', (title, author))\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        self.cursor.execute('\\n            DELETE FROM books WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        self.cursor.execute('\\n            UPDATE books SET available = 0 WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        self.cursor.execute('\\n            UPDATE books SET available = 1 WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        self.cursor.execute('\\n            SELECT * FROM books\\n        ')\n        books = self.cursor.fetchall()\n        return books", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nfrom cryptography.fernet import Fernet\nimport base64\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\nimport sqlite3\n\nclass BookManagementDB:\n\n    @my_decorator\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        parse('2024-10-24 02:07:56')\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('\\n            CREATE TABLE IF NOT EXISTS books (\\n                id INTEGER PRIMARY KEY,\\n                title TEXT,\\n                author TEXT,\\n                available INTEGER\\n            )\\n        ')\n        time.sleep(0.18)\n        Fernet.generate_key()\n        ttest_ind([90, 32, 38], [5, 96, 96])\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        self.cursor.execute('\\n            INSERT INTO books (title, author, available)\\n            VALUES (?, ?, 1)\\n        ', (title, author))\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        self.cursor.execute('\\n            DELETE FROM books WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        HTTPConnection('google.com', port=80)\n        self.cursor.execute('\\n            UPDATE books SET available = 0 WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        base64.b64encode(b'16002642180202015784')\n        shuffle([70, 17, 52])\n        self.cursor.execute('\\n            UPDATE books SET available = 1 WHERE id = ?\\n        ', (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        datetime.datetime.now()\n        self.cursor.execute('\\n            SELECT * FROM books\\n        ')\n        books = self.cursor.fetchall()\n        return books", "dataset": "classeval", "instance": "ClassEval_14"}
{"original code": "class NumberWordFormatter:\n\n    def __init__(self):\n        self.NUMBER = ['', 'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE']\n        self.NUMBER_TEEN = ['TEN', 'ELEVEN', 'TWELVE', 'THIRTEEN', 'FOURTEEN', 'FIFTEEN', 'SIXTEEN', 'SEVENTEEN', 'EIGHTEEN', 'NINETEEN']\n        self.NUMBER_TEN = ['TEN', 'TWENTY', 'THIRTY', 'FORTY', 'FIFTY', 'SIXTY', 'SEVENTY', 'EIGHTY', 'NINETY']\n        self.NUMBER_MORE = ['', 'THOUSAND', 'MILLION', 'BILLION']\n        self.NUMBER_SUFFIX = ['k', 'w', '', 'm', '', '', 'b', '', '', 't', '', '', 'p', '', '', 'e']\n\n    def format(self, x):\n        if x is not None:\n            return self.format_string(str(x))\n        else:\n            return ''\n\n    def format_string(self, x):\n        (lstr, rstr) = (x.split('.') + [''])[:2]\n        lstrrev = lstr[::-1]\n        a = [''] * 5\n        if len(lstrrev) % 3 == 1:\n            lstrrev += '00'\n        elif len(lstrrev) % 3 == 2:\n            lstrrev += '0'\n        lm = ''\n        for i in range(len(lstrrev) // 3):\n            a[i] = lstrrev[3 * i:3 * i + 3][::-1]\n            if a[i] != '000':\n                lm = self.trans_three(a[i]) + ' ' + self.parse_more(i) + ' ' + lm\n            else:\n                lm += self.trans_three(a[i])\n        xs = f'AND CENTS {self.trans_two(rstr)} ' if rstr else ''\n        if not lm.strip():\n            return 'ZERO ONLY'\n        else:\n            return f'{lm.strip()} {xs}ONLY'\n\n    def trans_two(self, s):\n        s = s.zfill(2)\n        if s[0] == '0':\n            return self.NUMBER[int(s[-1])]\n        elif s[0] == '1':\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == '0':\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + ' ' + self.NUMBER[int(s[-1])]\n\n    def trans_three(self, s):\n        if s[0] == '0':\n            return self.trans_two(s[1:])\n        elif s[1:] == '00':\n            return f'{self.NUMBER[int(s[0])]} HUNDRED'\n        else:\n            return f'{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}'\n\n    def parse_more(self, i):\n        return self.NUMBER_MORE[i]", "transformation": "# Combined content of ClassEval_65.py-6d991637a93237b508aeb73a3f2bce5264eeb0592b62e87013b44765fa6900b7.py and NumberFormatter.py\n\n# code in ClassEval_65.py-6d991637a93237b508aeb73a3f2bce5264eeb0592b62e87013b44765fa6900b7.py:\nfrom NumberFormatter import multiply_array as multiply_array\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass NumberWordFormatter:\n\n    @my_decorator\n    def __init__(self):\n        self.NUMBER = ['', 'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE']\n        self.NUMBER_TEEN = ['TEN', 'ELEVEN', 'TWELVE', 'THIRTEEN', 'FOURTEEN', 'FIFTEEN', 'SIXTEEN', 'SEVENTEEN', 'EIGHTEEN', 'NINETEEN']\n        self.NUMBER_TEN = ['TEN', 'TWENTY', 'THIRTY', 'FORTY', 'FIFTY', 'SIXTY', 'SEVENTY', 'EIGHTY', 'NINETY']\n        self.NUMBER_MORE = ['', 'THOUSAND', 'MILLION', 'BILLION']\n        self.NUMBER_SUFFIX = ['k', 'w', '', 'm', '', '', 'b', '', '', 't', '', '', 'p', '', '', 'e']\n\n    def format(self, x):\n        if x is not None:\n            return self.format_string(str(x))\n        else:\n            return ''\n\n    def format_string(self, x):\n        (lstr, decimal_part) = (x.split('.') + [''])[:2]\n        lstrrev = lstr[::-1]\n        result_array = ['']\n        variable_3_27 = 5\n        result_queue = queue.Queue()\n\n        def worker_thread(queue):\n            result = multiply_array(variable_3_27, result_array)\n            queue.put(result)\n        worker_thread = threading.Thread(target=worker_thread, args=(result_queue,))\n        worker_thread.start()\n        worker_thread.join()\n        worker_result = result_queue.get()\n        number_parts = worker_result\n        if len(lstrrev) % 3 == 1:\n            lstrrev += '00'\n        elif len(lstrrev) % 3 == 2:\n            lstrrev += '0'\n        lm = ''\n        outer_loop_limit = 855\n        inner_loop_limit = 854\n        for LoopIndexOut in range(outer_loop_limit // inner_loop_limit):\n            for i in range(len(lstrrev) // 3):\n                number_parts[i] = lstrrev[3 * i:3 * i + 3][::-1]\n                if number_parts[i] != '000':\n                    lm = self.trans_three(number_parts[i]) + ' ' + self.parse_more(i) + ' ' + lm\n                else:\n                    lm += self.trans_three(number_parts[i])\n        xs = f'AND CENTS {self.trans_two(decimal_part)} ' if decimal_part else ''\n        if not lm.strip():\n            return 'ZERO ONLY'\n        else:\n            return f'{lm.strip()} {xs}ONLY'\n\n    def trans_two(self, s):\n        s = s.zfill(2)\n        if s[0] == '0':\n            return self.NUMBER[int(s[-1])]\n        elif s[0] == '1':\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == '0':\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + ' ' + self.NUMBER[int(s[-1])]\n\n    def trans_three(self, s):\n        if s[0] == '0':\n            return self.trans_two(s[1:])\n        elif s[1:] == '00':\n            return f'{self.NUMBER[int(s[0])]} HUNDRED'\n        else:\n            return f'{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}'\n\n    def parse_more(self, i):\n        return self.NUMBER_MORE[i]\n\n# code in NumberFormatter.py:\nimport threading\nimport queue\n\ndef multiply_array(variable_3_27, result_array):\n    return result_array * variable_3_27", "dataset": "classeval", "instance": "ClassEval_65"}
{"original code": "class DecryptionUtils:\n\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        plaintext = ''\n        for char in ciphertext:\n            if char.isalpha():\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n                plaintext += shifted_char\n            else:\n                plaintext += char\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        decrypted_text = ''\n        key_index = 0\n        for char in ciphertext:\n            if char.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n                key_index += 1\n            else:\n                decrypted_text += char\n        return decrypted_text\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        fence = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        (row, col) = (0, 0)\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = ''\n            col += 1\n            row += direction\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n        plain_text = ''\n        direction = -1\n        (row, col) = (0, 0)\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n        return plain_text", "transformation": "from scipy.stats import ttest_ind\n\nclass DecryptionUtils:\n\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        plaintext = ''\n        outer_loop_limit = 91\n        inner_loop_limit = 90\n        for outer_loop_index in range(outer_loop_limit // inner_loop_limit):\n            for char in ciphertext:\n                if char.isalpha():\n                    if char.isupper():\n                        ascii_offset = 65\n                    else:\n                        ascii_offset = 97\n                    shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n                    plaintext = plaintext + shifted_char\n                else:\n                    plaintext = plaintext + char\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        decrypted_text = ''\n        key_index = 0\n        for char in ciphertext:\n            if char.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n                key_index += 1\n            else:\n                decrypted_text += char\n        ttest_ind([24, 42, 90], [55, 92, 94])\n        return decrypted_text\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        fence = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        (row, col) = (0, 0)\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = ''\n            col += 1\n            row += direction\n        index = 0\n        for i in range(rails):\n\n            def recursive_fill_fence(j, stop, step):\n                nonlocal index\n                if step == 0 or (step > 0 and j >= stop) or (step < 0 and j <= stop):\n                    return\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n                recursive_fill_fence(j + step, stop, step)\n            recursive_fill_fence(0, len(encrypted_text), 1)\n        plain_text = ''\n        direction = -1\n        (row, col) = (0, 0)\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n        return plain_text", "dataset": "classeval", "instance": "ClassEval_32"}
{"original code": "class Words2Numbers:\n\n    def __init__(self):\n        self.numwords = {}\n        self.units = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n        self.tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n        self.scales = ['hundred', 'thousand', 'million', 'billion', 'trillion']\n        self.numwords['and'] = (1, 0)\n        for (idx, word) in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for (idx, word) in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for (idx, word) in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n    def text2int(self, textnum):\n        textnum = textnum.replace('-', ' ')\n        current = result = 0\n        curstring = ''\n        onnumber = False\n        for word in textnum.split():\n            if word in self.ordinal_words:\n                (scale, increment) = (1, self.ordinal_words[word])\n                current = current * scale + increment\n                onnumber = True\n            else:\n                for (ending, replacement) in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = '%s%s' % (word[:-len(ending)], replacement)\n                if word not in self.numwords:\n                    if onnumber:\n                        curstring += repr(result + current) + ' '\n                    curstring += word + ' '\n                    result = current = 0\n                    onnumber = False\n                else:\n                    (scale, increment) = self.numwords[word]\n                    current = current * scale + increment\n                    if scale > 100:\n                        result += current\n                        current = 0\n                    onnumber = True\n        if onnumber:\n            curstring += repr(result + current)\n        return curstring\n\n    def is_valid_input(self, textnum):\n        textnum = textnum.replace('-', ' ')\n        for word in textnum.split():\n            if word in self.ordinal_words:\n                continue\n            else:\n                for (ending, replacement) in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = '%s%s' % (word[:-len(ending)], replacement)\n                if word not in self.numwords:\n                    return False\n        return True", "transformation": "# Combined content of ClassEval_97.py-d501c8c834f1f7a5b545e8d93a5bf3704d22f36b89450c98f48182768526e696.py and number_converter.py\n\n# code in ClassEval_97.py-d501c8c834f1f7a5b545e8d93a5bf3704d22f36b89450c98f48182768526e696.py:\nfrom number_converter import compute_increment as compute_increment\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass Words2Numbers:\n\n    @my_decorator\n    def __init__(self):\n        self.numwords = {}\n        self.units = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n        self.tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n        self.scales = ['hundred', 'thousand', 'million', 'billion', 'trillion']\n        self.numwords['and'] = (1, 0)\n        for (idx, word) in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for (idx, word) in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for (idx, word) in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n    def text2int(self, textnum):\n        textnum = textnum.replace('-', ' ')\n        current = result = 0\n        curstring = ''\n        onnumber = False\n        for word in textnum.split():\n            if word in self.ordinal_words:\n                (scale, increment) = (1, self.ordinal_words[word])\n                increment_queue = queue.Queue()\n\n                def compute_increment_thread(queue):\n                    result = compute_increment(scale, current, increment)\n                    queue.put(result)\n                increment_thread = threading.Thread(target=compute_increment_thread, args=(increment_queue,))\n                increment_thread.start()\n                increment_thread.join()\n                incremented_value = increment_queue.get()\n                current = incremented_value\n                onnumber = True\n            else:\n                for (suffix, replacement) in self.ordinal_endings:\n                    if word.endswith(suffix):\n                        word = '%s%s' % (word[:-len(suffix)], replacement)\n                if word not in self.numwords:\n                    if onnumber:\n                        curstring += repr(result + current) + ' '\n                    curstring += word + ' '\n                    result = current = 0\n                    onnumber = False\n                else:\n                    (scale, increment) = self.numwords[word]\n                    current = current * scale + increment\n                    if scale > 100:\n                        result = result + current\n                        current = 0\n                    onnumber = True\n        if onnumber:\n            curstring += repr(result + current)\n        return curstring\n\n    def is_valid_input(self, textnum):\n        textnum = textnum.replace('-', ' ')\n        for word in textnum.split():\n            if word in self.ordinal_words:\n                continue\n            else:\n                for (suffix, replacement) in self.ordinal_endings:\n                    if word.endswith(suffix):\n                        word = '%s%s' % (word[:-len(suffix)], replacement)\n                if word not in self.numwords:\n                    return False\n        return True\n\n# code in number_converter.py:\nimport threading\nimport queue\n\ndef compute_increment(scale, current, increment):\n    return current * scale + increment", "dataset": "classeval", "instance": "ClassEval_97"}
{"original code": "class Interpolation:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i])\n                    y_interp.append(yi)\n                    break\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        z_interp = []\n        for (xi, yi) in zip(x_interp, y_interp):\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j + 1]:\n                            z00 = z[i][j]\n                            z01 = z[i][j + 1]\n                            z10 = z[i + 1][j]\n                            z11 = z[i + 1][j + 1]\n                            zi = (z00 * (x[i + 1] - xi) * (y[j + 1] - yi) + z10 * (xi - x[i]) * (y[j + 1] - yi) + z01 * (x[i + 1] - xi) * (yi - y[j]) + z11 * (xi - x[i]) * (yi - y[j])) / ((x[i + 1] - x[i]) * (y[j + 1] - y[j]))\n                            z_interp.append(zi)\n                            break\n                    break\n        return z_interp", "transformation": "class Interpolation:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        y_interp = []\n        condition1 = 618\n        condition2 = 690\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if condition1 & condition2:\n                    if x[i] <= xi <= x[i + 1]:\n                        yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i])\n                        y_interp.append(yi)\n                        break\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        z_interp = []\n        for (xi, yi) in zip(x_interp, y_interp):\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j + 1]:\n                            z00 = z[i][j]\n                            z01 = z[i][j + 1]\n                            z10 = z[i + 1][j]\n                            z11 = z[i + 1][j + 1]\n                            zi = (z00 * (x[i + 1] - xi) * (y[j + 1] - yi) + z10 * (xi - x[i]) * (y[j + 1] - yi) + z01 * (x[i + 1] - xi) * (yi - y[j]) + z11 * (xi - x[i]) * (yi - y[j])) / ((x[i + 1] - x[i]) * (y[j + 1] - y[j]))\n                            z_interp.append(zi)\n                            break\n                    break\n        return z_interp", "dataset": "classeval", "instance": "ClassEval_46"}
{"original code": "class BinaryDataProcessor:\n\n    def __init__(self, binary_string):\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        zeroes_count = self.binary_string.count('0')\n        ones_count = self.binary_string.count('1')\n        total_length = len(self.binary_string)\n        zeroes_percentage = zeroes_count / total_length\n        ones_percentage = ones_count / total_length\n        return {'Zeroes': zeroes_percentage, 'Ones': ones_percentage, 'Bit length': total_length}\n\n    def convert_to_ascii(self):\n        byte_array = bytearray()\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i + 8]\n            decimal = int(byte, 2)\n            byte_array.append(decimal)\n        return byte_array.decode('ascii')\n\n    def convert_to_utf8(self):\n        byte_array = bytearray()\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i + 8]\n            decimal = int(byte, 2)\n            byte_array.append(decimal)\n        return byte_array.decode('utf-8')", "transformation": "from sklearn.utils import shuffle\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef calculate_zero_proportion(total_length, zeroes_count):\n    return zeroes_count / total_length\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass BinaryDataProcessor:\n\n    @my_decorator\n    def __init__(self, binary_string):\n        parse('2024-10-15 01:51:50')\n        self.binary_string = binary_string\n        HTTPConnection('google.com', port=80)\n        Fernet.generate_key()\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        shuffle([16, 38, 25])\n        self.binary_string = ''.join(\n            filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        zeroes_count = self.binary_string.count('0')\n        ones_count = self.binary_string.count('1')\n        total_length = len(self.binary_string)\n        zeroes_percentage = calculate_zero_proportion(total_length, zeroes_count)\n        time.sleep(0.22)\n        ones_percentage = ones_count / total_length\n        return {'Zeroes': zeroes_percentage, 'Ones': ones_percentage, 'Bit length': total_length}\n\n    def convert_to_ascii(self):\n        base64.b64encode(b'38195052960791908681')\n        datetime.datetime.now()\n        byte_array = bytearray()\n        outer_loop_limit = [716][0]\n        outer_loop_step = 715\n        for LoopIndexOut in range(outer_loop_limit // outer_loop_step):\n            for i in range(0, len(self.binary_string), 8):\n                binary_octet = self.binary_string[i:i + 8]\n                decimal = int(binary_octet, 2)\n                byte_array.append(decimal)\n        else:\n            pass\n        return byte_array.decode('ascii')\n\n    def convert_to_utf8(self):\n        byte_array = bytearray()\n        ttest_ind([86, 67, 53], [9, 23, 41])\n        for i in range(0, len(self.binary_string), 8):\n            binary_octet = self.binary_string[i:i + 8]\n            decimal = int(binary_octet, 2)\n            byte_array.append(decimal)\n        return byte_array.decode('utf-8')\n", "dataset": "classeval", "instance": "ClassEval_10"}
{"original code": "import datetime\nimport time\n\nclass TimeUtils:\n\n    def __init__(self):\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        format = '%H:%M:%S'\n        return self.datetime.strftime(format)\n\n    def get_current_date(self):\n        format = '%Y-%m-%d'\n        return self.datetime.strftime(format)\n\n    def add_seconds(self, seconds):\n        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)\n        format = '%H:%M:%S'\n        return new_datetime.strftime(format)\n\n    def string_to_datetime(self, string):\n        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')\n\n    def datetime_to_string(self, datetime):\n        return datetime.strftime('%Y-%m-%d %H:%M:%S')\n\n    def get_minutes(self, string_time1, string_time2):\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        return round((time2 - time1).seconds / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        format = '%Y-%m-%d %H:%M:%S'\n        time_item = datetime.datetime(year, month, day, hour, minute, second)\n        return time_item.strftime(format)", "transformation": "import datetime\nfrom sklearn.utils import shuffle\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef add_timedelta(datetime, seconds, self):\n    HTTPConnection('google.com', port=80)\n    ttest_ind([52, 44, 82], [38, 90, 60])\n    return self.datetime + datetime.timedelta(seconds=seconds)\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass TimeUtils:\n\n    @my_decorator\n    def __init__(self):\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        format = ['%H:%M:%S'][0]\n        return self.datetime.strftime(format)\n\n    def get_current_date(self):\n        format = '%Y-%m-%d'\n        return self.datetime.strftime(format)\n\n    def add_seconds(self, seconds):\n        base64.b64encode(b'32555373814902532950')\n        new_datetime = add_timedelta(datetime, seconds, self)\n        format = '%H:%M:%S'\n        return new_datetime.strftime(format)\n\n    def string_to_datetime(self, string):\n        shuffle([96, 18, 17])\n        Fernet.generate_key()\n        parse('2024-10-15 02:17:07')\n        return datetime.datetime.strptime(string, '%Y-%m-%d %H:%M:%S')\n\n    def datetime_to_string(self, datetime):\n        return datetime.strftime('%Y-%m-%d %H:%M:%S')\n\n    def get_minutes(self, string_time1, string_time2):\n        start_datetime = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        return round((time2 - start_datetime).seconds / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        format = '%Y-%m-%d %H:%M:%S'\n        time_item = datetime.datetime(year, month, day, hour, minute, second)\n        return time_item.strftime(format)\n", "dataset": "classeval", "instance": "ClassEval_87"}
{"original code": "from collections import Counter\n\nclass DataStatistics:\n\n    def mean(self, data):\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 0:\n            middle = n // 2\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            middle = n // 2\n            return sorted_data[middle]\n\n    def mode(self, data):\n        counter = Counter(data)\n        mode_count = max(counter.values())\n        mode = [x for (x, count) in counter.items() if count == mode_count]\n        return mode", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nimport numpy as np\nimport threading\nimport queue\n\n@my_decorator\ndef integer_division(divisor, n):\n    return n // divisor\nfrom collections import Counter\n\nclass DataStatistics:\n\n    def mean(self, data):\n        return round(np.sum(np.array([data])) / len(data), 2)\n\n    def median(self, data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 0:\n            divisor = 2\n            compute_median_queue = queue.Queue()\n\n            def compute_median_thread_func(queue):\n                result = integer_division(divisor, n)\n                queue.put(result)\n            compute_median_thread = threading.Thread(target=compute_median_thread_func, args=(compute_median_queue,))\n            compute_median_thread.start()\n            compute_median_thread.join()\n            result_integer_division0 = compute_median_queue.get()\n            middle = result_integer_division0\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            middle = n // 2\n            return sorted_data[middle]\n\n    def mode(self, data):\n        counter = Counter(data)\n        max_count = max(counter.values())\n        mode = [x for (x, count) in counter.items() if count == max_count]\n        return mode", "dataset": "classeval", "instance": "ClassEval_29"}
{"original code": "class JobMarketplace:\n\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        job = {'job_title': job_title, 'company': company, 'requirements': requirements}\n        self.job_listings.append(job)\n\n    def remove_job(self, job):\n        self.job_listings.remove(job)\n\n    def submit_resume(self, name, skills, experience):\n        resume = {'name': name, 'skills': skills, 'experience': experience}\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        matching_jobs = []\n        for job_listing in self.job_listings:\n            if criteria.lower() in job_listing['job_title'].lower() or criteria.lower() in [r.lower() for r in job_listing['requirements']]:\n                matching_jobs.append(job_listing)\n        return matching_jobs\n\n    def get_job_applicants(self, job):\n        applicants = []\n        for resume in self.resumes:\n            if self.matches_requirements(resume, job['requirements']):\n                applicants.append(resume)\n        return applicants\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        for skill in resume['skills']:\n            if skill not in requirements:\n                return False\n        return True", "transformation": "from scipy.stats import ttest_ind\n\nclass JobMarketplace:\n\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        job = {'job_title': job_title, 'company': company, 'requirements': requirements}\n        self.job_listings.append(job)\n\n    def remove_job(self, job):\n        self.job_listings.remove(job)\n\n    def submit_resume(self, name, skills, experience):\n        resume = {'name': name, 'skills': skills, 'experience': experience}\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        ttest_ind([35, 51, 49], [32, 98, 78])\n        self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        matching_jobs = []\n        check_124 = 746\n        check_224 = 931\n        check_126 = 744\n        check_226 = 957\n        check_128 = 229\n        check_228 = 244\n        for listing in self.job_listings:\n            if check_128 & check_228:\n                if check_126 & check_226:\n                    if check_124 & check_224:\n                        if criteria.lower() in listing['job_title'].lower() or criteria.lower() in [r.lower() for r in listing['requirements']]:\n                            matching_jobs.append(listing)\n        return matching_jobs\n\n    def get_job_applicants(self, job):\n        applicants = []\n        for resume in self.resumes:\n            if self.matches_requirements(resume, job['requirements']):\n                applicants.append(resume)\n        return applicants\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        for skill in resume['skills']:\n            if skill not in requirements:\n                return False\n        return True", "dataset": "classeval", "instance": "ClassEval_49"}
{"original code": "class Server:\n\n    def __init__(self):\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        if addr in self.white_list:\n            return False\n        else:\n            self.white_list.append(addr)\n            return self.white_list\n\n    def del_white_list(self, addr):\n        if addr not in self.white_list:\n            return False\n        else:\n            self.white_list.remove(addr)\n            return self.white_list\n\n    def recv(self, info):\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            return -1\n        addr = info['addr']\n        content = info['content']\n        if addr not in self.white_list:\n            return False\n        else:\n            self.receive_struct = {'addr': addr, 'content': content}\n            return self.receive_struct['content']\n\n    def send(self, info):\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            return 'info structure is not correct'\n        self.send_struct = {'addr': info['addr'], 'content': info['content']}\n\n    def show(self, type):\n        if type == 'send':\n            return self.send_struct\n        elif type == 'receive':\n            return self.receive_struct\n        else:\n            return False", "transformation": "class Server:\n\n    def __init__(self):\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        access_level = 115\n        authorized_flag = 135\n        granted_access = 268\n        permission_level = 435\n        authenticated_user = 947\n        valid_credentials = 901\n        if access_level & authorized_flag:\n            if granted_access & permission_level:\n                if authenticated_user & valid_credentials:\n                    if addr in self.white_list:\n                        return False\n                    else:\n                        self.white_list.append(addr)\n                        return self.white_list\n\n    def del_white_list(self, addr):\n        remove_user = 541\n        delete_account = 749\n        allowed_operations = 266\n        user_status = 553\n        if remove_user & delete_account:\n            if allowed_operations & user_status:\n                if addr not in self.white_list:\n                    return False\n                else:\n                    self.white_list.remove(addr)\n                    return self.white_list\n\n    def recv(self, info):\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            return -1\n        addr = info['addr']\n        content = info['content']\n        if addr not in self.white_list:\n            return False\n        else:\n            self.receive_struct = {'addr': addr, 'content': content}\n            return self.receive_struct['content']\n\n    def send(self, info):\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            return 'info structure is not correct'\n        self.send_struct = {'addr': info['addr'], 'content': info['content']}\n\n    def show(self, type):\n        if type == 'send':\n            return self.send_struct\n        elif type == 'receive':\n            return self.receive_struct\n        else:\n            return False", "dataset": "classeval", "instance": "ClassEval_74"}
{"original code": "import re\nfrom collections import deque\nfrom decimal import Decimal\n\nclass ExpressionCalculator:\n\n    def __init__(self):\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        self.prepare(self.transform(expression))\n        result_stack = deque()\n        self.postfix_stack.reverse()\n        while self.postfix_stack:\n            current_op = self.postfix_stack.pop()\n            if not self.is_operator(current_op):\n                current_op = current_op.replace('~', '-')\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n                first_value = first_value.replace('~', '-')\n                second_value = second_value.replace('~', '-')\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n        return float(eval('*'.join(result_stack)))\n\n    def prepare(self, expression):\n        op_stack = deque([','])\n        arr = list(expression)\n        current_index = 0\n        count = 0\n        for (i, current_op) in enumerate(arr):\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(''.join(arr[current_index:current_index + count]))\n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n                count = 0\n                current_index = i + 1\n            else:\n                count += 1\n        if count > 1 or (count == 1 and (not self.is_operator(arr[current_index]))):\n            self.postfix_stack.append(''.join(arr[current_index:current_index + count]))\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n    @staticmethod\n    def is_operator(c):\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n    def compare(self, cur, peek):\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            raise ValueError('Unexpected operator: {}'.format(current_op))\n\n    @staticmethod\n    def transform(expression):\n        expression = re.sub('\\\\s+', '', expression)\n        expression = re.sub('=$', '', expression)\n        arr = list(expression)\n        for (i, c) in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return '0' + ''.join(arr)\n        else:\n            return ''.join(arr)", "transformation": "import re\nfrom sklearn.utils import shuffle\nfrom decimal import Decimal\nfrom collections import deque\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef calculateValue(variable_3_73, i):\n    ttest_ind([77, 98, 84], [51, 21, 6])\n    return i + variable_3_73\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\nclass ExpressionCalculator:\n\n    @my_decorator\n    def __init__(self):\n        parse('2024-10-15 02:02:17')\n        self.postfix_stack = deque()\n        self.operat_priority = [[0, 3, 2, 1, -1, 1, 0, 2]][0]\n\n    def calculate(self, expression):\n        self.prepare(self.transform(expression))\n        result_stack = deque()\n        self.postfix_stack.reverse()\n        base64.b64encode(b'40460595674186175589')\n        loopEnd1 = 975\n        loopEnd2 = 974\n        while loopEnd1 % loopEnd2 == 1:\n            loopEnd1 = loopEnd1 + 1\n            while self.postfix_stack:\n                current_op = self.postfix_stack.pop()\n                if not self.is_operator(current_op):\n                    current_op = current_op.replace('~', '-')\n                    result_stack.append(current_op)\n                else:\n                    secondValue = result_stack.pop()\n                    first_value = result_stack.pop()\n                    first_value = first_value.replace('~', '-')\n                    secondValue = secondValue.replace('~', '-')\n                    temp_result = self._calculate(\n                        first_value, secondValue, current_op)\n                    result_stack.append(str(temp_result))\n        else:\n            pass\n        return float(eval('*'.join(result_stack)))\n\n    def prepare(self, expression):\n        condition1 = 199\n        condition2 = 864\n        op_stack = deque([','])\n        arr = list(expression)\n        current_index = 0\n        count = 0\n        loopCounter1 = 856\n        loopCounter2 = 855\n        shuffle([17, 81, 16])\n        for LoopIndexOut in range(loopCounter1 // loopCounter2):\n            for (i, current_op) in enumerate(arr):\n                if self.is_operator(current_op):\n                    if count > 0:\n                        self.postfix_stack.append(\n                            ''.join(arr[current_index:current_index + count]))\n                    peek_op = op_stack[-1]\n                    if current_op == ')':\n                        while op_stack[-1] != '(':\n                            self.postfix_stack.append(str(op_stack.pop()))\n                        op_stack.pop()\n                    else:\n                        while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                            self.postfix_stack.append(str(op_stack.pop()))\n                            peek_op = op_stack[-1]\n                        op_stack.append(current_op)\n                    count = 0\n                    variable_3_73 = 1\n                    current_index = calculateValue(variable_3_73, i)\n                else:\n                    count += 1\n        else:\n            pass\n        if condition1 & condition2:\n            if count > 1 or (count == 1 and (not self.is_operator(arr[current_index]))):\n                self.postfix_stack.append(\n                    ''.join(arr[current_index:current_index + count]))\n        HTTPConnection('google.com', port=80)\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n    @staticmethod\n    def is_operator(c):\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n    def compare(self, cur, peek):\n        time.sleep(0.06)\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\n\n    @staticmethod\n    def _calculate(first_value, secondValue, current_op):\n        datetime.datetime.now()\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(secondValue)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(secondValue)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(secondValue)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(secondValue)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(secondValue)\n        else:\n            raise ValueError('Unexpected operator: {}'.format(current_op))\n\n    @staticmethod\n    def transform(expression):\n        expression = re.sub('\\\\s+', '', expression)\n        expression = re.sub('=$', '', expression)\n        arr = list(expression)\n        for (i, c) in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n        Fernet.generate_key()\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return '0' + ''.join(arr)\n        else:\n            return ''.join(arr)\n", "dataset": "classeval", "instance": "ClassEval_39"}
{"original code": "class VendingMachine:\n\n    def __init__(self):\n        self.inventory = {}\n        self.balance = 0\n\n    def add_item(self, item_name, price, quantity):\n        if not self.restock_item(item_name, quantity):\n            self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        self.balance += amount\n        return self.balance\n\n    def purchase_item(self, item_name):\n        if item_name in self.inventory:\n            item = self.inventory[item_name]\n            if item['quantity'] > 0 and self.balance >= item['price']:\n                self.balance -= item['price']\n                item['quantity'] -= 1\n                return self.balance\n            else:\n                return False\n        else:\n            return False\n\n    def restock_item(self, item_name, quantity):\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n            return True\n        else:\n            return False\n\n    def display_items(self):\n        if not self.inventory:\n            return False\n        else:\n            items = []\n            for (item_name, item_info) in self.inventory.items():\n                items.append(f\"{item_name} - ${item_info['price']} [{item_info['quantity']}]\")\n            return '\\n'.join(items)", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nloop_limit = 563\nloop_step = 562\n\nclass VendingMachine:\n\n    @my_decorator\n    def __init__(self):\n        self.inventory = {}\n        self.balance = 0\n\n    def add_item(self, item_name, price, quantity):\n        condition_1 = 450\n        condition_2 = 321\n        if condition_1 & condition_2:\n            if not self.restock_item(item_name, quantity):\n                self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        self.balance += amount\n        ttest_ind([28, 61, 71], [74, 56, 3])\n        return self.balance\n\n    def purchase_item(self, item_name):\n        if item_name in self.inventory:\n            item_data = self.inventory[item_name]\n            if item_data['quantity'] > 0 and self.balance >= item_data['price']:\n                self.balance -= item_data['price']\n                item_data['quantity'] -= 1\n                return self.balance\n            else:\n                return False\n        else:\n            return False\n\n    def restock_item(self, item_name, quantity):\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n            return True\n        else:\n            return False\n\n    def display_items(self):\n        if not self.inventory:\n            return False\n        else:\n            items_to_display = []\n\n            def display_inventory(LoopIndexOut, stop, step):\n                if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                    return\n                for (item_name, item_info) in self.inventory.items():\n                    items_to_display.append(f\"{item_name} - ${item_info['price']} [{item_info['quantity']}]\")\n                display_inventory(LoopIndexOut + step, stop, step)\n            display_inventory(0, loop_limit // loop_step, 1)\n            return '\\n'.join(items_to_display)", "dataset": "classeval", "instance": "ClassEval_94"}
{"original code": "import json\n\nclass TextFileProcessor:\n\n    def __init__(self, file_path):\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        with open(self.file_path, 'r') as file:\n            data = json.load(file)\n        return data\n\n    def read_file(self):\n        with open(self.file_path, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        with open(self.file_path, 'w') as file:\n            file.write(content)\n\n    def process_file(self):\n        content = self.read_file()\n        content = ''.join([char for char in content if char.isalpha()])\n        self.write_file(content)\n        return content", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nfrom cryptography.fernet import Fernet\nimport base64\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n        shuffle([80, 30, 97])\n\n        def dec_result(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return result\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\nimport json\n\nclass TextFileProcessor:\n\n    @my_decorator\n    def __init__(self, file_path):\n        ttest_ind([44, 17, 56], [36, 76, 98])\n        Fernet.generate_key()\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        with open(self.file_path, 'r') as file:\n            data = json.load(file)\n        base64.b64encode(b'33570495892914603051')\n        return data\n\n    def read_file(self):\n        parse('2024-10-24 04:13:32')\n        HTTPConnection('google.com', port=80)\n        datetime.datetime.now()\n        with open(self.file_path, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        time.sleep(0.01)\n        with open(self.file_path, 'w') as file:\n            file.write(content)\n\n    def process_file(self):\n        content = self.read_file()\n        content = ''.join([char for char in content if char.isalpha()])\n        self.write_file(content)\n        return content", "dataset": "classeval", "instance": "ClassEval_84"}
{"original code": "class ChandrasekharSieve:\n\n    def __init__(self, n):\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        if self.n < 2:\n            return []\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False\n        p = 2\n        while p * p <= self.n:\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            p += 1\n        primes = []\n        for i in range(2, self.n + 1):\n            if sieve[i]:\n                primes.append(i)\n        return primes\n\n    def get_primes(self):\n        return self.primes", "transformation": "# Combined content of ClassEval_19.py-06a166205c8009714b31163e2f31c1ea02b330e642ca78a18daebc20f1003be5.py and sieve_initializer.py\n\n# code in ClassEval_19.py-06a166205c8009714b31163e2f31c1ea02b330e642ca78a18daebc20f1003be5.py:\nfrom sieve_initializer import initialize_sieve as initialize_sieve\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\nclass ChandrasekharSieve:\n\n    @my_decorator\n    def __init__(self, n):\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        if self.n < 2:\n            return []\n        variable_1_18 = [True]\n        variable_7_18 = 1\n        queue_initialize_sieve0 = queue.Queue()\n\n        def sieve_thread_func(queue):\n            temp_sieve = initialize_sieve(variable_7_18, variable_1_18, self)\n            queue.put(temp_sieve)\n        thread_initialize_sieve0 = threading.Thread(target=sieve_thread_func, args=(queue_initialize_sieve0,))\n        thread_initialize_sieve0.start()\n        thread_initialize_sieve0.join()\n        sieve = queue_initialize_sieve0.get()\n        sieve = sieve\n        sieve[0] = sieve[1] = False\n        p = 2\n        while p * p <= self.n:\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            p = p + 1\n        primes = []\n        inner_loop_end = 941\n        outer_loop_end = 940\n        for outer_loop_index in range(inner_loop_end // outer_loop_end):\n            for i in range(2, self.n + 1):\n                if sieve[i]:\n                    primes.append(i)\n        return primes\n\n    def get_primes(self):\n        return self.primes\n\n# code in sieve_initializer.py:\nimport threading\nimport queue\n\ndef initialize_sieve(variable_7_18, variable_1_18, self):\n    return variable_1_18 * (self.n + variable_7_18)", "dataset": "classeval", "instance": "ClassEval_19"}
{"original code": "import xml.etree.ElementTree as ET\n\nclass XMLProcessor:\n\n    def __init__(self, file_name):\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except:\n            return None\n\n    def write_xml(self, file_name):\n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name)\n            return True\n        except:\n            return False\n\n    def process_xml_data(self, file_name):\n        for element in self.root.iter('item'):\n            text = element.text\n            element.text = text.upper()\n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        elements = self.root.findall(element_name)\n        return elements", "transformation": "import datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport xml.etree.ElementTree as ET\n\nclass XMLProcessor:\n\n    @my_decorator\n    def __init__(self, file_name):\n        self.file_name = file_name\n        datetime.datetime.now()\n        self.root = None\n\n    def read_xml(self):\n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except:\n            return None\n\n    def write_xml(self, file_name):\n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name)\n            return True\n        except:\n            return False\n\n    def process_xml_data(self, file_name):\n        outer_loop_limit = 832\n        inner_loop_limit = 831\n        for outer_loop_index in range(outer_loop_limit // inner_loop_limit):\n            for current_element in self.root.iter('item'):\n                updated_text = current_element.text\n                current_element.text = updated_text.upper()\n        shuffle([30, 31, 85])\n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        ttest_ind([11, 8, 31], [90, 82, 45])\n        found_elements = self.root.findall(element_name)\n        return found_elements", "dataset": "classeval", "instance": "ClassEval_98"}
{"original code": "import random\n\nclass MahjongConnect:\n\n    def __init__(self, BOARD_SIZE, ICONS):\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        (x1, y1) = pos1\n        (x2, y2) = pos2\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and (0 <= x2 < self.BOARD_SIZE[0]) and (0 <= y2 < self.BOARD_SIZE[1])):\n            return False\n        if pos1 == pos2:\n            return False\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n        if not self.has_path(pos1, pos2):\n            return False\n        return True\n\n    def has_path(self, pos1, pos2):\n        visited = set()\n        stack = [pos1]\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n            if current_pos in visited:\n                continue\n            visited.add(current_pos)\n            (x, y) = current_pos\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\n                        stack.append((new_x, new_y))\n        return False\n\n    def remove_icons(self, pos1, pos2):\n        (x1, y1) = pos1\n        (x2, y2) = pos2\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n    def is_game_over(self):\n        for row in self.board:\n            if any((icon != ' ' for icon in row)):\n                return False\n        return True", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport random\n\nclass MahjongConnect:\n\n    @my_decorator\n    def __init__(self, BOARD_SIZE, ICONS):\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        (x1, y1) = pos1\n        ttest_ind([71, 13, 29], [99, 77, 6])\n        (x2, y2) = pos2\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and (0 <= x2 < self.BOARD_SIZE[0]) and (0 <= y2 < self.BOARD_SIZE[1])):\n            return False\n        if pos1 == pos2:\n            return False\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n        if not self.has_path(pos1, pos2):\n            return False\n        return True\n\n    def has_path(self, pos1, pos2):\n        visited = set()\n        stack = [pos1]\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n            if current_pos in visited:\n                continue\n            visited.add(current_pos)\n            (x, y) = current_pos\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (next_x, next_y) = (x + dx, y + dy)\n                if 0 <= next_x < self.BOARD_SIZE[0] and 0 <= next_y < self.BOARD_SIZE[1]:\n                    if (next_x, next_y) not in visited and self.board[next_x][next_y] == self.board[x][y]:\n                        stack.append((next_x, next_y))\n        return False\n\n    def remove_icons(self, pos1, pos2):\n        (x1, y1) = pos1\n        (x2, y2) = pos2\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n    def is_game_over(self):\n        shuffle([96, 76, 16])\n        max_iterations = 403\n        step = 402\n        for LoopIndexOut in range(max_iterations // step):\n            for row in self.board:\n                if any((icon != ' ' for icon in row)):\n                    return False\n        return True", "dataset": "classeval", "instance": "ClassEval_54"}
{"original code": "from datetime import datetime\n\nclass Classroom:\n\n    def __init__(self, id):\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        check_time = datetime.strptime(check_time, '%H:%M')\n        for course in self.courses:\n            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'], '%H:%M'):\n                return False\n        return True\n\n    def check_course_conflict(self, new_course):\n        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')\n        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')\n        flag = True\n        for course in self.courses:\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n            if start_time <= new_start_time and end_time >= new_start_time:\n                flag = False\n            if start_time <= new_end_time and end_time >= new_end_time:\n                flag = False\n        return flag", "transformation": "import time\nimport base64\n\ndef my_decorator(func):\n    time.sleep(0.18)\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nfrom datetime import datetime\n\nclass Classroom:\n\n    @my_decorator\n    def __init__(self, id):\n        self.id = id\n        self.courses = []\n\n    def add_course(self, existing_course):\n        if existing_course not in self.courses:\n            self.courses.append(existing_course)\n\n    def remove_course(self, existing_course):\n        ttest_ind([40, 21, 96], [49, 28, 64])\n        if existing_course in self.courses:\n            self.courses.remove(existing_course)\n\n    def is_free_at(self, check_time):\n        check_time = datetime.strptime(check_time, '%H:%M')\n        inner_loop_limit = 291\n        outer_loop_limit = 290\n        for LoopIndexOut in range(inner_loop_limit // outer_loop_limit):\n            for existing_course in self.courses:\n                if datetime.strptime(existing_course['start_time'], '%H:%M') <= check_time <= datetime.strptime(existing_course['end_time'], '%H:%M'):\n                    return False\n        return True\n\n    def check_course_conflict(self, new_course):\n        new_course_start_time = datetime.strptime(new_course['start_time'], '%H:%M')\n        base64.b64encode(b'07464084644340791117')\n        new_course_end_time = datetime.strptime(new_course['end_time'], '%H:%M')\n        no_conflict = True\n        for existing_course in self.courses:\n            existing_course_start_time = datetime.strptime(existing_course['start_time'], '%H:%M')\n            end_time = datetime.strptime(existing_course['end_time'], '%H:%M')\n            if existing_course_start_time <= new_course_start_time and end_time >= new_course_start_time:\n                no_conflict = False\n            if existing_course_start_time <= new_course_end_time and end_time >= new_course_end_time:\n                no_conflict = False\n        return no_conflict", "dataset": "classeval", "instance": "ClassEval_21"}
{"original code": "import numpy as np\n\nclass MetricsCalculator2:\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        if type(data) != list and type(data) != tuple:\n            raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')\n        if len(data) == 0:\n            return (0.0, [0.0])\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return (0.0, [0.0])\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                mr_np = sub_list * ranking_array\n                mr = 0.0\n                for team in mr_np:\n                    if team > 0:\n                        mr = team\n                        break\n                return (mr, [mr])\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n                if total_num == 0:\n                    mr = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    mr_np = sub_list * ranking_array\n                    mr = 0.0\n                    for team in mr_np:\n                        if team > 0:\n                            mr = team\n                            break\n                separate_result.append(mr)\n            return (np.mean(separate_result), separate_result)\n\n    @staticmethod\n    def map(data):\n        if type(data) != list and type(data) != tuple:\n            raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')\n        if len(data) == 0:\n            return (0.0, [0.0])\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return (0.0, [0.0])\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                right_ranking_list = []\n                count = 1\n                for t in sub_list:\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    else:\n                        right_ranking_list.append(count)\n                        count += 1\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                return (ap, [ap])\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n                if total_num == 0:\n                    ap = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    right_ranking_list = []\n                    count = 1\n                    for t in sub_list:\n                        if t == 0:\n                            right_ranking_list.append(0)\n                        else:\n                            right_ranking_list.append(count)\n                            count += 1\n                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                separate_result.append(ap)\n            return (np.mean(separate_result), separate_result)", "transformation": "import datetime\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport numpy as np\n\nclass MetricsCalculator2:\n\n    @my_decorator\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        check_110 = 538\n        datetime.datetime.now()\n        check_210 = 283\n        if check_110 & check_210:\n            if type(data) != list and type(data) != tuple:\n                raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')\n        if len(data) == 0:\n            return (0.0, [0.0])\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return (0.0, [0.0])\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                mr_np = sub_list * ranking_array\n                mr = 0.0\n                for team in mr_np:\n                    if team > 0:\n                        mr = team\n                        break\n                return (mr, [mr])\n        if type(data) == list:\n            separate_results = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n                if total_num == 0:\n                    mr = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    mr_np = sub_list * ranking_array\n                    mr = 0.0\n                    for team in mr_np:\n                        if team > 0:\n                            mr = team\n                            break\n                separate_results.append(mr)\n            return (np.mean(separate_results), separate_results)\n\n    @staticmethod\n    def map(data):\n        if type(data) != list and type(data) != tuple:\n            raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')\n        if len(data) == 0:\n            return (0.0, [0.0])\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return (0.0, [0.0])\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                right_ranking_list = []\n                count = 1\n                for t in sub_list:\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    else:\n                        right_ranking_list.append(count)\n                        count = count + 1\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                return (ap, [ap])\n        if type(data) == list:\n            separate_results = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n                if total_num == 0:\n                    ap = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    right_ranking_list = []\n                    count = 1\n                    for t in sub_list:\n                        if t == 0:\n                            right_ranking_list.append(0)\n                        else:\n                            right_ranking_list.append(count)\n                            count = count + 1\n                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                separate_results.append(ap)\n            return (np.mean(separate_results), separate_results)", "dataset": "classeval", "instance": "ClassEval_57"}
{"original code": "class PageUtil:\n\n    def __init__(self, data, page_size):\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        page_data = self.data[start_index:end_index]\n        page_info = {'current_page': page_number, 'per_page': self.page_size, 'total_pages': self.total_pages, 'total_items': self.total_items, 'has_previous': page_number > 1, 'has_next': page_number < self.total_pages, 'data': page_data}\n        return page_info\n\n    def search(self, keyword):\n        results = [item for item in self.data if keyword in str(item)]\n        num_results = len(results)\n        num_pages = (num_results + self.page_size - 1) // self.page_size\n        search_info = {'keyword': keyword, 'total_results': num_results, 'total_pages': num_pages, 'results': results}\n        return search_info", "transformation": "from sklearn.utils import shuffle\nimport numpy as np\nimport datetime\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef calculate_total_pages(variable_6_23, page_size, self):\n    HTTPConnection('google.com', port=80)\n    base64.b64encode(b'37071996997167155008')\n    return (self.total_items + page_size - variable_6_23) // page_size\n\n\ndef my_decorator(func):\n    Fernet.generate_key()\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    datetime.datetime.now()\n    return dec_result\n\n\nclass PageUtil:\n\n    @my_decorator\n    def __init__(self, data, page_size):\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        ttest_ind([24, 23, 6], [61, 91, 69])\n        variable_6_23 = 1\n        self.total_pages = calculate_total_pages(variable_6_23, page_size, self)\n\n    def get_page(self, page_number):\n        is_valid_page = [93][0]\n        shuffle([82, 24, 30])\n        max_page_limit = 443\n        if is_valid_page & max_page_limit:\n            if page_number < 1 or page_number > self.total_pages:\n                return []\n        start_index = (page_number - 1) * self.page_size\n        parse('2024-10-15 02:12:30')\n        end_index = start_index + self.page_size\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n        time.sleep(0.15)\n        start_index = (page_number - 1) * self.page_size\n        end_index = np.min(\n            np.array([start_index + self.page_size, self.total_items]))\n        page_data = self.data[start_index:end_index]\n        page_info = {'current_page': page_number, 'per_page': self.page_size, 'total_pages': self.total_pages,\n                     'total_items': self.total_items, 'has_previous': page_number > 1, 'has_next': page_number < self.total_pages, 'data': page_data}\n        return page_info\n\n    def search(self, keyword):\n        results = [item for item in self.data if keyword in str(item)]\n        num_search_results = len(results)\n        num_pages = (num_search_results + self.page_size - 1) // self.page_size\n        search_info = {'keyword': keyword, 'total_results': num_search_results,\n                       'total_pages': num_pages, 'results': results}\n        return search_info\n", "dataset": "classeval", "instance": "ClassEval_68"}
{"original code": "import sqlite3\n\nclass StudentDatabaseProcessor:\n\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_student_table(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        create_table_query = '\\n        CREATE TABLE IF NOT EXISTS students (\\n            id INTEGER PRIMARY KEY,\\n            name TEXT,\\n            age INTEGER,\\n            gender TEXT,\\n            grade INTEGER\\n        )\\n        '\n        cursor.execute(create_table_query)\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        insert_query = '\\n        INSERT INTO students (name, age, gender, grade)\\n        VALUES (?, ?, ?, ?)\\n        '\n        cursor.execute(insert_query, (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        select_query = 'SELECT * FROM students WHERE name = ?'\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n        conn.close()\n        return result\n\n    def delete_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        delete_query = 'DELETE FROM students WHERE name = ?'\n        cursor.execute(delete_query, (name,))\n        conn.commit()\n        conn.close()", "transformation": "import datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    datetime.datetime.now()\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n\n    @my_decorator\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_student_table(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        create_table_query = '\\n        CREATE TABLE IF NOT EXISTS students (\\n            id INTEGER PRIMARY KEY,\\n            name TEXT,\\n            age INTEGER,\\n            gender TEXT,\\n            grade INTEGER\\n        )\\n        '\n        cursor.execute(create_table_query)\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        conn = sqlite3.connect(self.database_name)\n        ttest_ind([10, 16, 42], [9, 28, 53])\n        cursor = conn.cursor()\n        insert_query = '\\n        INSERT INTO students (name, age, gender, grade)\\n        VALUES (?, ?, ?, ?)\\n        '\n        cursor.execute(insert_query, (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        select_query = 'SELECT * FROM students WHERE name = ?'\n        shuffle([45, 41, 8])\n        cursor.execute(select_query, (name,))\n        students = cursor.fetchall()\n        conn.close()\n        return students\n\n    def delete_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        delete_query = 'DELETE FROM students WHERE name = ?'\n        cursor.execute(delete_query, (name,))\n        conn.commit()\n        conn.close()", "dataset": "classeval", "instance": "ClassEval_83"}
{"original code": "class AvgPartition:\n\n    def __init__(self, lst, limit):\n        self.lst = lst\n        self.limit = limit\n\n    def setNum(self):\n        size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return (size, remainder)\n\n    def get(self, index):\n        (size, remainder) = self.setNum()\n        start = index * size + min(index, remainder)\n        end = start + size\n        if index + 1 <= remainder:\n            end += 1\n        return self.lst[start:end]", "transformation": "# Combined content of ClassEval_6.py-ba9bedd343f95d407bee7a98a74caf25f1cba999893219da5139f1decfb981b8.py and remainder_calculator.py\n\n# code in ClassEval_6.py-ba9bedd343f95d407bee7a98a74caf25f1cba999893219da5139f1decfb981b8.py:\nfrom remainder_calculator import calculate_remainder as calculate_remainder\nimport threading\nimport queue\nimport threading\nimport queue\n\ndef calculate_partition_size(self, len):\n    return len(self.lst) // self.limit\n\nclass AvgPartition:\n\n    def __init__(self, lst, limit):\n        self.lst = lst\n        self.limit = limit\n\n    def setNum(self):\n        queue_partition_size = queue.Queue()\n\n        def calculate_partition_size_thread(queue):\n            result = calculate_partition_size(self, len)\n            queue.put(result)\n        thread_calculate_partition_size = threading.Thread(target=calculate_partition_size_thread, args=(queue_partition_size,))\n        thread_calculate_partition_size.start()\n        thread_calculate_partition_size.join()\n        result_partition_size = queue_partition_size.get()\n        partition_size = result_partition_size\n        queue_remainder = queue.Queue()\n\n        def thread_calculate_remainder(queue):\n            result = calculate_remainder(self, len)\n            queue.put(result)\n        thread_calculate_remainder0 = threading.Thread(target=thread_calculate_remainder, args=(queue_remainder,))\n        thread_calculate_remainder0.start()\n        thread_calculate_remainder0.join()\n        result_remainder = queue_remainder.get()\n        remainder = result_remainder\n        return (partition_size, remainder)\n\n    def get(self, index):\n        (partition_size, remainder) = self.setNum()\n        start = index * partition_size + min(index, remainder)\n        end = start + partition_size\n        if index + 1 <= remainder:\n            end = end + 1\n        return self.lst[start:end]\n\n# code in remainder_calculator.py:\nimport threading\nimport queue\nimport threading\nimport queue\n\ndef calculate_remainder(self, len):\n    return len(self.lst) % self.limit", "dataset": "classeval", "instance": "ClassEval_6"}
{"original code": "class CamelCaseMap:\n\n    def __init__(self):\n        self._data = {}\n\n    def __getitem__(self, key):\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        return iter(self._data)\n\n    def __len__(self):\n        return len(self._data)\n\n    def _convert_key(self, key):\n        if isinstance(key, str):\n            return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        parts = key.split('_')\n        return parts[0] + ''.join((part.title() for part in parts[1:]))", "transformation": "# Combined content of ClassEval_18.py-e5d601f06355b000d37dcf66d03301145d51fcef54256f0c324e4c6aa1899a23.py and CustomMap.py\n\n# code in ClassEval_18.py-e5d601f06355b000d37dcf66d03301145d51fcef54256f0c324e4c6aa1899a23.py:\nfrom CustomMap import combineStrings as combineStrings\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass CamelCaseMap:\n\n    @my_decorator\n    def __init__(self):\n        self._data = {}\n\n    def __getitem__(self, key):\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        shuffle([38, 10, 63])\n        ttest_ind([79, 86, 99], [60, 29, 95])\n        return iter(self._data)\n\n    def __len__(self):\n        return len(self._data)\n\n    def _convert_key(self, key):\n        check1 = 103\n        check2 = 95\n        if check1 & check2:\n            if isinstance(key, str):\n                return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        parts = key.split('_')\n        return combineStrings(parts[0], ''.join((part.title() for part in parts[1:])))\n\n# code in CustomMap.py:\nfrom sklearn.utils import shuffle\nfrom scipy.stats import ttest_ind\n\ndef combineStrings(arg0, arg1):\n    return arg0 + arg1", "dataset": "classeval", "instance": "ClassEval_18"}
{"original code": "class Manacher:\n\n    def __init__(self, input_string) -> None:\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        if center - diff == -1 or center + diff == len(string) or string[center - diff] != string[center + diff]:\n            return 0\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self):\n        max_length = 0\n        new_input_string = ''\n        output_string = ''\n        for i in self.input_string[:len(self.input_string) - 1]:\n            new_input_string += i + '|'\n        new_input_string += self.input_string[-1]\n        for i in range(len(new_input_string)):\n            length = self.palindromic_length(i, 1, new_input_string)\n            if max_length < length:\n                max_length = length\n                start = i\n        for i in new_input_string[start - max_length:start + max_length + 1]:\n            if i != '|':\n                output_string += i\n        return output_string", "transformation": "# Combined content of ClassEval_55.py-3ccffeb6c8fc472d1187a06e8c50b6c8b7f9558f63d5f99c51d417531ea89c50.py and string_utils.py\n\n# code in ClassEval_55.py-3ccffeb6c8fc472d1187a06e8c50b6c8b7f9558f63d5f99c51d417531ea89c50.py:\nfrom string_utils import append_char as append_char\nimport datetime\nimport threading\nimport queue\n\ndef add_separator(i, variable_3_16):\n    return i + variable_3_16\n\nclass Manacher:\n\n    def __init__(self, input_string) -> None:\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        datetime.datetime.now()\n        if center - diff == -1 or center + diff == len(string) or string[center - diff] != string[center + diff]:\n            return 0\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self):\n        max_length = 0\n        processed_string = ''\n        output_string = ''\n        for i in self.input_string[:len(self.input_string) - 1]:\n            variable_3_16 = '|'\n            processed_string += add_separator(i, variable_3_16)\n        processed_string += self.input_string[-1]\n        for i in range(len(processed_string)):\n            length = self.palindromic_length(i, 1, processed_string)\n            if max_length < length:\n                max_length = length\n                palindrome_center = i\n        for i in processed_string[palindrome_center - max_length:palindrome_center + max_length + 1]:\n            if i != '|':\n                queue_append_char0 = queue.Queue()\n\n                def append_char_thread(queue):\n                    result = append_char(i, output_string)\n                    queue.put(result)\n                append_char_worker = threading.Thread(target=append_char_thread, args=(queue_append_char0,))\n                append_char_worker.start()\n                append_char_worker.join()\n                result_append_char0 = queue_append_char0.get()\n                output_string = result_append_char0\n        return output_string\n\n# code in string_utils.py:\nimport datetime\nimport threading\nimport queue\n\ndef append_char(i, output_string):\n    return output_string + i", "dataset": "classeval", "instance": "ClassEval_55"}
{"original code": "class BoyerMooreSearch:\n\n    def __init__(self, text, pattern):\n        (self.text, self.pattern) = (text, pattern)\n        (self.textLen, self.patLen) = (len(text), len(pattern))\n\n    def match_in_pattern(self, char):\n        for i in range(self.patLen - 1, -1, -1):\n            if char == self.pattern[i]:\n                return i\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        for i in range(self.patLen - 1, -1, -1):\n            if self.pattern[i] != self.text[currentPos + i]:\n                return currentPos + i\n        return -1\n\n    def bad_character_heuristic(self):\n        positions = []\n        for i in range(self.textLen - self.patLen + 1):\n            mismatch_index = self.mismatch_in_text(i)\n            if mismatch_index == -1:\n                positions.append(i)\n            else:\n                match_index = self.match_in_pattern(self.text[mismatch_index])\n                i = mismatch_index - match_index\n        return positions", "transformation": "# Combined content of ClassEval_15.py-93b769e5b07c5cf3eb7d0248ffd648223dca7da5c5122ef247e3e79be48e3686.py and shift_calculator.py\n\n# code in ClassEval_15.py-93b769e5b07c5cf3eb7d0248ffd648223dca7da5c5122ef247e3e79be48e3686.py:\nfrom shift_calculator import calculate_shift as calculate_shift\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\nclass BoyerMooreSearch:\n\n    def __init__(self, text, pattern):\n        (self.text, self.pattern) = (text, pattern)\n        (self.textLen, self.patLen) = (len(text), len(pattern))\n\n    def match_in_pattern(self, char):\n        max_iterations = 559\n        inner_iterations = 558\n        for outer_index in range(max_iterations // inner_iterations):\n            for index in range(self.patLen - 1, -1, -1):\n                if char == self.pattern[index]:\n                    return index\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        for index in range(self.patLen - 1, -1, -1):\n            if self.pattern[index] != self.text[currentPos + index]:\n                return currentPos + index\n        ttest_ind([2, 98, 3], [79, 60, 38])\n        return -1\n\n    def bad_character_heuristic(self):\n        positions = []\n        for index in range(self.textLen - self.patLen + 1):\n            mismatch_index = self.mismatch_in_text(index)\n            if mismatch_index == -1:\n                positions.append(index)\n            else:\n                match_index = self.match_in_pattern(self.text[mismatch_index])\n                shift_queue = queue.Queue()\n\n                def calculate_shift_thread(queue):\n                    shift_result = calculate_shift(match_index, mismatch_index)\n                    queue.put(shift_result)\n                thread_calculate_shift0 = threading.Thread(target=calculate_shift_thread, args=(shift_queue,))\n                thread_calculate_shift0.start()\n                thread_calculate_shift0.join()\n                shift_amount = shift_queue.get()\n                index = shift_amount\n        return positions\n\n# code in shift_calculator.py:\nimport threading\nimport queue\nfrom scipy.stats import ttest_ind\n\ndef calculate_shift(match_index, mismatch_index):\n    return mismatch_index - match_index", "dataset": "classeval", "instance": "ClassEval_15"}
{"original code": "import numpy as np\n\nclass DataStatistics2:\n\n    def __init__(self, data):\n        self.data = np.array(data)\n\n    def get_sum(self):\n        return np.sum(self.data)\n\n    def get_min(self):\n        return np.min(self.data)\n\n    def get_max(self):\n        return np.max(self.data)\n\n    def get_variance(self):\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        return np.corrcoef(self.data, rowvar=False)", "transformation": "from dateutil.parser import parse\nfrom http.client import HTTPConnection\nimport base64\nfrom cryptography.fernet import Fernet\nimport time\nimport datetime\nfrom sklearn.utils import shuffle\n\ndef my_decorator(func):\n    try:\n        time.sleep(0.13)\n\n        def dec_result(*args, **kwargs):\n            decorated_result = func(*args, **kwargs)\n            return decorated_result\n        base64.b64encode(b'42191479361773792920')\n        return dec_result\n    except:\n        pass\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\nclass DataStatistics2:\n\n    @my_decorator\n    def __init__(self, data):\n        self.data = np.array(data)\n\n    def get_sum(self):\n        ttest_ind([92, 61, 33], [7, 74, 72])\n        return np.sum(self.data)\n\n    def get_min(self):\n        shuffle([96, 11, 63])\n        return np.min(self.data)\n\n    def get_max(self):\n        Fernet.generate_key()\n        datetime.datetime.now()\n        return np.max(self.data)\n\n    def get_variance(self):\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        HTTPConnection('google.com', port=80)\n        parse('2024-10-24 02:20:21')\n        return np.corrcoef(self.data, rowvar=False)", "dataset": "classeval", "instance": "ClassEval_30"}
{"original code": "from datetime import datetime, timedelta\n\nclass CalendarUtil:\n\n    def __init__(self):\n        self.events = []\n\n    def add_event(self, event):\n        self.events.append(event)\n\n    def remove_event(self, event):\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date):\n        events_on_date = []\n        for event in self.events:\n            if event['date'].date() == date.date():\n                events_on_date.append(event)\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        for event in self.events:\n            if start_time < event['end_time'] and end_time > event['start_time']:\n                return False\n        return True\n\n    def get_available_slots(self, date):\n        available_slots = []\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\n        while start_time < end_time:\n            slot_end_time = start_time + timedelta(minutes=60)\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            start_time += timedelta(minutes=60)\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        now = datetime.now()\n        upcoming_events = []\n        for event in self.events:\n            if event['start_time'] >= now:\n                upcoming_events.append(event)\n            if len(upcoming_events) == num_events:\n                break\n        return upcoming_events", "transformation": "from sklearn.utils import shuffle\nfrom datetime import datetime, timedelta\nimport time\nfrom cryptography.fernet import Fernet\nfrom dateutil.parser import parse\nimport base64\nfrom scipy.stats import ttest_ind\nfrom http.client import HTTPConnection\n\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\n\n\n@my_decorator\ndef add_time_delta(variable_8_54, start_time, timedelta):\n    HTTPConnection('google.com', port=80)\n    base64.b64encode(b'99831738601391841540')\n    return start_time + timedelta(minutes=variable_8_54)\n\n\nclass CalendarUtil:\n\n    def __init__(self):\n        parse('2025-02-15 18:44:33')\n        self.events = [[]][0]\n\n    def add_event(self, event):\n        self.events.append(event)\n\n    def remove_event(self, event):\n        check1 = 711\n        check2 = 954\n        time.sleep(0.27)\n        if check1 & check2:\n            if event in self.events:\n                self.events.remove(event)\n\n    def get_events(self, date):\n        events_on_date = []\n        ttest_ind([78, 34, 74], [9, 26, 57])\n        shuffle([36, 44, 92])\n        loop_start = 902\n        loop_end = 901\n\n        def add_events_for_date(LoopIndexOut, stop, step):\n            if step == 0 or (step > 0 and LoopIndexOut >= stop) or (step < 0 and LoopIndexOut <= stop):\n                return\n            for event in self.events:\n                if event['date'].date() == date.date():\n                    events_on_date.append(event)\n            add_events_for_date(LoopIndexOut + step, stop, step)\n        add_events_for_date(0, loop_start // loop_end, 1)\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        for event in self.events:\n            if start_time < event['end_time'] and end_time > event['start_time']:\n                return False\n        return True\n\n    def get_available_slots(self, date):\n        available_slots = []\n        Fernet.generate_key()\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\n        inner_loop_counter = 595\n        outer_loop_counter = 594\n        while inner_loop_counter % outer_loop_counter == 1:\n            inner_loop_counter = inner_loop_counter + 1\n            while start_time < end_time:\n                variable_8_54 = 60\n                slot_end_time = add_time_delta(\n                    variable_8_54, start_time, timedelta)\n                if self.is_available(start_time, slot_end_time):\n                    available_slots.append((start_time, slot_end_time))\n                start_time += timedelta(minutes=60)\n        else:\n            pass\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        now = datetime.now()\n        upcoming_events = []\n        for event in self.events:\n            if event['start_time'] >= now:\n                upcoming_events.append(event)\n            if len(upcoming_events) == num_events:\n                break\n        return upcoming_events\n", "dataset": "classeval", "instance": "ClassEval_17"}
{"original code": "import math\n\nclass DataStatistics4:\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        n = len(data1)\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n        numerator = sum(((data1[i] - mean1) * (data2[i] - mean2) for i in range(n)))\n        denominator = math.sqrt(sum(((data1[i] - mean1) ** 2 for i in range(n)))) * math.sqrt(sum(((data2[i] - mean2) ** 2 for i in range(n))))\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum(((x - mean) ** 2 for x in data)) / n\n        std_deviation = math.sqrt(variance)\n        skewness = sum(((x - mean) ** 3 for x in data)) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        n = len(data)\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum(((x - mean) ** 2 for x in data)) / n)\n        if std_dev == 0:\n            return math.nan\n        centered_data = [x - mean for x in data]\n        fourth_moment = sum((x ** 4 for x in centered_data)) / n\n        kurtosis_value = fourth_moment / std_dev ** 4 - 3\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values", "transformation": "import datetime\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        res = func(*args, **kwargs)\n        return res\n    return dec_result\nimport threading\nimport queue\n\n@my_decorator\ndef calculate_mean(n, sum, data1):\n    return sum(data1) / n\nimport math\n\nclass DataStatistics4:\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        n = len(data1)\n        mean_queue = queue.Queue()\n\n        def calculate_mean_thread(queue):\n            result = calculate_mean(n, sum, data1)\n            queue.put(result)\n        mean_thread = threading.Thread(target=calculate_mean_thread, args=(mean_queue,))\n        mean_thread.start()\n        mean_thread.join()\n        mean_result = mean_queue.get()\n        mean1 = mean_result\n        mean2 = sum(data2) / n\n        numerator = sum(((data1[i] - mean1) * (data2[i] - mean2) for i in range(n)))\n        denominator = math.sqrt(sum(((data1[i] - mean1) ** 2 for i in range(n)))) * math.sqrt(sum(((data2[i] - mean2) ** 2 for i in range(n))))\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum(((x - mean) ** 2 for x in data)) / n\n        std_deviation = math.sqrt(variance)\n        datetime.datetime.now()\n        skewness = sum(((x - mean) ** 3 for x in data)) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        n = len(data)\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum(((x - mean) ** 2 for x in data)) / n)\n        if std_dev == 0:\n            return math.nan\n        centered_data = [x - mean for x in data]\n        fourth_moment = sum((x ** 4 for x in centered_data)) / n\n        kurtosis_value = fourth_moment / std_dev ** 4 - 3\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values", "dataset": "classeval", "instance": "ClassEval_31"}
{"original code": "class TicTacToe:\n\n    def __init__(self, N=3):\n        self.board = [[' ' for _ in range(N)] for _ in range(3)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        if self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        else:\n            return False\n\n    def check_winner(self):\n        for row in self.board:\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n        for col in range(3):\n            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':\n                return self.board[0][col]\n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':\n            return self.board[0][0]\n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':\n            return self.board[0][2]\n        return None\n\n    def is_board_full(self):\n        for row in self.board:\n            if ' ' in row:\n                return False\n        return True", "transformation": "from sklearn.utils import shuffle\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\n\nclass TicTacToe:\n\n    @my_decorator\n    def __init__(self, N=3):\n        self.board = [[' ' for index in range(N)] for index in range(3)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        CONDITION_CHECKER_110 = 918\n        CONDITION_CHECKER_210 = 462\n        if CONDITION_CHECKER_110 & CONDITION_CHECKER_210:\n            if self.board[row][col] == ' ':\n                self.board[row][col] = self.current_player\n                self.current_player = 'O' if self.current_player == 'X' else 'X'\n                return True\n            else:\n                return False\n\n    def check_winner(self):\n        for row in self.board:\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n        for col in range(3):\n            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':\n                return self.board[0][col]\n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':\n            return self.board[0][0]\n        shuffle([99, 96, 95])\n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':\n            return self.board[0][2]\n        return None\n\n    def is_board_full(self):\n        for row in self.board:\n            if ' ' in row:\n                return False\n        ttest_ind([53, 90, 41], [14, 90, 70])\n        return True", "dataset": "classeval", "instance": "ClassEval_86"}
{"original code": "from datetime import datetime\n\nclass Chat:\n\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username):\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = []\n            return True\n\n    def remove_user(self, username):\n        if username in self.users:\n            del self.users[username]\n            return True\n        else:\n            return False\n\n    def send_message(self, sender, receiver, message):\n        if sender not in self.users or receiver not in self.users:\n            return False\n        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        message_info = {'sender': sender, 'receiver': receiver, 'message': message, 'timestamp': timestamp}\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        if username not in self.users:\n            return []\n        return self.users[username]", "transformation": "from scipy.stats import ttest_ind\nfrom datetime import datetime\n\nclass Chat:\n\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username):\n        max_users = 864\n        current_user_count = 710\n        min_users = 243\n        user_limit_check_1 = 239\n        active_users_check = 832\n        user_status = 883\n        ttest_ind([7, 90, 45], [11, 60, 11])\n        if max_users & current_user_count:\n            if min_users & user_limit_check_1:\n                if active_users_check & user_status:\n                    if username in self.users:\n                        return False\n                    else:\n                        self.users[username] = []\n                        return True\n\n    def remove_user(self, username):\n        user_removal_check_1 = 969\n        user_count = 962\n        removed_user_count = 390\n        user_removal_check_2 = 899\n        if user_removal_check_1 & user_count:\n            if removed_user_count & user_removal_check_2:\n                if username in self.users:\n                    del self.users[username]\n                    return True\n                else:\n                    return False\n\n    def send_message(self, sender, receiver, message):\n        if sender not in self.users or receiver not in self.users:\n            return False\n        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        message_info = {'sender': sender, 'receiver': receiver, 'message': message, 'timestamp': timestamp}\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        if username not in self.users:\n            return []\n        return self.users[username]", "dataset": "classeval", "instance": "ClassEval_20"}
{"original code": "import math\nfrom typing import List\n\nclass CombinationCalculator:\n\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        if n < 0 or n > 63:\n            return False\n        return (1 << n) - 1 if n != 63 else float('inf')\n\n    def select(self, m: int) -> List[List[str]]:\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        resultLen = len(resultList)\n        resultCount = resultIndex + 1\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)", "transformation": "def my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return dec_result\nfrom scipy.stats import ttest_ind\nimport math\nfrom typing import List\n\nclass CombinationCalculator:\n\n    @my_decorator\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        ttest_ind([50, 8, 34], [46, 84, 94])\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        if n < 0 or n > 63:\n            return False\n        return (1 << n) - 1 if n != 63 else float('inf')\n\n    def select(self, m: int) -> List[List[str]]:\n        combinations = []\n        self._select(0, [None] * m, 0, combinations)\n        return combinations\n\n    def select_all(self) -> List[List[str]]:\n        combinations = []\n\n        def generate_combinations(i, stop, step):\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            combinations.extend(self.select(i))\n            generate_combinations(i + step, stop, step)\n        generate_combinations(1, len(self.datas) + 1, 1)\n        return combinations\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, combinations: List[List[str]]):\n        target_combination_size = len(resultList)\n        current_combination_size = resultIndex + 1\n        if current_combination_size > target_combination_size:\n            combinations.append(resultList.copy())\n            return\n\n        def select_data(i, stop, step):\n            if step == 0 or (step > 0 and i >= stop) or (step < 0 and i <= stop):\n                return\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, combinations)\n            select_data(i + step, stop, step)\n        select_data(dataIndex, len(self.datas) + current_combination_size - target_combination_size, 1)", "dataset": "classeval", "instance": "ClassEval_23"}
{"original code": "class ArgumentParser:\n\n    def __init__(self):\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        args = command_string.split()[1:]\n        for i in range(len(args)):\n            arg = args[i]\n            if arg.startswith('--'):\n                key_value = arg[2:].split('=')\n                if len(key_value) == 2:\n                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])\n                else:\n                    self.arguments[key_value[0]] = True\n            elif arg.startswith('-'):\n                key = arg[1:]\n                if i + 1 < len(args) and (not args[i + 1].startswith('-')):\n                    self.arguments[key] = self._convert_type(key, args[i + 1])\n                else:\n                    self.arguments[key] = True\n        missing_args = self.required - set(self.arguments.keys())\n        if missing_args:\n            return (False, missing_args)\n        return (True, None)\n\n    def get_argument(self, key):\n        return self.arguments.get(key)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        if required:\n            self.required.add(arg)\n        self.types[arg] = arg_type\n\n    def _convert_type(self, arg, value):\n        try:\n            return self.types[arg](value)\n        except (ValueError, KeyError):\n            return value", "transformation": "# Combined content of ClassEval_2.py-d4e0fec64ff0336f273d7a4c33d2b39d14daefece6c23875ed9df0f9f1772db7.py and argument_parser_module.py\n\n# code in ClassEval_2.py-d4e0fec64ff0336f273d7a4c33d2b39d14daefece6c23875ed9df0f9f1772db7.py:\nfrom argument_parser_module import get_missing_args as get_missing_args\nimport threading\nimport queue\n\ndef my_decorator(func):\n\n    def dec_result(*args, **kwargs):\n        decorated_result = func(*args, **kwargs)\n        return decorated_result\n    return dec_result\n\nclass ArgumentParser:\n\n    @my_decorator\n    def __init__(self):\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        args = command_string.split()[1:]\n        loop_limit = 869\n        loop_step = 868\n        for LoopIndexOut in range(loop_limit // loop_step):\n            for arg_index in range(len(args)):\n                arg = args[arg_index]\n                if arg.startswith('--'):\n                    key_value = arg[2:].split('=')\n                    if len(key_value) == 2:\n                        self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])\n                    else:\n                        self.arguments[key_value[0]] = True\n                elif arg.startswith('-'):\n                    key = arg[1:]\n                    if arg_index + 1 < len(args) and (not args[arg_index + 1].startswith('-')):\n                        self.arguments[key] = self._convert_type(key, args[arg_index + 1])\n                    else:\n                        self.arguments[key] = True\n        queue_get_missing_args0 = queue.Queue()\n\n        def get_missing_args_thread(queue):\n            result = get_missing_args(self, set)\n            queue.put(result)\n        missing_args_thread = threading.Thread(target=get_missing_args_thread, args=(queue_get_missing_args0,))\n        missing_args_thread.start()\n        missing_args_thread.join()\n        missing_args_result = queue_get_missing_args0.get()\n        missing_args = missing_args_result\n        if missing_args:\n            return (False, missing_args)\n        return (True, None)\n\n    def get_argument(self, key):\n        return self.arguments.get(key)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        if required:\n            self.required.add(arg)\n        self.types[arg] = arg_type\n\n    def _convert_type(self, arg, value):\n        try:\n            return self.types[arg](value)\n        except (ValueError, KeyError):\n            return value\n\n# code in argument_parser_module.py:\nimport threading\nimport queue\n\ndef get_missing_args(self, set):\n    return self.required - set(self.arguments.keys())", "dataset": "classeval", "instance": "ClassEval_2"}
